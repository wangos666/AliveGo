{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nconst URL = require(\"./url\");\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\n\n\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\n\nexports.getArg = getArg;\n\nconst supportsNullProto = function () {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}();\n\nfunction identity(s) {\n  return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\n\n\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\n\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\n\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9\n  /* \"__proto__\".length */\n  ) {\n    return false;\n  }\n  /* eslint-disable no-multi-spaces */\n\n\n  if (s.charCodeAt(length - 1) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 2) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 3) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 4) !== 116\n  /* 't' */\n  || s.charCodeAt(length - 5) !== 111\n  /* 'o' */\n  || s.charCodeAt(length - 6) !== 114\n  /* 'r' */\n  || s.charCodeAt(length - 7) !== 112\n  /* 'p' */\n  || s.charCodeAt(length - 8) !== 95\n  /* '_' */\n  || s.charCodeAt(length - 9) !== 95\n  /* '_' */\n  ) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36\n    /* '$' */\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\n\n\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\n\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\n\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\n\nexports.parseSourceMapInput = parseSourceMapInput; // We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\n\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\n\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n    cb(url);\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    } // This assumes that the callback will only change\n    // the path, search and hash values.\n\n\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n\n  do {\n    const ident = prefix + id++;\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1; // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n\n  const segment = buildUniqueSegment(\"p\", str);\n  let base = `${PROTOCOL_AND_HOST}/`;\n\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\n\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\n\n\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\"); // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (targetParts.length > 0 && rootParts.length > 0 && targetParts[0] === rootParts[0]) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts.map(() => \"..\").concat(targetParts).join(\"/\");\n  return relativePath + targetURL.search + targetURL.hash;\n}\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\n\n\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n/**\n * Given a URL, strip off any filename if one is present.\n *\n * @param url\n * @return A normalized URL value.\n */\n\nconst trimFilename = createSafeHandler(url => {\n  url.href = new URL(\".\", url.toString()).toString();\n});\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\n\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\n\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL.length);\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL_AND_HOST.length);\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\n\nexports.join = join;\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\n\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\n\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (target.protocol !== root.protocol || target.user !== root.user || target.password !== root.password || target.hostname !== root.hostname || target.port !== root.port) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\n\n\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  // The source map spec states that \"sourceRoot\" and \"sources\" entries are to be appended. While\n  // that is a little vague, implementations have generally interpreted that as joining the\n  // URLs with a `/` between then, assuming the \"sourceRoot\" doesn't already end with one.\n  // For example,\n  //\n  //   sourceRoot: \"some-dir\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // and\n  //\n  //   sourceRoot: \"some-dir/\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // must behave as \"some-dir/some-path.js\".\n  //\n  // With this library's the transition to a more URL-focused implementation, that behavior is\n  // preserved here. To acheive that, we trim the \"/\" from absolute-path when a sourceRoot value\n  // is present in order to make the sources entries behave as if they are relative to the\n  // \"sourceRoot\", as they would have if the two strings were simply concated.\n  if (sourceRoot && getURLType(sourceURL) === \"path-absolute\") {\n    sourceURL = sourceURL.replace(/^\\//, \"\");\n  }\n\n  let url = normalize(sourceURL || \"\"); // Parsing URLs can be expensive, so we only perform these joins when needed.\n\n  if (sourceRoot) url = join(sourceRoot, url);\n  if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);\n  return url;\n}\n\nexports.computeSourceURL = computeSourceURL;","map":{"version":3,"names":["URL","require","getArg","aArgs","aName","aDefaultValue","arguments","length","Error","exports","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","slice","charCodeAt","i","strcmp","aStr1","aStr2","compareByGeneratedPositionsInflated","mappingA","mappingB","cmp","generatedLine","generatedColumn","source","originalLine","originalColumn","name","parseSourceMapInput","str","JSON","parse","replace","PROTOCOL","PROTOCOL_AND_HOST","createSafeHandler","cb","input","type","getURLType","base","buildSafeBase","url","result","toString","computeRelativeURL","withBase","buildUniqueSegment","prefix","id","ident","indexOf","maxDotParts","split","segment","ABSOLUTE_SCHEME","test","rootURL","targetURL","targetParts","pathname","rootParts","pop","shift","relativePath","map","concat","join","search","hash","ensureDirectory","trimFilename","href","normalize","aRoot","aPath","pathType","rootType","undefined","newPath","relative","relativeIfPossible","urlType","root","target","err","protocol","user","password","hostname","port","computeSourceURL","sourceRoot","sourceURL","sourceMapURL"],"sources":["D:/web/Vue/shop/node_modules/terser/node_modules/source-map/lib/util.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst URL = require(\"./url\");\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n// We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n\n    cb(url);\n\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    }\n\n    // This assumes that the callback will only change\n    // the path, search and hash values.\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n  do {\n    const ident = prefix + (id++);\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1;\n\n  // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n  const segment = buildUniqueSegment(\"p\", str);\n\n  let base = `${PROTOCOL_AND_HOST}/`;\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\");\n\n  // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (\n    targetParts.length > 0 &&\n    rootParts.length > 0 &&\n    targetParts[0] === rootParts[0]\n  ) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts\n    .map(() => \"..\")\n    .concat(targetParts)\n    .join(\"/\");\n\n  return relativePath + targetURL.search + targetURL.hash;\n}\n\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n\n/**\n * Given a URL, strip off any filename if one is present.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst trimFilename = createSafeHandler(url => {\n  url.href = new URL(\".\", url.toString()).toString();\n});\n\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL.length);\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL_AND_HOST.length);\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\nexports.join = join;\n\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (\n    target.protocol !== root.protocol ||\n    target.user !== root.user ||\n    target.password !== root.password ||\n    target.hostname !== root.hostname ||\n    target.port !== root.port\n  ) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  // The source map spec states that \"sourceRoot\" and \"sources\" entries are to be appended. While\n  // that is a little vague, implementations have generally interpreted that as joining the\n  // URLs with a `/` between then, assuming the \"sourceRoot\" doesn't already end with one.\n  // For example,\n  //\n  //   sourceRoot: \"some-dir\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // and\n  //\n  //   sourceRoot: \"some-dir/\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // must behave as \"some-dir/some-path.js\".\n  //\n  // With this library's the transition to a more URL-focused implementation, that behavior is\n  // preserved here. To acheive that, we trim the \"/\" from absolute-path when a sourceRoot value\n  // is present in order to make the sources entries behave as if they are relative to the\n  // \"sourceRoot\", as they would have if the two strings were simply concated.\n  if (sourceRoot && getURLType(sourceURL) === \"path-absolute\") {\n    sourceURL = sourceURL.replace(/^\\//, \"\");\n  }\n\n  let url = normalize(sourceURL || \"\");\n\n  // Parsing URLs can be expensive, so we only perform these joins when needed.\n  if (sourceRoot) url = join(sourceRoot, url);\n  if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);\n  return url;\n}\nexports.computeSourceURL = computeSourceURL;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}