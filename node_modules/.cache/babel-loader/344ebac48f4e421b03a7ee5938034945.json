{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nrequire(\"core-js/modules/es.array.at.js\");\n\nrequire(\"core-js/modules/es.string.at-alternative.js\");\n\n/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nconst util = require(\"./util\");\n\nconst binarySearch = require(\"./binary-search\");\n\nconst ArraySet = require(\"./array-set\").ArraySet;\n\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\n\n\nconst readWasm = require(\"../lib/read-wasm\");\n\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n\n\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n\n\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n\n\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n\n}\n/**\n * The version of the source mapping spec that we are consuming.\n */\n\n\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\n\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null); // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map(); // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n      that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function (s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      }), true);\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n\n\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    } // Treat the source as map-relative overall by default.\n\n\n    const sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);\n\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n\n      this._sourceLookupCache.set(aSource, index);\n\n      return index;\n    } // Fall back to treating the source as sourceRoot-relative.\n\n\n    const sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);\n\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n\n      this._sourceLookupCache.set(aSource, index);\n\n      return index;\n    } // To avoid this cache growing forever, we do not cache lookup misses.\n\n\n    return -1;\n  }\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n\n\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n\n      let msg = `Error parsing mappings (code ${error}): `; // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(mapping => {\n      if (mapping.source !== null) {\n        mapping.source = this._absoluteSources.at(mapping.source);\n\n        if (mapping.name !== null) {\n          mapping.name = this._names.at(mapping.name);\n        }\n      }\n\n      if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n        mapping.lastGeneratedColumn = Infinity;\n      }\n\n      aCallback.call(context, mapping);\n    }, () => {\n      switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n\n          break;\n\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n\n          break;\n\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n      }\n    });\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n    source = this._findSourceIndex(source);\n\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(m => {\n      let lastColumn = m.lastGeneratedColumn;\n\n      if (this._computedColumnSpans && lastColumn === null) {\n        lastColumn = Infinity;\n      }\n\n      mappings.push({\n        line: m.generatedLine,\n        column: m.generatedColumn,\n        lastColumn\n      });\n    }, () => {\n      this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(), source, originalLine - 1, \"column\" in aArgs, originalColumn);\n    });\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n\n      this._mappingsPtr = 0;\n    }\n  }\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n\n\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n\n    this._computedColumnSpans = true;\n  }\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n\n\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(this._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n\n\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n      return sc == null;\n    });\n  }\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n\n\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    } // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n\n\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n\n\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(this._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\n\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n\n        lastOffset = offset;\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n  /**\n   * The list of original sources.\n   */\n\n\n  get sources() {\n    const sources = [];\n\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n\n    return sources;\n  }\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n\n\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    }; // Find the section containing the generated position we're trying to map\n    // to an original position.\n\n    const sectionIndex = binarySearch.search(needle, this._sections, function (aNeedle, section) {\n      const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n\n      if (cmp) {\n        return cmp;\n      }\n\n      return aNeedle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n      bias: aArgs.bias\n    });\n  }\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n\n\n  hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n\n\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n      const content = section.consumer.sourceContentFor(aSource, true);\n\n      if (content) {\n        return content;\n      }\n    }\n\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const {\n        consumer\n      } = this._sections[i];\n\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n\n\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;\n    const generatedPosition = section && section.consumer.generatedPositionFor(aArgs);\n\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {\n        generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;\n      }\n\n      generatedPosition.line += lineShift;\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;\n    if (!section) return [];\n    return section.consumer.allGeneratedPositionsFor(aArgs).map(generatedPosition => {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {\n        generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;\n      }\n\n      generatedPosition.line += lineShift;\n      return generatedPosition;\n    });\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection = index + 1 < this._sections.length ? this._sections[index + 1] : null;\n      const {\n        generatedOffset\n      } = section;\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n      section.consumer.eachMapping(function (mapping) {\n        if (mapping.generatedLine === 1) {\n          mapping.generatedColumn += columnShift;\n\n          if (typeof mapping.lastGeneratedColumn === \"number\") {\n            mapping.lastGeneratedColumn += columnShift;\n          }\n        }\n\n        if (mapping.lastGeneratedColumn === Infinity && nextSection && mapping.generatedLine === nextSection.generatedOffset.generatedLine) {\n          mapping.lastGeneratedColumn = nextSection.generatedOffset.generatedColumn - 2;\n        }\n\n        mapping.generatedLine += lineShift;\n        aCallback.call(this, mapping);\n      }, aContext, aOrder);\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n\n}\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\n\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}","map":{"version":3,"names":["util","require","binarySearch","ArraySet","base64VLQ","readWasm","wasm","INTERNAL","Symbol","SourceMapConsumer","constructor","aSourceMap","aSourceMapURL","Promise","resolve","_factory","initialize","opts","fromSourceMap","_factoryBSM","with","rawSourceMap","sourceMapUrl","f","consumer","destroy","eachMapping","aCallback","aContext","aOrder","Error","allGeneratedPositionsFor","aArgs","prototype","_version","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","exports","BasicSourceMapConsumer","then","that","sourceMap","parseSourceMapInput","version","getArg","sources","map","String","names","sourceRoot","sourcesContent","mappings","file","_sourceLookupCache","Map","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","_findSourceIndex","aSource","cachedIndex","get","sourceAsMapRelative","has","index","indexOf","set","sourceAsSourceRootRelative","toString","_getMappingsPtr","_parseMappings","aStr","size","length","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","buffer","i","charCodeAt","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","withMappingCallback","mapping","source","at","name","lastGeneratedColumn","Infinity","call","by_generated_location","by_original_location","originalLine","originalColumn","column","m","lastColumn","push","line","generatedLine","generatedColumn","all_generated_locations_for","free_mappings","computeColumnSpans","compute_column_spans","originalPositionFor","needle","bias","original_location_for","hasContentsOfAllSources","some","sc","sourceContentFor","nullOnMissing","generatedPositionFor","generated_location_for","IndexedSourceMapConsumer","sections","lastOffset","all","url","offset","offsetLine","offsetColumn","cons","generatedOffset","_sections","j","sectionIndex","search","aNeedle","section","cmp","every","content","_findSectionIndex","nextSection","generatedPosition","lineShift","columnShift","forEach"],"sources":["D:/web/Vue/shop/node_modules/terser/node_modules/source-map/lib/source-map-consumer.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String);\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map();\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      }), true);\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    }\n\n    // Treat the source as map-relative overall by default.\n    const sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // Fall back to treating the source as sourceRoot-relative.\n    const sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // To avoid this cache growing forever, we do not cache lookup misses.\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._absoluteSources.at(mapping.source);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n        if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n          mapping.lastGeneratedColumn = Infinity;\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const { consumer } = this._sections[i];\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    const generatedPosition =\n      section && section.consumer.generatedPositionFor(aArgs);\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (\n        generatedPosition.lastColumn === Infinity &&\n        nextSection &&\n        generatedPosition.line === nextSection.generatedOffset.generatedLine\n      ) {\n        generatedPosition.lastColumn =\n          nextSection.generatedOffset.generatedColumn - 2;\n      }\n      generatedPosition.line += lineShift;\n\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    if (!section) return [];\n\n    return section.consumer.allGeneratedPositionsFor(aArgs).map(\n      generatedPosition => {\n        const lineShift = section.generatedOffset.generatedLine - 1;\n        const columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (\n          generatedPosition.lastColumn === Infinity &&\n          nextSection &&\n          generatedPosition.line === nextSection.generatedOffset.generatedLine\n        ) {\n          generatedPosition.lastColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        generatedPosition.line += lineShift;\n\n        return generatedPosition;\n      }\n    );\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection =\n        index + 1 < this._sections.length\n          ? this._sections[index + 1]\n          : null;\n      const { generatedOffset } = section;\n\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n\n      section.consumer.eachMapping(function(mapping) {\n        if (mapping.generatedLine === 1) {\n          mapping.generatedColumn += columnShift;\n\n          if (typeof mapping.lastGeneratedColumn === \"number\") {\n            mapping.lastGeneratedColumn += columnShift;\n          }\n        }\n\n        if (\n          mapping.lastGeneratedColumn === Infinity &&\n          nextSection &&\n          mapping.generatedLine === nextSection.generatedOffset.generatedLine\n        ) {\n          mapping.lastGeneratedColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        mapping.generatedLine += lineShift;\n\n        aCallback.call(this, mapping);\n      }, aContext, aOrder);\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}