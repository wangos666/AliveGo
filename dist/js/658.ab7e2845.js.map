{"version":3,"file":"js/658.ab7e2845.js","mappings":"ozjEAEkBA,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAiGtC,SAASC,EAAkBC,GACzB,SAAIC,EAAAA,EAAAA,SACFC,EAAAA,EAAAA,IAAeF,IACR,GAkCAG,EAAAA,GACAA,EAAAA,GACEA,EAAAA,GA+Cb,IAqIIC,EArIcb,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAmItC,MAAMO,EAA6B,qBAAXC,OASlBC,GAHWhB,OAAOK,UAAUY,SAGhBC,GAAuB,kBAARA,GAC3BC,EAAYD,GAAuB,kBAARA,EAM3BE,EAAO,OAOCN,IAAkE,OAApDD,EAAe,MAAVE,YAAiB,EAASA,OAAOM,gBAAqB,EAASR,EAAGS,YAAc,iBAAiBC,KAAKR,OAAOM,UAAUC,WA0RtItB,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAyQpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAoCtC,SAASiB,EAAaC,EAAIC,EAAUC,EAAU,IAC5C,MAAM,UACJC,GAAY,GACVD,EACEE,GAAYC,EAAAA,EAAAA,KAAI,GACtB,IAAIC,EAAQ,KACZ,SAASC,IACHD,IACFE,aAAaF,GACbA,EAAQ,MAGZ,SAASG,IACPL,EAAUM,OAAQ,EAClBH,IAEF,SAASI,KAASC,GAChBL,IACAH,EAAUM,OAAQ,EAClBJ,EAAQO,YAAW,KACjBT,EAAUM,OAAQ,EAClBJ,EAAQ,KACRN,KAAMY,MACLE,EAAAA,EAAAA,IAAMb,IAQX,OANIE,IACFC,EAAUM,OAAQ,EACdrB,GACFsB,KAEJ5B,EAAkB0B,GACX,CACLL,UAAAA,EACAO,MAAAA,EACAF,KAAAA,GAIclC,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAkDVP,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAsBVP,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA6BpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAuCpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAsFpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAuCtBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBCruCpC,SAASiC,EAAUC,GACjB,IAAIC,GAAS,EACTC,EAAkB,MAATF,EAAgB,EAAIA,EAAME,OACnCC,EAAS,GAEb,QAASF,EAAQC,EAAQ,CACvB,IAAIE,EAAOJ,EAAMC,GACjBE,EAAOC,EAAK,IAAMA,EAAK,GAEzB,OAAOD,EAGT,QCvBA,MAAME,EAAaC,SACNC,EAAU,uBAChB,SAASC,EAAUC,EAAQC,GAChC,KAAKC,EAAAA,EAAAA,IAASF,IAAaA,EAAOF,GAChC,OAAOE,EACT,MAAM,OAAEG,EAAF,SAAUC,EAAUC,QAASC,EAA7B,KAA2CC,EAA3C,UAAiDC,GAAcR,EAC/DS,EAAaN,GAAUK,EAAaxC,IACxC,IAAI0C,GAAQ,EACRC,EAAgB,GAUpB,GATIR,IACFQ,EAAgBC,MAAMC,KAAKV,IACvBW,EAAAA,EAAAA,IAAOd,EAAQ,YACjBW,EAAcI,KAAKT,GAErBI,IAAUA,EAAQC,EAAcK,SAAShD,KAEvCwC,IACFE,IAAUA,EAAQF,EAAUxC,MACzB0C,GAASC,EAAclB,OAAS,EAAG,CACtC,MAAMwB,EAAkB,IAAI,IAAIC,IAAIP,IAAgBQ,KAAKlC,GAAUmC,KAAKC,UAAUpC,KAAQqC,KAAK,OAC/FC,EAAAA,EAAAA,IAAM,kCAAiCtB,EAAO,cAAaA,KAAS,wBAAwBgB,iBAA+BG,KAAKC,UAAUrD,OAE5I,OAAO0C,QACL,EACEc,EAAO,CACXjB,MAAML,EAAAA,EAAAA,IAASK,IAASzD,OAAOI,sBAAsBqD,GAAMS,SAASpB,GAAcW,EAAKX,GAAcW,EACrGH,WAAYA,EACZI,UAAWC,EACX,CAACX,IAAU,GAIb,OAFIgB,EAAAA,EAAAA,IAAOd,EAAQ,aACjBwB,EAAKnB,QAAUC,GACVkB,EAEG,MAACC,EAAcC,GAAUpC,EAAUxC,OAAO6E,QAAQD,GAAOP,KAAI,EAAElB,EAAKD,KAAY,CAC1FC,EACAF,EAAUC,EAAQC,OAEP2B,EAAkB5D,IAAD,CAAY,CAAC4B,GAAa5B,ICzC3C6D,EAAYJ,EAAW,CAClCK,KAAM,CACJvB,KAAMqB,EAAe,CAACG,OAAQC,UAEhCC,MAAO,CACL1B,KAAMyB,UCLV,MAAe,CAACE,EAAKR,KACnB,MAAMS,EAASD,EAAIE,WAAaF,EAChC,IAAK,MAAOjC,EAAKjC,KAAQ0D,EACvBS,EAAOlC,GAAOjC,EAEhB,OAAOmE,GCNG,MAACE,EAA2BxC,SCCxC,MAAMyC,UAAyBC,MAC7BC,YAAYC,GACV,MAAMA,GACN,KAAKC,KAAO,oBAGT,SAASC,EAAWC,EAAOH,GAChC,MAAM,IAAIH,EAAkB,IAAGM,MAAUH,KAEpC,SAASI,EAAUD,EAAOE,GAC3BC,ECVM,MAACC,EAAUC,GAAQnG,OAAOoG,KAAKD,GCErCE,GAAevE,EAAAA,EAAAA,MACd,SAASwE,EAAgBnD,EAAKK,GACnC,MAAM+C,GAASC,EAAAA,EAAAA,OAAuBC,EAAAA,EAAAA,IAAOlB,EAA0Bc,GAAgBA,EACvF,OAAIlD,GACKuD,EAAAA,EAAAA,KAAS,KACd,IAAI7F,EAAI8F,EACR,OAAgE,OAAxDA,EAA4B,OAAtB9F,EAAK0F,EAAOpE,YAAiB,EAAStB,EAAGsC,IAAgBwD,EAAKnD,KAGvE+C,EAGC,MAACK,EAAsB,CAACL,EAAQM,EAAKC,GAAS,KACxD,IAAIjG,EACJ,MAAMkG,KAAYP,EAAAA,EAAAA,MACZQ,EAAYD,EAAUT,SAAoB,EAC1CW,EAAyD,OAA5CpG,EAAY,MAAPgG,OAAc,EAASA,EAAIK,SAAmBrG,EAAKkG,EAAUG,EAAAA,QAAU,EAC/F,IAAKD,EAEH,YADAlB,EAAU,sBAAuB,0DAGnC,MAAMoB,GAAUT,EAAAA,EAAAA,KAAS,KACvB,MAAMU,GAAM7E,EAAAA,EAAAA,IAAMgE,GAClB,OAAmB,MAAbS,OAAoB,EAASA,EAAU7E,OAEtCkF,EAAYL,EAAU7E,MAAOiF,GAD3BA,KAOX,OAJAH,EAAU1B,EAA0B4B,IAChCL,GAAWT,EAAalE,QAC1BkE,EAAalE,MAAQgF,EAAQhF,OAExBgF,GAEHE,EAAc,CAACC,EAAGC,KACtB,IAAI1G,EACJ,MAAMuF,EAAO,IAAoB,IAAIhC,IAAI,IAAI8B,EAAOoB,MAAOpB,EAAOqB,MAC5DC,EAAM,GACZ,IAAK,MAAMrE,KAAOiD,EAChBoB,EAAIrE,GAAwB,OAAhBtC,EAAK0G,EAAEpE,IAAgBtC,EAAKyG,EAAEnE,GAE5C,OAAOqE,GCzCIC,EAAmB,KAC1BC,EAAc,MACdC,GAAO,CAACC,EAAWC,EAAOC,EAAaC,EAASC,KACpD,IAAIC,EAAO,GAAEL,KAAaC,IAU1B,OATIC,IACFG,GAAQ,IAAGH,KAETC,IACFE,GAAQ,KAAIF,KAEVC,IACFC,GAAQ,KAAID,KAEPC,GAEIC,GAAgBL,IAC3B,MAAMxB,EAAeC,EAAgB,aAC/BsB,GAAYlB,EAAAA,EAAAA,KAAS,IAAML,EAAalE,OAASsF,IACjDF,EAAI,CAACO,EAAc,KAAOH,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAOC,EAAa,GAAI,IACzEK,EAAKJ,GAAYA,EAAUJ,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAO,GAAIE,EAAS,IAAM,GAC5EpC,EAAKqC,GAAaA,EAAWL,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAO,GAAI,GAAIG,GAAY,GAC/EI,EAAK,CAACN,EAAaC,IAAYD,GAAeC,EAAUJ,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAOC,EAAaC,EAAS,IAAM,GAClHM,EAAK,CAACN,EAASC,IAAaD,GAAWC,EAAWL,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAO,GAAIE,EAASC,GAAY,GACzGM,EAAK,CAACR,EAAaE,IAAaF,GAAeE,EAAWL,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAOC,EAAa,GAAIE,GAAY,GACrHO,EAAM,CAACT,EAAaC,EAASC,IAAaF,GAAeC,GAAWC,EAAWL,IAAKpF,EAAAA,EAAAA,IAAMqF,GAAYC,EAAOC,EAAaC,EAASC,GAAY,GAC/IQ,EAAK,CAAC5C,KAASvD,KACnB,MAAMoG,IAAQpG,EAAKM,QAAU,IAAIN,EAAK,GACtC,OAAOuD,GAAQ6C,EAAS,GAAEf,IAAc9B,IAAS,IAE7C8C,EAAUC,IACd,MAAMC,EAAS,GACf,IAAK,MAAMzF,KAAOwF,EAChBC,EAAQ,KAAIhB,EAAUzF,SAASgB,KAASwF,EAAOxF,GAEjD,OAAOyF,GAEHC,EAAeF,IACnB,MAAMC,EAAS,GACf,IAAK,MAAMzF,KAAOwF,EAChBC,EAAQ,KAAIhB,EAAUzF,SAAS0F,KAAS1E,KAASwF,EAAOxF,GAE1D,OAAOyF,GAEHE,EAAclD,GAAU,KAAIgC,EAAUzF,SAASyD,IAC/CmD,EAAmBnD,GAAU,KAAIgC,EAAUzF,SAAS0F,KAASjC,IACnE,MAAO,CACLgC,UAAAA,EACAL,EAAAA,EACAY,EAAAA,EACAxC,EAAAA,EACAyC,GAAAA,EACAC,GAAAA,EACAC,GAAAA,EACAC,IAAAA,EACAC,GAAAA,EACAE,OAAAA,EACAI,WAAAA,EACAD,YAAAA,EACAE,gBAAAA,IC/CSC,GAAe9H,QAAgB,IAARA,EAEvB+H,GAAad,GACD,qBAAZe,SAEJf,aAAae,QCbhBC,GAAQ,kBACDC,GAAmB,CAACnB,EAAM,KAAOA,EAAIoB,MAAM,KAAKC,QAAQC,KAAWA,EAAKC,SACxEC,GAAW,CAACC,EAAIzB,KAC3B,IAAKyB,IAAOzB,EACV,OAAO,EACT,GAAIA,EAAI/D,SAAS,KACf,MAAM,IAAIuB,MAAM,uCAClB,OAAOiE,EAAGC,UAAUC,SAAS3B,IAElB4B,GAAW,CAACH,EAAIzB,KACtByB,GAAOzB,EAAIuB,QAEhBE,EAAGC,UAAUG,OAAOV,GAAiBnB,KAE1B8B,GAAc,CAACL,EAAIzB,KACzByB,GAAOzB,EAAIuB,QAEhBE,EAAGC,UAAUK,UAAUZ,GAAiBnB,KAE7BgC,GAAW,CAAClC,EAASmC,KAChC,IAAIrJ,EACJ,IAAKC,IAAaiH,IAAYmC,EAC5B,MAAO,GACT,IAAI/G,GAAMgH,EAAAA,EAAAA,IAASD,GACP,UAAR/G,IACFA,EAAM,YACR,IACE,MAAMiH,EAAQrC,EAAQqC,MAAMF,GAC5B,GAAIE,EACF,OAAOA,EACT,MAAM1D,EAA0C,OAA9B7F,EAAKwJ,SAASC,kBAAuB,EAASzJ,EAAG0J,iBAAiBxC,EAAS,IAC7F,OAAOrB,EAAWA,EAASwD,GAAa,GACxC,MAAO/B,GACP,OAAOJ,EAAQqC,MAAMF,KAsBlB,SAASM,GAAQrI,EAAOsI,EAAc,MAC3C,OAAKtI,GAEDhB,EAAAA,EAAAA,IAASgB,GACJA,EACEnB,EAASmB,GACV,GAAEA,IAAQsI,SAEpB1E,EAAUoD,GAAO,4CANR,G,uFC5CLuB,EAAKxC,GAAa,QAElBkC,GAAQ,SAAQ,IACtB,gBAEA,CACAO,SAAAA,GAAAA,EAAAA,WAAAA,EAAAA,GAAAA,EAAAA,MACA,mBAJA,K,wPCpBY,MAACC,GAAc,CAACC,EAAMC,KAOhC,GALAD,EAAKE,QAAWlE,IACd,IAAK,MAAMmE,IAAQ,CAACH,KAAS7K,OAAOqD,OAAgB,MAATyH,EAAgBA,EAAQ,KACjEjE,EAAIoE,UAAUD,EAAKpF,KAAMoF,IAGzBF,EACF,IAAK,MAAO3H,EAAK6H,KAAShL,OAAO6E,QAAQiG,GAEvCD,EAAK1H,GAAO6H,EAGhB,OAAOH,GAEIK,GAAsB,CAACzK,EAAImF,KAEtCnF,EAAGsK,QAAWlE,IAEZpG,EAAG0K,SAAWtE,EAAIsE,SAClBtE,EAAIN,OAAO6E,iBAAiBxF,GAAQnF,GAE/BA,GAEI4K,GAAmBJ,IAE9BA,EAAUF,QAAUO,EAAAA,GACbL,GC1BIM,GAASX,GAAYY,ICFlC,IAAIC,GAAc,CAACrG,EAAKR,KACtB,MAAMS,EAASD,EAAIE,WAAaF,EAChC,IAAK,MAAOjC,EAAKjC,KAAQ0D,EACvBS,EAAOlC,GAAOjC,EAEhB,OAAOmE,GCFT,MAAMqG,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,YAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,4tBACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAIU,GAA0BpB,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCnBrD,MAACU,GAAWlH,IACtB,MAAMmH,GAAKvG,EAAAA,EAAAA,MACX,OAAOE,EAAAA,EAAAA,KAAS,KACd,IAAI7F,EAAI8F,EACR,OAAoE,OAA5DA,EAAwB,OAAlB9F,EAAKkM,EAAGC,YAAiB,EAASnM,EAAG0L,OAAO3G,IAAiBe,OAAK,MCLvEsG,GAAiB,CAAC,GAAI,UAAW,QAAS,SCA1CC,GAAiBnK,OAAO,kBACxBoK,GAAqBpK,OAAO,sBCK5BqK,GAAcnK,EAAU,CACnCQ,KAAMyB,OACN7B,OAAQ4J,GACR3J,UAAU,IAEC+J,GAAU,CAACC,EAAUC,EAAS,MACzC,MAAMC,GAAW1L,EAAAA,EAAAA,SAAI,GACfkD,EAAOuI,EAAO7I,KAAO8I,EAAWV,GAAQ,QACxCzG,EAAekH,EAAOzG,OAAS0G,EAAWlH,EAAgB,QAC1DmH,EAAOF,EAAOE,KAAO,CAAEzI,UAAM,IAAWyB,EAAAA,EAAAA,IAAOyG,QAAgB,GAC/DQ,EAAWH,EAAOG,SAAW,CAAE1I,UAAM,IAAWyB,EAAAA,EAAAA,IAAO0G,QAAoB,GACjF,OAAOzG,EAAAA,EAAAA,KAAS,IAAM1B,EAAK7C,QAASI,EAAAA,EAAAA,IAAM+K,KAA0B,MAAZI,OAAmB,EAASA,EAAS1I,QAAkB,MAARyI,OAAe,EAASA,EAAKzI,OAASqB,EAAalE,OAAS,MAExJwL,GAAeL,IAC1B,MAAMM,EAAWd,GAAQ,YACnBW,GAAOhH,EAAAA,EAAAA,IAAOyG,QAAgB,GACpC,OAAOxG,EAAAA,EAAAA,KAAS,IAAMkH,EAASzL,QAASI,EAAAA,EAAAA,IAAM+K,KAAsB,MAARG,OAAe,EAASA,EAAKG,YAAa,KCnBlGlC,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,UAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,yQACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAI0B,GAAwBpC,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCjB/D,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,kBAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,uNACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAI2B,GAAgCrC,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCjBvE,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,eAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,wnBACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAI4B,GAA6BtC,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCjBpE,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,kBAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,wOACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAI6B,GAAgCvC,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCjBvE,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,sBAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,+RACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAI8B,GAAoCxC,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCjB3E,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,gBAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,mGACF,MAAO,GACJC,IAA6BH,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,4IACF,MAAO,GACJgC,GAAa,CACjBnC,GACAI,IAEF,SAASC,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYsC,IAE5D,IAAIC,GAA8B1C,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCtBrE,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,gBAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,kOACF,MAAO,GACJC,IAA6BH,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,mGACF,MAAO,GACJgC,GAAa,CACjBnC,GACAI,IAEF,SAASC,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYsC,IAE5D,IAAIE,GAA8B3C,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCdzD,MAACiC,GAAevJ,EAAe,CACzCI,OACAlF,OACAsO,WAKWC,GAAiB,CAC5BC,MAD4B,GAE5BC,cAF4B,GAG5BC,WAH4B,GAI5BC,cAJ4B,GAK5BC,kBAAAA,IAEWC,GAAoB,CAC/BC,QAASL,GACTM,QAASJ,GACTK,MAAOJ,GACPK,KAAMP,IAEKQ,GAAwB,CACnCC,WAAYC,GACZN,QAASO,GACTL,MAAOM,IChCIC,GAAc,CACzB,UACA,UACA,UACA,UACA,OACA,SACA,OACA,IAEWC,GAAoB,CAAC,SAAU,SAAU,SACzCC,GAAc9K,EAAW,CACpCK,KAAMoI,GACNQ,SAAU8B,QACVjM,KAAM,CACJA,KAAMyB,OACN7B,OAAQkM,GACRhM,QAAS,IAEXoM,KAAM,CACJlM,KAAM4K,GACN9K,QAAS,IAEXqM,WAAY,CACVnM,KAAMyB,OACN7B,OAAQmM,GACRjM,QAAS,UAEXsJ,QAAS6C,QACTG,YAAa,CACXpM,KAAM4K,GACN9K,QAAS,IAAM6L,IAEjBU,MAAOJ,QACPK,KAAML,QACNM,KAAMN,QACNO,GAAIP,QACJQ,UAAWR,QACXS,MAAOT,QACPU,OAAQV,QACRvK,MAAOD,OACPmL,KAAMX,QACNY,gBAAiB,CACf7M,KAAMiM,QACNnM,aAAS,KAGAgN,GAAc,CACzBC,MAAQC,GAAQA,aAAeC,YC/C1B,SAASC,GAAQC,EAAGC,GACnBC,GAAeF,KACfA,EAAI,QAER,IAAIG,EAAYC,GAAaJ,GAO7B,OANAA,EAAY,MAARC,EAAcD,EAAIK,KAAKC,IAAIL,EAAKI,KAAKJ,IAAI,EAAGM,WAAWP,KAEvDG,IACAH,EAAIQ,SAASlM,OAAO0L,EAAIC,GAAM,IAAM,KAGpCI,KAAKI,IAAIT,EAAIC,GAAO,KACb,GAOPD,EAJQ,MAARC,GAIKD,EAAI,EAAKA,EAAIC,EAAOA,EAAMD,EAAIC,GAAOM,WAAWjM,OAAO2L,IAKvDD,EAAIC,EAAOM,WAAWjM,OAAO2L,IAE/BD,GAMJ,SAASU,GAAQpQ,GACpB,OAAO+P,KAAKC,IAAI,EAAGD,KAAKJ,IAAI,EAAG3P,IAO5B,SAAS4P,GAAeF,GAC3B,MAAoB,kBAANA,IAAsC,IAApBA,EAAEW,QAAQ,MAAiC,IAAlBJ,WAAWP,GAMjE,SAASI,GAAaJ,GACzB,MAAoB,kBAANA,IAAsC,IAApBA,EAAEW,QAAQ,KAMvC,SAASC,GAAWlK,GAKvB,OAJAA,EAAI6J,WAAW7J,IACXmK,MAAMnK,IAAMA,EAAI,GAAKA,EAAI,KACzBA,EAAI,GAEDA,EAMJ,SAASoK,GAAoBd,GAChC,OAAIA,GAAK,EACE,GAAGe,OAAmB,IAAZ1M,OAAO2L,GAAU,KAE/BA,EAMJ,SAASgB,GAAKC,GACjB,OAAoB,IAAbA,EAAElP,OAAe,IAAMkP,EAAI3M,OAAO2M,GCvEtC,SAASC,GAASC,EAAGC,EAAGzK,GAC3B,MAAO,CACHwK,EAAqB,IAAlBpB,GAAQoB,EAAG,KACdC,EAAqB,IAAlBrB,GAAQqB,EAAG,KACdzK,EAAqB,IAAlBoJ,GAAQpJ,EAAG,MAQf,SAAS0K,GAASF,EAAGC,EAAGzK,GAC3BwK,EAAIpB,GAAQoB,EAAG,KACfC,EAAIrB,GAAQqB,EAAG,KACfzK,EAAIoJ,GAAQpJ,EAAG,KACf,IAAIsJ,EAAMI,KAAKJ,IAAIkB,EAAGC,EAAGzK,GACrB2J,EAAMD,KAAKC,IAAIa,EAAGC,EAAGzK,GACrB2K,EAAI,EACJC,EAAI,EACJC,GAAKvB,EAAMK,GAAO,EACtB,GAAIL,IAAQK,EACRiB,EAAI,EACJD,EAAI,MAEH,CACD,IAAIhG,EAAI2E,EAAMK,EAEd,OADAiB,EAAIC,EAAI,GAAMlG,GAAK,EAAI2E,EAAMK,GAAOhF,GAAK2E,EAAMK,GACvCL,GACJ,KAAKkB,EACDG,GAAKF,EAAIzK,GAAK2E,GAAK8F,EAAIzK,EAAI,EAAI,GAC/B,MACJ,KAAKyK,EACDE,GAAK3K,EAAIwK,GAAK7F,EAAI,EAClB,MACJ,KAAK3E,EACD2K,GAAKH,EAAIC,GAAK9F,EAAI,EAClB,MACJ,QACI,MAERgG,GAAK,EAET,MAAO,CAAEA,EAAGA,EAAGC,EAAGA,EAAGC,EAAGA,GAE5B,SAASC,GAAQC,EAAGC,EAAGC,GAOnB,OANIA,EAAI,IACJA,GAAK,GAELA,EAAI,IACJA,GAAK,GAELA,EAAI,EAAI,EACDF,EAAe,EAAIE,GAAdD,EAAID,GAEhBE,EAAI,GACGD,EAEPC,EAAI,EAAI,EACDF,GAAKC,EAAID,IAAM,EAAI,EAAIE,GAAK,EAEhCF,EAQJ,SAASG,GAASP,EAAGC,EAAGC,GAC3B,IAAIL,EACAC,EACAzK,EAIJ,GAHA2K,EAAIvB,GAAQuB,EAAG,KACfC,EAAIxB,GAAQwB,EAAG,KACfC,EAAIzB,GAAQyB,EAAG,KACL,IAAND,EAEAH,EAAII,EACJ7K,EAAI6K,EACJL,EAAIK,MAEH,CACD,IAAIG,EAAIH,EAAI,GAAMA,GAAK,EAAID,GAAKC,EAAID,EAAIC,EAAID,EACxCG,EAAI,EAAIF,EAAIG,EAChBR,EAAIM,GAAQC,EAAGC,EAAGL,EAAI,EAAI,GAC1BF,EAAIK,GAAQC,EAAGC,EAAGL,GAClB3K,EAAI8K,GAAQC,EAAGC,EAAGL,EAAI,EAAI,GAE9B,MAAO,CAAEH,EAAO,IAAJA,EAASC,EAAO,IAAJA,EAASzK,EAAO,IAAJA,GAQjC,SAASmL,GAASX,EAAGC,EAAGzK,GAC3BwK,EAAIpB,GAAQoB,EAAG,KACfC,EAAIrB,GAAQqB,EAAG,KACfzK,EAAIoJ,GAAQpJ,EAAG,KACf,IAAIsJ,EAAMI,KAAKJ,IAAIkB,EAAGC,EAAGzK,GACrB2J,EAAMD,KAAKC,IAAIa,EAAGC,EAAGzK,GACrB2K,EAAI,EACJS,EAAI9B,EACJ3E,EAAI2E,EAAMK,EACViB,EAAY,IAARtB,EAAY,EAAI3E,EAAI2E,EAC5B,GAAIA,IAAQK,EACRgB,EAAI,MAEH,CACD,OAAQrB,GACJ,KAAKkB,EACDG,GAAKF,EAAIzK,GAAK2E,GAAK8F,EAAIzK,EAAI,EAAI,GAC/B,MACJ,KAAKyK,EACDE,GAAK3K,EAAIwK,GAAK7F,EAAI,EAClB,MACJ,KAAK3E,EACD2K,GAAKH,EAAIC,GAAK9F,EAAI,EAClB,MACJ,QACI,MAERgG,GAAK,EAET,MAAO,CAAEA,EAAGA,EAAGC,EAAGA,EAAGQ,EAAGA,GAQrB,SAASC,GAASV,EAAGC,EAAGQ,GAC3BT,EAAsB,EAAlBvB,GAAQuB,EAAG,KACfC,EAAIxB,GAAQwB,EAAG,KACfQ,EAAIhC,GAAQgC,EAAG,KACf,IAAIE,EAAI5B,KAAK6B,MAAMZ,GACfa,EAAIb,EAAIW,EACRP,EAAIK,GAAK,EAAIR,GACbI,EAAII,GAAK,EAAII,EAAIZ,GACjBK,EAAIG,GAAK,GAAK,EAAII,GAAKZ,GACvBa,EAAMH,EAAI,EACVd,EAAI,CAACY,EAAGJ,EAAGD,EAAGA,EAAGE,EAAGG,GAAGK,GACvBhB,EAAI,CAACQ,EAAGG,EAAGA,EAAGJ,EAAGD,EAAGA,GAAGU,GACvBzL,EAAI,CAAC+K,EAAGA,EAAGE,EAAGG,EAAGA,EAAGJ,GAAGS,GAC3B,MAAO,CAAEjB,EAAO,IAAJA,EAASC,EAAO,IAAJA,EAASzK,EAAO,IAAJA,GAQjC,SAAS0L,GAASlB,EAAGC,EAAGzK,EAAG2L,GAC9B,IAAIC,EAAM,CACNvB,GAAKX,KAAKd,MAAM4B,GAAG9Q,SAAS,KAC5B2Q,GAAKX,KAAKd,MAAM6B,GAAG/Q,SAAS,KAC5B2Q,GAAKX,KAAKd,MAAM5I,GAAGtG,SAAS,MAGhC,OAAIiS,GACAC,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,KAChCF,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,KAChCF,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,IACzBF,EAAI,GAAGE,OAAO,GAAKF,EAAI,GAAGE,OAAO,GAAKF,EAAI,GAAGE,OAAO,GAExDF,EAAI3O,KAAK,IASb,SAAS8O,GAAUvB,EAAGC,EAAGzK,EAAGD,EAAGiM,GAClC,IAAIJ,EAAM,CACNvB,GAAKX,KAAKd,MAAM4B,GAAG9Q,SAAS,KAC5B2Q,GAAKX,KAAKd,MAAM6B,GAAG/Q,SAAS,KAC5B2Q,GAAKX,KAAKd,MAAM5I,GAAGtG,SAAS,KAC5B2Q,GAAK4B,GAAoBlM,KAG7B,OAAIiM,GACAJ,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,KAChCF,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,KAChCF,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,KAChCF,EAAI,GAAGC,WAAWD,EAAI,GAAGE,OAAO,IACzBF,EAAI,GAAGE,OAAO,GAAKF,EAAI,GAAGE,OAAO,GAAKF,EAAI,GAAGE,OAAO,GAAKF,EAAI,GAAGE,OAAO,GAE3EF,EAAI3O,KAAK,IAgBb,SAASgP,GAAoBtH,GAChC,OAAO+E,KAAKd,MAAsB,IAAhBgB,WAAWjF,IAAUjL,SAAS,IAG7C,SAASwS,GAAoBvB,GAChC,OAAOwB,GAAgBxB,GAAK,IAGzB,SAASwB,GAAgBxS,GAC5B,OAAOkQ,SAASlQ,EAAK,IAElB,SAASyS,GAAoBxO,GAChC,MAAO,CACH4M,EAAG5M,GAAS,GACZ6M,GAAY,MAAR7M,IAAmB,EACvBoC,EAAW,IAARpC,GCpOJ,IAAIyO,GAAQ,CACfC,UAAW,UACXC,aAAc,UACdC,KAAM,UACNC,WAAY,UACZC,MAAO,UACPC,MAAO,UACPC,OAAQ,UACRC,MAAO,UACPC,eAAgB,UAChBC,KAAM,UACNC,WAAY,UACZC,MAAO,UACPC,UAAW,UACXC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,MAAO,UACPC,eAAgB,UAChBC,SAAU,UACVC,QAAS,UACTC,KAAM,UACNC,SAAU,UACVC,SAAU,UACVC,cAAe,UACfC,SAAU,UACVC,UAAW,UACXC,SAAU,UACVC,UAAW,UACXC,YAAa,UACbC,eAAgB,UAChBC,WAAY,UACZC,WAAY,UACZC,QAAS,UACTC,WAAY,UACZC,aAAc,UACdC,cAAe,UACfC,cAAe,UACfC,cAAe,UACfC,cAAe,UACfC,WAAY,UACZC,SAAU,UACVC,YAAa,UACbC,QAAS,UACTC,QAAS,UACTC,WAAY,UACZC,UAAW,UACXC,YAAa,UACbC,YAAa,UACbC,QAAS,UACTC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,KAAM,UACNC,KAAM,UACNC,MAAO,UACPC,YAAa,UACbC,KAAM,UACNC,SAAU,UACVC,QAAS,UACTC,UAAW,UACXC,OAAQ,UACRC,MAAO,UACPC,MAAO,UACPC,cAAe,UACfC,SAAU,UACVC,UAAW,UACXC,aAAc,UACdC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,qBAAsB,UACtBC,UAAW,UACXC,WAAY,UACZC,UAAW,UACXC,UAAW,UACXC,YAAa,UACbC,cAAe,UACfC,aAAc,UACdC,eAAgB,UAChBC,eAAgB,UAChBC,eAAgB,UAChBC,YAAa,UACbC,KAAM,UACNC,UAAW,UACXC,MAAO,UACPC,QAAS,UACTC,OAAQ,UACRC,iBAAkB,UAClBC,WAAY,UACZC,aAAc,UACdC,aAAc,UACdC,eAAgB,UAChBC,gBAAiB,UACjBC,kBAAmB,UACnBC,gBAAiB,UACjBC,gBAAiB,UACjBC,aAAc,UACdC,UAAW,UACXC,UAAW,UACXC,SAAU,UACVC,YAAa,UACbC,KAAM,UACNC,QAAS,UACTC,MAAO,UACPC,UAAW,UACXC,OAAQ,UACRC,UAAW,UACXC,OAAQ,UACRC,cAAe,UACfC,UAAW,UACXC,cAAe,UACfC,cAAe,UACfC,WAAY,UACZC,UAAW,UACXC,KAAM,UACNC,KAAM,UACNC,KAAM,UACNC,WAAY,UACZC,OAAQ,UACRC,cAAe,UACfC,IAAK,UACLC,UAAW,UACXC,UAAW,UACXC,YAAa,UACbC,OAAQ,UACRC,WAAY,UACZC,SAAU,UACVC,SAAU,UACVC,OAAQ,UACRC,OAAQ,UACRC,QAAS,UACTC,UAAW,UACXC,UAAW,UACXC,UAAW,UACXC,KAAM,UACNC,YAAa,UACbC,UAAW,UACXC,IAAK,UACLC,KAAM,UACNC,QAAS,UACTC,OAAQ,UACRC,UAAW,UACXC,OAAQ,UACRC,MAAO,UACPC,MAAO,UACPC,WAAY,UACZC,OAAQ,UACRC,YAAa,WCnIV,SAASC,GAAW9X,GACvB,IAAI+X,EAAM,CAAEnL,EAAG,EAAGC,EAAG,EAAGzK,EAAG,GACvBD,EAAI,EACJ6K,EAAI,KACJQ,EAAI,KACJP,EAAI,KACJ+K,GAAK,EACLC,GAAS,EA6Bb,MA5BqB,kBAAVjY,IACPA,EAAQkY,GAAoBlY,IAEX,kBAAVA,IACHmY,GAAenY,EAAM4M,IAAMuL,GAAenY,EAAM6M,IAAMsL,GAAenY,EAAMoC,IAC3E2V,EAAMpL,GAAS3M,EAAM4M,EAAG5M,EAAM6M,EAAG7M,EAAMoC,GACvC4V,GAAK,EACLC,EAAwC,MAA/BlY,OAAOC,EAAM4M,GAAGwL,QAAQ,GAAa,OAAS,OAElDD,GAAenY,EAAM+M,IAAMoL,GAAenY,EAAMgN,IAAMmL,GAAenY,EAAMwN,IAChFR,EAAIT,GAAoBvM,EAAMgN,GAC9BQ,EAAIjB,GAAoBvM,EAAMwN,GAC9BuK,EAAMtK,GAASzN,EAAM+M,EAAGC,EAAGQ,GAC3BwK,GAAK,EACLC,EAAS,OAEJE,GAAenY,EAAM+M,IAAMoL,GAAenY,EAAMgN,IAAMmL,GAAenY,EAAMiN,KAChFD,EAAIT,GAAoBvM,EAAMgN,GAC9BC,EAAIV,GAAoBvM,EAAMiN,GAC9B8K,EAAMzK,GAAStN,EAAM+M,EAAGC,EAAGC,GAC3B+K,GAAK,EACLC,EAAS,OAETpd,OAAOK,UAAUC,eAAekd,KAAKrY,EAAO,OAC5CmC,EAAInC,EAAMmC,IAGlBA,EAAIkK,GAAWlK,GACR,CACH6V,GAAIA,EACJC,OAAQjY,EAAMiY,QAAUA,EACxBrL,EAAGd,KAAKC,IAAI,IAAKD,KAAKJ,IAAIqM,EAAInL,EAAG,IACjCC,EAAGf,KAAKC,IAAI,IAAKD,KAAKJ,IAAIqM,EAAIlL,EAAG,IACjCzK,EAAG0J,KAAKC,IAAI,IAAKD,KAAKJ,IAAIqM,EAAI3V,EAAG,IACjCD,EAAGA,GAIX,IAAImW,GAAc,gBAEdC,GAAa,uBAEbC,GAAW,MAAMhM,OAAO+L,GAAY,SAAS/L,OAAO8L,GAAa,KAIjEG,GAAoB,cAAcjM,OAAOgM,GAAU,cAAchM,OAAOgM,GAAU,cAAchM,OAAOgM,GAAU,aACjHE,GAAoB,cAAclM,OAAOgM,GAAU,cAAchM,OAAOgM,GAAU,cAAchM,OAAOgM,GAAU,cAAchM,OAAOgM,GAAU,aAChJG,GAAW,CACXH,SAAU,IAAII,OAAOJ,IACrBT,IAAK,IAAIa,OAAO,MAAQH,IACxBI,KAAM,IAAID,OAAO,OAASF,IAC1BI,IAAK,IAAIF,OAAO,MAAQH,IACxBM,KAAM,IAAIH,OAAO,OAASF,IAC1BM,IAAK,IAAIJ,OAAO,MAAQH,IACxBQ,KAAM,IAAIL,OAAO,OAASF,IAC1BQ,KAAM,uDACNC,KAAM,uDACNC,KAAM,uEACNC,KAAM,wEAMH,SAASnB,GAAoBlY,GAEhC,GADAA,EAAQA,EAAMqE,OAAOiV,cACA,IAAjBtZ,EAAMxC,OACN,OAAO,EAEX,IAAI+b,GAAQ,EACZ,GAAI9K,GAAMzO,GACNA,EAAQyO,GAAMzO,GACduZ,GAAQ,OAEP,GAAc,gBAAVvZ,EACL,MAAO,CAAE4M,EAAG,EAAGC,EAAG,EAAGzK,EAAG,EAAGD,EAAG,EAAG8V,OAAQ,QAM7C,IAAIuB,EAAQb,GAASZ,IAAI0B,KAAKzZ,GAC9B,OAAIwZ,EACO,CAAE5M,EAAG4M,EAAM,GAAI3M,EAAG2M,EAAM,GAAIpX,EAAGoX,EAAM,KAEhDA,EAAQb,GAASE,KAAKY,KAAKzZ,GACvBwZ,EACO,CAAE5M,EAAG4M,EAAM,GAAI3M,EAAG2M,EAAM,GAAIpX,EAAGoX,EAAM,GAAIrX,EAAGqX,EAAM,KAE7DA,EAAQb,GAASG,IAAIW,KAAKzZ,GACtBwZ,EACO,CAAEzM,EAAGyM,EAAM,GAAIxM,EAAGwM,EAAM,GAAIvM,EAAGuM,EAAM,KAEhDA,EAAQb,GAASI,KAAKU,KAAKzZ,GACvBwZ,EACO,CAAEzM,EAAGyM,EAAM,GAAIxM,EAAGwM,EAAM,GAAIvM,EAAGuM,EAAM,GAAIrX,EAAGqX,EAAM,KAE7DA,EAAQb,GAASK,IAAIS,KAAKzZ,GACtBwZ,EACO,CAAEzM,EAAGyM,EAAM,GAAIxM,EAAGwM,EAAM,GAAIhM,EAAGgM,EAAM,KAEhDA,EAAQb,GAASM,KAAKQ,KAAKzZ,GACvBwZ,EACO,CAAEzM,EAAGyM,EAAM,GAAIxM,EAAGwM,EAAM,GAAIhM,EAAGgM,EAAM,GAAIrX,EAAGqX,EAAM,KAE7DA,EAAQb,GAASU,KAAKI,KAAKzZ,GACvBwZ,EACO,CACH5M,EAAG2B,GAAgBiL,EAAM,IACzB3M,EAAG0B,GAAgBiL,EAAM,IACzBpX,EAAGmM,GAAgBiL,EAAM,IACzBrX,EAAGmM,GAAoBkL,EAAM,IAC7BvB,OAAQsB,EAAQ,OAAS,SAGjCC,EAAQb,GAASQ,KAAKM,KAAKzZ,GACvBwZ,EACO,CACH5M,EAAG2B,GAAgBiL,EAAM,IACzB3M,EAAG0B,GAAgBiL,EAAM,IACzBpX,EAAGmM,GAAgBiL,EAAM,IACzBvB,OAAQsB,EAAQ,OAAS,QAGjCC,EAAQb,GAASS,KAAKK,KAAKzZ,GACvBwZ,EACO,CACH5M,EAAG2B,GAAgBiL,EAAM,GAAKA,EAAM,IACpC3M,EAAG0B,GAAgBiL,EAAM,GAAKA,EAAM,IACpCpX,EAAGmM,GAAgBiL,EAAM,GAAKA,EAAM,IACpCrX,EAAGmM,GAAoBkL,EAAM,GAAKA,EAAM,IACxCvB,OAAQsB,EAAQ,OAAS,SAGjCC,EAAQb,GAASO,KAAKO,KAAKzZ,KACvBwZ,GACO,CACH5M,EAAG2B,GAAgBiL,EAAM,GAAKA,EAAM,IACpC3M,EAAG0B,GAAgBiL,EAAM,GAAKA,EAAM,IACpCpX,EAAGmM,GAAgBiL,EAAM,GAAKA,EAAM,IACpCvB,OAAQsB,EAAQ,OAAS,gBAS9B,SAASpB,GAAenY,GAC3B,OAAOuK,QAAQoO,GAASH,SAASiB,KAAK1Z,OAAOC,KChLjD,IAAI0Z,GAA2B,WAC3B,SAASA,EAAU1Z,EAAO2Z,GAGtB,IAAIje,EAEJ,QAJc,IAAVsE,IAAoBA,EAAQ,SACnB,IAAT2Z,IAAmBA,EAAO,IAG1B3Z,aAAiB0Z,EAEjB,OAAO1Z,EAEU,kBAAVA,IACPA,EAAQwO,GAAoBxO,IAEhC4Z,KAAKC,cAAgB7Z,EACrB,IAAI+X,EAAMD,GAAW9X,GACrB4Z,KAAKC,cAAgB7Z,EACrB4Z,KAAKhN,EAAImL,EAAInL,EACbgN,KAAK/M,EAAIkL,EAAIlL,EACb+M,KAAKxX,EAAI2V,EAAI3V,EACbwX,KAAKzX,EAAI4V,EAAI5V,EACbyX,KAAKE,OAAShO,KAAKd,MAAM,IAAM4O,KAAKzX,GAAK,IACzCyX,KAAK3B,OAAgC,QAAtBvc,EAAKie,EAAK1B,cAA2B,IAAPvc,EAAgBA,EAAKqc,EAAIE,OACtE2B,KAAKG,aAAeJ,EAAKI,aAKrBH,KAAKhN,EAAI,IACTgN,KAAKhN,EAAId,KAAKd,MAAM4O,KAAKhN,IAEzBgN,KAAK/M,EAAI,IACT+M,KAAK/M,EAAIf,KAAKd,MAAM4O,KAAK/M,IAEzB+M,KAAKxX,EAAI,IACTwX,KAAKxX,EAAI0J,KAAKd,MAAM4O,KAAKxX,IAE7BwX,KAAKI,QAAUjC,EAAIC,GA0bvB,OAxbA0B,EAAUxe,UAAU+e,OAAS,WACzB,OAAOL,KAAKM,gBAAkB,KAElCR,EAAUxe,UAAUif,QAAU,WAC1B,OAAQP,KAAKK,UAKjBP,EAAUxe,UAAUgf,cAAgB,WAEhC,IAAInC,EAAM6B,KAAKQ,QACf,OAAgB,IAARrC,EAAInL,EAAkB,IAARmL,EAAIlL,EAAkB,IAARkL,EAAI3V,GAAW,KAKvDsX,EAAUxe,UAAUmf,aAAe,WAE/B,IACIC,EACAC,EACAC,EAHAzC,EAAM6B,KAAKQ,QAIXK,EAAQ1C,EAAInL,EAAI,IAChB8N,EAAQ3C,EAAIlL,EAAI,IAChB8N,EAAQ5C,EAAI3V,EAAI,IAsBpB,OApBIkY,EADAG,GAAS,OACLA,EAAQ,MAIR3O,KAAK8O,KAAKH,EAAQ,MAAS,MAAO,KAGtCF,EADAG,GAAS,OACLA,EAAQ,MAIR5O,KAAK8O,KAAKF,EAAQ,MAAS,MAAO,KAGtCF,EADAG,GAAS,OACLA,EAAQ,MAIR7O,KAAK8O,KAAKD,EAAQ,MAAS,MAAO,KAEnC,MAASL,EAAI,MAASC,EAAI,MAASC,GAK9Cd,EAAUxe,UAAU2f,SAAW,WAC3B,OAAOjB,KAAKzX,GAOhBuX,EAAUxe,UAAU4f,SAAW,SAAUC,GAGrC,OAFAnB,KAAKzX,EAAIkK,GAAW0O,GACpBnB,KAAKE,OAAShO,KAAKd,MAAM,IAAM4O,KAAKzX,GAAK,IAClCyX,MAKXF,EAAUxe,UAAU8f,MAAQ,WACxB,IAAIhC,EAAMzL,GAASqM,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,GACxC,MAAO,CAAE2K,EAAW,IAARiM,EAAIjM,EAASC,EAAGgM,EAAIhM,EAAGQ,EAAGwL,EAAIxL,EAAGrL,EAAGyX,KAAKzX,IAMzDuX,EAAUxe,UAAU+f,YAAc,WAC9B,IAAIjC,EAAMzL,GAASqM,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,GACpC2K,EAAIjB,KAAKd,MAAc,IAARgO,EAAIjM,GACnBC,EAAIlB,KAAKd,MAAc,IAARgO,EAAIhM,GACnBQ,EAAI1B,KAAKd,MAAc,IAARgO,EAAIxL,GACvB,OAAkB,IAAXoM,KAAKzX,EAAU,OAAOqK,OAAOO,EAAG,MAAMP,OAAOQ,EAAG,OAAOR,OAAOgB,EAAG,MAAQ,QAAQhB,OAAOO,EAAG,MAAMP,OAAOQ,EAAG,OAAOR,OAAOgB,EAAG,OAAOhB,OAAOoN,KAAKE,OAAQ,MAKlKJ,EAAUxe,UAAUggB,MAAQ,WACxB,IAAIpC,EAAMhM,GAAS8M,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,GACxC,MAAO,CAAE2K,EAAW,IAAR+L,EAAI/L,EAASC,EAAG8L,EAAI9L,EAAGC,EAAG6L,EAAI7L,EAAG9K,EAAGyX,KAAKzX,IAMzDuX,EAAUxe,UAAUigB,YAAc,WAC9B,IAAIrC,EAAMhM,GAAS8M,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,GACpC2K,EAAIjB,KAAKd,MAAc,IAAR8N,EAAI/L,GACnBC,EAAIlB,KAAKd,MAAc,IAAR8N,EAAI9L,GACnBC,EAAInB,KAAKd,MAAc,IAAR8N,EAAI7L,GACvB,OAAkB,IAAX2M,KAAKzX,EAAU,OAAOqK,OAAOO,EAAG,MAAMP,OAAOQ,EAAG,OAAOR,OAAOS,EAAG,MAAQ,QAAQT,OAAOO,EAAG,MAAMP,OAAOQ,EAAG,OAAOR,OAAOS,EAAG,OAAOT,OAAOoN,KAAKE,OAAQ,MAMlKJ,EAAUxe,UAAUkgB,MAAQ,SAAUrN,GAElC,YADmB,IAAfA,IAAyBA,GAAa,GACnCD,GAAS8L,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,EAAG2L,IAM5C2L,EAAUxe,UAAUmgB,YAAc,SAAUtN,GAExC,YADmB,IAAfA,IAAyBA,GAAa,GACnC,IAAM6L,KAAKwB,MAAMrN,IAM5B2L,EAAUxe,UAAUogB,OAAS,SAAUlN,GAEnC,YADmB,IAAfA,IAAyBA,GAAa,GACnCD,GAAUyL,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,EAAGwX,KAAKzX,EAAGiM,IAMrDsL,EAAUxe,UAAUqgB,aAAe,SAAUnN,GAEzC,YADmB,IAAfA,IAAyBA,GAAa,GACnC,IAAMwL,KAAK0B,OAAOlN,IAK7BsL,EAAUxe,UAAUkf,MAAQ,WACxB,MAAO,CACHxN,EAAGd,KAAKd,MAAM4O,KAAKhN,GACnBC,EAAGf,KAAKd,MAAM4O,KAAK/M,GACnBzK,EAAG0J,KAAKd,MAAM4O,KAAKxX,GACnBD,EAAGyX,KAAKzX,IAOhBuX,EAAUxe,UAAUsgB,YAAc,WAC9B,IAAI5O,EAAId,KAAKd,MAAM4O,KAAKhN,GACpBC,EAAIf,KAAKd,MAAM4O,KAAK/M,GACpBzK,EAAI0J,KAAKd,MAAM4O,KAAKxX,GACxB,OAAkB,IAAXwX,KAAKzX,EAAU,OAAOqK,OAAOI,EAAG,MAAMJ,OAAOK,EAAG,MAAML,OAAOpK,EAAG,KAAO,QAAQoK,OAAOI,EAAG,MAAMJ,OAAOK,EAAG,MAAML,OAAOpK,EAAG,MAAMoK,OAAOoN,KAAKE,OAAQ,MAK9JJ,EAAUxe,UAAUugB,gBAAkB,WAClC,IAAIC,EAAM,SAAUC,GAAK,MAAO,GAAGnP,OAAOV,KAAKd,MAAwB,IAAlBQ,GAAQmQ,EAAG,MAAa,MAC7E,MAAO,CACH/O,EAAG8O,EAAI9B,KAAKhN,GACZC,EAAG6O,EAAI9B,KAAK/M,GACZzK,EAAGsZ,EAAI9B,KAAKxX,GACZD,EAAGyX,KAAKzX,IAMhBuX,EAAUxe,UAAU0gB,sBAAwB,WACxC,IAAIC,EAAM,SAAUF,GAAK,OAAO7P,KAAKd,MAAwB,IAAlBQ,GAAQmQ,EAAG,OACtD,OAAkB,IAAX/B,KAAKzX,EACN,OAAOqK,OAAOqP,EAAIjC,KAAKhN,GAAI,OAAOJ,OAAOqP,EAAIjC,KAAK/M,GAAI,OAAOL,OAAOqP,EAAIjC,KAAKxX,GAAI,MACjF,QAAQoK,OAAOqP,EAAIjC,KAAKhN,GAAI,OAAOJ,OAAOqP,EAAIjC,KAAK/M,GAAI,OAAOL,OAAOqP,EAAIjC,KAAKxX,GAAI,OAAOoK,OAAOoN,KAAKE,OAAQ,MAKvHJ,EAAUxe,UAAU4gB,OAAS,WACzB,GAAe,IAAXlC,KAAKzX,EACL,MAAO,cAEX,GAAIyX,KAAKzX,EAAI,EACT,OAAO,EAGX,IADA,IAAI6L,EAAM,IAAMF,GAAS8L,KAAKhN,EAAGgN,KAAK/M,EAAG+M,KAAKxX,GAAG,GACxC2Z,EAAK,EAAGrgB,EAAKb,OAAO6E,QAAQ+O,IAAQsN,EAAKrgB,EAAG8B,OAAQue,IAAM,CAC/D,IAAIva,EAAK9F,EAAGqgB,GAAK/d,EAAMwD,EAAG,GAAIxE,EAAQwE,EAAG,GACzC,GAAIwM,IAAQhR,EACR,OAAOgB,EAGf,OAAO,GAEX0b,EAAUxe,UAAUY,SAAW,SAAUmc,GACrC,IAAI+D,EAAYzR,QAAQ0N,GACxBA,EAAoB,OAAXA,QAA8B,IAAXA,EAAoBA,EAAS2B,KAAK3B,OAC9D,IAAIgE,GAAkB,EAClBC,EAAWtC,KAAKzX,EAAI,GAAKyX,KAAKzX,GAAK,EACnCga,GAAoBH,GAAaE,IAAajE,EAAOhK,WAAW,QAAqB,SAAXgK,GAC9E,OAAIkE,EAGe,SAAXlE,GAAgC,IAAX2B,KAAKzX,EACnByX,KAAKkC,SAETlC,KAAK4B,eAED,QAAXvD,IACAgE,EAAkBrC,KAAK4B,eAEZ,SAAXvD,IACAgE,EAAkBrC,KAAKgC,yBAEZ,QAAX3D,GAA+B,SAAXA,IACpBgE,EAAkBrC,KAAKyB,eAEZ,SAAXpD,IACAgE,EAAkBrC,KAAKyB,aAAY,IAExB,SAAXpD,IACAgE,EAAkBrC,KAAK2B,cAAa,IAEzB,SAAXtD,IACAgE,EAAkBrC,KAAK2B,gBAEZ,SAAXtD,IACAgE,EAAkBrC,KAAKkC,UAEZ,QAAX7D,IACAgE,EAAkBrC,KAAKuB,eAEZ,QAAXlD,IACAgE,EAAkBrC,KAAKqB,eAEpBgB,GAAmBrC,KAAKyB,gBAEnC3B,EAAUxe,UAAUkhB,SAAW,WAC3B,OAAQtQ,KAAKd,MAAM4O,KAAKhN,IAAM,KAAOd,KAAKd,MAAM4O,KAAK/M,IAAM,GAAKf,KAAKd,MAAM4O,KAAKxX,IAEpFsX,EAAUxe,UAAUmhB,MAAQ,WACxB,OAAO,IAAI3C,EAAUE,KAAK9d,aAM9B4d,EAAUxe,UAAUohB,QAAU,SAAUC,QACrB,IAAXA,IAAqBA,EAAS,IAClC,IAAIzD,EAAMc,KAAKsB,QAGf,OAFApC,EAAI7L,GAAKsP,EAAS,IAClBzD,EAAI7L,EAAId,GAAQ2M,EAAI7L,GACb,IAAIyM,EAAUZ,IAMzBY,EAAUxe,UAAUshB,SAAW,SAAUD,QACtB,IAAXA,IAAqBA,EAAS,IAClC,IAAIxE,EAAM6B,KAAKQ,QAIf,OAHArC,EAAInL,EAAId,KAAKJ,IAAI,EAAGI,KAAKC,IAAI,IAAKgM,EAAInL,EAAId,KAAKd,OAAcuR,EAAS,IAAjB,OACrDxE,EAAIlL,EAAIf,KAAKJ,IAAI,EAAGI,KAAKC,IAAI,IAAKgM,EAAIlL,EAAIf,KAAKd,OAAcuR,EAAS,IAAjB,OACrDxE,EAAI3V,EAAI0J,KAAKJ,IAAI,EAAGI,KAAKC,IAAI,IAAKgM,EAAI3V,EAAI0J,KAAKd,OAAcuR,EAAS,IAAjB,OAC9C,IAAI7C,EAAU3B,IAOzB2B,EAAUxe,UAAUuhB,OAAS,SAAUF,QACpB,IAAXA,IAAqBA,EAAS,IAClC,IAAIzD,EAAMc,KAAKsB,QAGf,OAFApC,EAAI7L,GAAKsP,EAAS,IAClBzD,EAAI7L,EAAId,GAAQ2M,EAAI7L,GACb,IAAIyM,EAAUZ,IAOzBY,EAAUxe,UAAUwhB,KAAO,SAAUH,GAEjC,YADe,IAAXA,IAAqBA,EAAS,IAC3B3C,KAAK+C,IAAI,QAASJ,IAO7B7C,EAAUxe,UAAU0hB,MAAQ,SAAUL,GAElC,YADe,IAAXA,IAAqBA,EAAS,IAC3B3C,KAAK+C,IAAI,QAASJ,IAO7B7C,EAAUxe,UAAU2hB,WAAa,SAAUN,QACxB,IAAXA,IAAqBA,EAAS,IAClC,IAAIzD,EAAMc,KAAKsB,QAGf,OAFApC,EAAI9L,GAAKuP,EAAS,IAClBzD,EAAI9L,EAAIb,GAAQ2M,EAAI9L,GACb,IAAI0M,EAAUZ,IAMzBY,EAAUxe,UAAU4hB,SAAW,SAAUP,QACtB,IAAXA,IAAqBA,EAAS,IAClC,IAAIzD,EAAMc,KAAKsB,QAGf,OAFApC,EAAI9L,GAAKuP,EAAS,IAClBzD,EAAI9L,EAAIb,GAAQ2M,EAAI9L,GACb,IAAI0M,EAAUZ,IAMzBY,EAAUxe,UAAU6hB,UAAY,WAC5B,OAAOnD,KAAKiD,WAAW,MAM3BnD,EAAUxe,UAAU8hB,KAAO,SAAUT,GACjC,IAAIzD,EAAMc,KAAKsB,QACX+B,GAAOnE,EAAI/L,EAAIwP,GAAU,IAE7B,OADAzD,EAAI/L,EAAIkQ,EAAM,EAAI,IAAMA,EAAMA,EACvB,IAAIvD,EAAUZ,IAMzBY,EAAUxe,UAAUyhB,IAAM,SAAU3c,EAAOuc,QACxB,IAAXA,IAAqBA,EAAS,IAClC,IAAIW,EAAOtD,KAAKQ,QACZ+C,EAAO,IAAIzD,EAAU1Z,GAAOoa,QAC5BjN,EAAIoP,EAAS,IACb1D,EAAO,CACPjM,GAAIuQ,EAAKvQ,EAAIsQ,EAAKtQ,GAAKO,EAAI+P,EAAKtQ,EAChCC,GAAIsQ,EAAKtQ,EAAIqQ,EAAKrQ,GAAKM,EAAI+P,EAAKrQ,EAChCzK,GAAI+a,EAAK/a,EAAI8a,EAAK9a,GAAK+K,EAAI+P,EAAK9a,EAChCD,GAAIgb,EAAKhb,EAAI+a,EAAK/a,GAAKgL,EAAI+P,EAAK/a,GAEpC,OAAO,IAAIuX,EAAUb,IAEzBa,EAAUxe,UAAUkiB,UAAY,SAAUC,EAASC,QAC/B,IAAZD,IAAsBA,EAAU,QACrB,IAAXC,IAAqBA,EAAS,IAClC,IAAIxE,EAAMc,KAAKsB,QACXqC,EAAO,IAAMD,EACbE,EAAM,CAAC5D,MACX,IAAKd,EAAI/L,GAAK+L,EAAI/L,GAAMwQ,EAAOF,GAAY,GAAK,KAAO,MAAOA,GAC1DvE,EAAI/L,GAAK+L,EAAI/L,EAAIwQ,GAAQ,IACzBC,EAAI1e,KAAK,IAAI4a,EAAUZ,IAE3B,OAAO0E,GAKX9D,EAAUxe,UAAUuiB,WAAa,WAC7B,IAAI3E,EAAMc,KAAKsB,QAEf,OADApC,EAAI/L,GAAK+L,EAAI/L,EAAI,KAAO,IACjB,IAAI2M,EAAUZ,IAEzBY,EAAUxe,UAAUwiB,cAAgB,SAAUL,QAC1B,IAAZA,IAAsBA,EAAU,GACpC,IAAIrE,EAAMY,KAAKoB,QACXjO,EAAIiM,EAAIjM,EACRC,EAAIgM,EAAIhM,EACRQ,EAAIwL,EAAIxL,EACRmQ,EAAM,GACNC,EAAe,EAAIP,EACvB,MAAOA,IACHM,EAAI7e,KAAK,IAAI4a,EAAU,CAAE3M,EAAGA,EAAGC,EAAGA,EAAGQ,EAAGA,KACxCA,GAAKA,EAAIoQ,GAAgB,EAE7B,OAAOD,GAEXjE,EAAUxe,UAAU2iB,gBAAkB,WAClC,IAAI/E,EAAMc,KAAKsB,QACXnO,EAAI+L,EAAI/L,EACZ,MAAO,CACH6M,KACA,IAAIF,EAAU,CAAE3M,GAAIA,EAAI,IAAM,IAAKC,EAAG8L,EAAI9L,EAAGC,EAAG6L,EAAI7L,IACpD,IAAIyM,EAAU,CAAE3M,GAAIA,EAAI,KAAO,IAAKC,EAAG8L,EAAI9L,EAAGC,EAAG6L,EAAI7L,MAM7DyM,EAAUxe,UAAU4iB,aAAe,SAAUC,GACzC,IAAIC,EAAKpE,KAAKQ,QACVtP,EAAK,IAAI4O,EAAUqE,GAAY3D,QACnC,OAAO,IAAIV,EAAU,CACjB9M,EAAG9B,EAAG8B,GAAKoR,EAAGpR,EAAI9B,EAAG8B,GAAKoR,EAAG7b,EAC7B0K,EAAG/B,EAAG+B,GAAKmR,EAAGnR,EAAI/B,EAAG+B,GAAKmR,EAAG7b,EAC7BC,EAAG0I,EAAG1I,GAAK4b,EAAG5b,EAAI0I,EAAG1I,GAAK4b,EAAG7b,KAMrCuX,EAAUxe,UAAU+iB,MAAQ,WACxB,OAAOrE,KAAKsE,OAAO,IAKvBxE,EAAUxe,UAAUijB,OAAS,WACzB,OAAOvE,KAAKsE,OAAO,IAMvBxE,EAAUxe,UAAUgjB,OAAS,SAAUzS,GAKnC,IAJA,IAAIqN,EAAMc,KAAKsB,QACXnO,EAAI+L,EAAI/L,EACRtP,EAAS,CAACmc,MACVwE,EAAY,IAAM3S,EACbiC,EAAI,EAAGA,EAAIjC,EAAGiC,IACnBjQ,EAAOqB,KAAK,IAAI4a,EAAU,CAAE3M,GAAIA,EAAIW,EAAI0Q,GAAa,IAAKpR,EAAG8L,EAAI9L,EAAGC,EAAG6L,EAAI7L,KAE/E,OAAOxP,GAKXic,EAAUxe,UAAUmjB,OAAS,SAAUre,GACnC,OAAO4Z,KAAK4B,gBAAkB,IAAI9B,EAAU1Z,GAAOwb,eAEhD9B,EA9doB,GCDxB,SAAS+C,GAAOzc,EAAOuc,EAAS,IACrC,OAAOvc,EAAM2c,IAAI,UAAWJ,GAAQzgB,WAE/B,SAASwiB,GAAqB7e,GACnC,MAAM8e,EAAY/V,KACZjD,EAAKxC,GAAa,UACxB,OAAOxB,EAAAA,EAAAA,KAAS,KACd,IAAIkC,EAAS,GACb,MAAM+a,EAAc/e,EAAMO,MAC1B,GAAIwe,EAAa,CACf,MAAMxe,EAAQ,IAAI0Z,GAAU8E,GACtBC,EAAgBhf,EAAMyL,KAAOlL,EAAM0c,KAAK,IAAI5gB,WAAa2gB,GAAOzc,EAAO,IAC7E,GAAIP,EAAMkL,MACRlH,EAAS8B,EAAG7B,YAAY,CACtB,WAAYjE,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,WAC5D,aAAc0iB,EACd,eAAgB/e,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,WAChE,mBAAqB,OAAMyJ,EAAG5B,WAAW,kBACzC,iBAAkB6a,EAClB,qBAAsBA,EACtB,kBAAmBC,EACnB,oBAAsB,OAAMlZ,EAAG5B,WAAW,kBAC1C,sBAAuB8a,IAErBF,EAAUvhB,QACZyG,EAAO8B,EAAG3B,gBAAgB,sBAAwBnE,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,WAClG2H,EAAO8B,EAAG3B,gBAAgB,wBAA0BnE,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,WACpG2H,EAAO8B,EAAG3B,gBAAgB,0BAA4BnE,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,gBAEnG,CACL,MAAM4iB,EAAejf,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,WAC/D6iB,EAAY3e,EAAMia,SAAY,OAAM1U,EAAG5B,WAAW,kBAAqB,OAAM4B,EAAG5B,WAAW,kBAWjG,GAVAF,EAAS8B,EAAG7B,YAAY,CACtB,WAAY8a,EACZ,aAAcG,EACd,eAAgBH,EAChB,iBAAkBE,EAClB,mBAAoBC,EACpB,qBAAsBD,EACtB,kBAAmBD,EACnB,sBAAuBA,IAErBF,EAAUvhB,MAAO,CACnB,MAAM4hB,EAAsBnf,EAAMyL,KAAOuR,GAAOzc,EAAO,IAAMA,EAAM0c,KAAK,IAAI5gB,WAC5E2H,EAAO8B,EAAG3B,gBAAgB,sBAAwBgb,EAClDnb,EAAO8B,EAAG3B,gBAAgB,wBAA0BnE,EAAMyL,KAAO,2BAA8B,OAAM3F,EAAG5B,WAAW,kBACnHF,EAAO8B,EAAG3B,gBAAgB,0BAA4Bgb,IAI5D,OAAOnb,KCnDC,MAACob,GAAgB,EAAGjgB,KAAAA,EAAMkgB,YAAAA,EAAane,MAAAA,EAAOoe,QAAAA,EAASpiB,IAAAA,EAAK2B,KAAAA,EAAO,OAAS0gB,MACtFC,EAAAA,EAAAA,KAAM,KAAM7hB,EAAAA,EAAAA,IAAM4hB,KAAajjB,IACzBA,GACF6E,EAAUD,EAAQ,GAAErC,KAAQM,0CAA6CmgB,iBAAuBD,8CACrEniB,SAG5B,CACDF,WAAW,KCVFyiB,GAAwBthB,OAAO,yBCGtCuhB,GAAqB,CACzBC,OAAQtT,KAAK6B,MAAsB,IAAhB7B,KAAKuT,UACxBC,QAAS,GAEEC,GAAmB3hB,OAAO,iBAC1B4hB,GAASC,IACpB,MAAMC,GAAcpe,EAAAA,EAAAA,IAAOie,GAAkBJ,IACxCxjB,GAAY+jB,IAAgBP,IAC/Bve,EAAU,cAAgB,8MAM5B,MAAM+e,GAAQpe,EAAAA,EAAAA,KAAS,KAAMnE,EAAAA,EAAAA,IAAMqiB,IAAqB,SAAQC,EAAYN,UAAUM,EAAYJ,cAClG,OAAOK,GCPIC,GAAc,KACzB,MAAMtX,GAAOhH,EAAAA,EAAAA,IAAOyG,QAAgB,GAC9BQ,GAAWjH,EAAAA,EAAAA,IAAO0G,QAAoB,GAC5C,MAAO,CACLM,KAAAA,EACAC,SAAAA,IAGSsX,GAAqB,CAACpgB,GACjCqgB,gBAAAA,EACAC,oBAAAA,EACAC,oBAAAA,MAEKD,IACHA,GAAsBpjB,EAAAA,EAAAA,KAAI,IAEvBqjB,IACHA,GAAsBrjB,EAAAA,EAAAA,KAAI,IAE5B,MAAMsjB,GAAUtjB,EAAAA,EAAAA,MAChB,IAAIujB,EACJ,MAAMC,GAAsB5e,EAAAA,EAAAA,KAAS,KACnC,IAAI7F,EACJ,UAAW+D,EAAM2gB,OAASN,GAAmBA,EAAgBO,WAAgD,OAAlC3kB,EAAKokB,EAAgBO,eAAoB,EAAS3kB,EAAG8B,SAAW,MAsB7I,OApBA8iB,EAAAA,EAAAA,KAAU,KACRJ,GAAYjB,EAAAA,EAAAA,IAAM,EAACsB,EAAAA,EAAAA,IAAM9gB,EAAO,MAAOsgB,IAAsB,EAAES,EAAIC,MACjE,MAAMC,EAAc,MAANF,EAAaA,EAAMC,OAAuC,EAAhBjB,KAAQxiB,MAC5D0jB,IAAUT,EAAQjjB,SACG,MAAnB8iB,OAA0B,EAASA,EAAgBa,iBACrDV,EAAQjjB,OAAS8iB,EAAgBa,cAAcV,EAAQjjB,QAC1B,MAAvBgjB,OAA8B,EAASA,EAAoBhjB,QAAWyjB,IAAwBC,GAClGZ,EAAgBc,WAAWF,IAG/BT,EAAQjjB,MAAQ0jB,KAEjB,CAAEjkB,WAAW,QAElBokB,EAAAA,EAAAA,KAAY,KACVX,GAAaA,KACU,MAAnBJ,OAA0B,EAASA,EAAgBa,gBACrDV,EAAQjjB,OAAS8iB,EAAgBa,cAAcV,EAAQjjB,UAGpD,CACLmjB,oBAAAA,EACAF,QAAAA,I,kJCKEa,GAAQ,UAGdjC,GAAAA,CACAjgB,KAAAA,YACAkgB,YAAAA,YACAC,QAAAA,QACApe,MAAAA,QACAhE,IAAAA,2EAEA4E,EAAAA,EAAAA,KAAAA,IAAAA,SAAAA,EAAAA,QAGA,MAAMwf,GAAqB,QAAO7B,QAAuB,GACnDhe,EAAeC,EAAgB,UAC/BoE,EAAKxC,GAAa,WAClB,KAANuF,GAAA,KACM0Y,EAAQ9Y,IAAQ,SAAS,IAAD,MAAO6Y,OAAP,YACxBxC,EAAY/V,KACZyY,GAAO,UAEPC,GAAQ,SAAS,IAAMzhB,EAAMnB,OAAb,6BAChB6M,GAAkB,SACxB,KAIA,UACA,gGAEA,iBACA,MACA,6CACA,2CACA,aACA,mCACA,mBACA,oDAKA,YAEA,QACA,MACA,yBAEA7C,MAAAA,GAAAA,EAAAA,eAIA6Y,EAAAA,QAAAA,I,OAEAC,EAEA,CAEAzkB,IAAAA,EACAkD,KAAAA,E,22CCzHY,MAACwhB,GAAmB,CAC9BxhB,KAAMyK,GAAAA,KACNhM,KAAMgM,GAAAA,M,0ECYRvI,EAAAA,EAAAA,IACAmd,IACAoC,EAAAA,EAAAA,IAAAA,CACAzhB,MAAAA,EAAAA,EAAAA,IAAAA,EAAAA,QACAvB,MAAAA,EAAAA,EAAAA,IAAAA,EAAAA,WAGA,MAAMiH,EAAKxC,GAAa,U,oPCnBZ,MAACwe,GAAW9b,GAAY+b,GAAQ,CAC1CC,YAAAA,KAE2Bvb,GAAgBub,I,wBC6E7C,SAASC,GAAaC,GACpB,IAAIjmB,EACJ,MAAMiP,GAAQvN,EAAAA,EAAAA,IAAMukB,GACpB,OAAoD,OAA5CjmB,EAAc,MAATiP,OAAgB,EAASA,EAAMiX,KAAelmB,EAAKiP,EAGlE,MAAMkX,GAAgBlmB,EAAWC,YAAS,EAClBD,GAAWC,OAAOsJ,SACjBvJ,GAAWC,OAAOM,UACnBP,GAAWC,OAAOkmB,SAE1C,SAASC,MAAoB7kB,GAC3B,IAAIgD,EACA8hB,EACAC,EACAzlB,EAOJ,GANIR,EAASkB,EAAK,MACf8kB,EAAOC,EAAUzlB,GAAWU,EAC7BgD,EAAS2hB,KAER3hB,EAAQ8hB,EAAOC,EAAUzlB,GAAWU,GAElCgD,EACH,OAAOjE,EACT,IAAIimB,EAAUjmB,EACd,MAAMkmB,GAAYlD,EAAAA,EAAAA,KAAM,IAAMyC,GAAaxhB,KAAUqE,IACnD2d,IACK3d,IAELA,EAAG6d,iBAAiBJ,EAAOC,EAAUzlB,GACrC0lB,EAAU,KACR3d,EAAG8d,oBAAoBL,EAAOC,EAAUzlB,GACxC0lB,EAAUjmB,MAEX,CAAEQ,WAAW,EAAM6lB,MAAO,SACvBvlB,EAAO,KACXolB,IACAD,KAGF,OADA7mB,EAAkB0B,GACXA,EAsCSlC,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAoZpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAgMtC,MAAMmnB,GAAgC,qBAAfC,WAA6BA,WAA+B,qBAAX5mB,OAAyBA,OAA2B,qBAAX+F,OAAyBA,OAAyB,qBAAT8gB,KAAuBA,KAAO,GAClLC,GAAY,0BAClBH,GAAQG,IAAaH,GAAQG,KAAc,GAC1BH,GAAQG,IA2HP7nB,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA+KpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA6HpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAuEpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAmQpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAiFtC,IAAIunB,GAAwB9nB,OAAOI,sBAC/B2nB,GAAiB/nB,OAAOK,UAAUC,eAClC0nB,GAAiBhoB,OAAOK,UAAUE,qBAClC0nB,GAAc,CAACC,EAAQC,KACzB,IAAI9iB,EAAS,GACb,IAAK,IAAIX,KAAQwjB,EACXH,GAAevK,KAAK0K,EAAQxjB,IAASyjB,EAAQ5W,QAAQ7M,GAAQ,IAC/DW,EAAOX,GAAQwjB,EAAOxjB,IAC1B,GAAc,MAAVwjB,GAAkBJ,GACpB,IAAK,IAAIpjB,KAAQojB,GAAsBI,GACjCC,EAAQ5W,QAAQ7M,GAAQ,GAAKsjB,GAAexK,KAAK0K,EAAQxjB,KAC3DW,EAAOX,GAAQwjB,EAAOxjB,IAE5B,OAAOW,GAET,SAAS+iB,GAAkB/iB,EAAQgjB,EAAU1mB,EAAU,IACrD,MAAMd,EAAKc,GAAS,OAAEZ,EAASimB,IAAkBnmB,EAAIynB,EAAkBL,GAAYpnB,EAAI,CAAC,WACxF,IAAI0nB,EACJ,MAAMC,EAAcznB,GAAU,mBAAoBA,EAC5CsmB,EAAU,KACVkB,IACFA,EAASE,aACTF,OAAW,IAGTjB,GAAYlD,EAAAA,EAAAA,KAAM,IAAMyC,GAAaxhB,KAAUqE,IACnD2d,IACImB,GAAeznB,GAAU2I,IAC3B6e,EAAW,IAAIG,eAAeL,GAC9BE,EAASI,QAAQjf,EAAI4e,MAEtB,CAAE1mB,WAAW,EAAM6lB,MAAO,SACvBvlB,EAAO,KACXmlB,IACAC,KAGF,OADA9mB,EAAkB0B,GACX,CACLsmB,YAAAA,EACAtmB,KAAAA,GAuGclC,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA4LpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA6PpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAygBpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAiLpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAscVP,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAgHpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA2IpBP,OAAOC,eACND,OAAOE,iBACAF,OAAOG,0BACLH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAsdpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAuWpBP,OAAOC,eACRD,OAAOE,iBACAF,OAAOG,0BACHH,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBAqBpBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBA6HtBP,OAAOC,eACGD,OAAOI,sBACdJ,OAAOK,UAAUC,eACjBN,OAAOK,UAAUE,qBCjgJpC,SAASqoB,GAAMzmB,GACb,OAAgB,MAATA,EAGT,UCrBA,MAAMuJ,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,SAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DC,KAAM,eACNC,EAAG,wXACF,MAAO,GACJC,GAAa,CACjBJ,IAEF,SAASK,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYO,IAE5D,IAAI0c,GAAuBpd,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCjB9D,MAAMV,IAAYC,EAAAA,EAAAA,IAAgB,CAChC/F,KAAM,SAEFgG,GAAa,CACjBC,QAAS,gBACTC,MAAO,8BAEHC,IAA6BC,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DE,EAAG,uhCACHD,KAAM,gBACL,MAAO,GACJE,IAA6BH,EAAAA,EAAAA,GAAmB,OAAQ,CAC5DE,EAAG,0OACHD,KAAM,gBACL,MAAO,GACJiC,GAAa,CACjBnC,GACAI,IAEF,SAASC,GAAYC,EAAMC,EAAQC,EAAQC,EAAQC,EAAOC,GACxD,OAAOC,EAAAA,EAAAA,OAAaC,EAAAA,EAAAA,IAAmB,MAAOhB,GAAYsC,IAE5D,IAAI4a,GAAuBrd,GAAYC,GAAW,CAAC,CAAC,SAAUU,MCxB9D,IAAI2c,GACJ,MAAMC,GAAgB,uMAShBC,GAAgB,CACpB,iBACA,cACA,cACA,iBACA,cACA,cACA,YACA,iBACA,iBACA,QACA,cACA,eACA,gBACA,eACA,cAEF,SAASC,GAAqBC,GAC5B,MAAM/e,EAAQrJ,OAAOwJ,iBAAiB4e,GAChCC,EAAYhf,EAAMif,iBAAiB,cACnCC,EAAcrkB,OAAOkM,WAAW/G,EAAMif,iBAAiB,mBAAqBpkB,OAAOkM,WAAW/G,EAAMif,iBAAiB,gBACrHE,EAAatkB,OAAOkM,WAAW/G,EAAMif,iBAAiB,wBAA0BpkB,OAAOkM,WAAW/G,EAAMif,iBAAiB,qBACzHG,EAAeP,GAAc5kB,KAAKuB,GAAU,GAAEA,KAAQwE,EAAMif,iBAAiBzjB,OAASpB,KAAK,KACjG,MAAO,CAAEglB,aAAAA,EAAcF,YAAAA,EAAaC,WAAAA,EAAYH,UAAAA,GAE3C,SAASK,GAAmBN,EAAeO,EAAU,EAAGC,GAC7D,IAAI9oB,EACCkoB,KACHA,GAAiB1e,SAASuf,cAAc,YACxCvf,SAASwf,KAAKC,YAAYf,KAE5B,MAAM,YAAEO,EAAF,WAAeC,EAAf,UAA2BH,EAA3B,aAAsCI,GAAiBN,GAAqBC,GAClFJ,GAAegB,aAAa,QAAU,GAAEP,KAAgBR,MACxDD,GAAe5mB,MAAQgnB,EAAchnB,OAASgnB,EAAca,aAAe,GAC3E,IAAIC,EAASlB,GAAemB,aAC5B,MAAMtnB,EAAS,GACG,eAAdwmB,EACFa,GAAkBV,EACK,gBAAdH,IACTa,GAAkBX,GAEpBP,GAAe5mB,MAAQ,GACvB,MAAMgoB,EAAkBpB,GAAemB,aAAeZ,EACtD,GAAItoB,EAAS0oB,GAAU,CACrB,IAAIU,EAAYD,EAAkBT,EAChB,eAAdN,IACFgB,EAAYA,EAAYd,EAAcC,GAExCU,EAAShZ,KAAKJ,IAAIuZ,EAAWH,GAC7BrnB,EAAOwnB,UAAa,GAAEA,MAExB,GAAIppB,EAAS2oB,GAAU,CACrB,IAAIU,EAAYF,EAAkBR,EAChB,eAAdP,IACFiB,EAAYA,EAAYf,EAAcC,GAExCU,EAAShZ,KAAKC,IAAImZ,EAAWJ,GAK/B,OAHArnB,EAAOqnB,OAAU,GAAEA,MACiB,OAAnCppB,EAAKkoB,GAAeuB,aAA+BzpB,EAAG0pB,YAAYxB,IACnEA,QAAiB,EACVnmB,ECxEG,MAAC4nB,GAAWtpB,GAAQA,ECAnBupB,GAAqB,oBCSrBC,GAAa/lB,EAAW,CACnCghB,GAAI,CACFliB,KAAMyB,OACN3B,aAAS,GAEXyB,KAAMoI,GACNQ,SAAU8B,QACVib,WAAY,CACVlnB,KAAMqB,EAAe,CACnBI,OACAD,OACAjF,SAEFuD,QAAS,IAEXE,KAAM,CACJA,KAAMyB,OACN3B,QAAS,QAEXqnB,OAAQ,CACNnnB,KAAMyB,OACN7B,OAAQ,CAAC,OAAQ,OAAQ,aAAc,aAEzCwnB,SAAU,CACRpnB,KAAMqB,EAAe,CAAC4K,QAAS1P,SAC/BuD,SAAS,GAEXunB,aAAc,CACZrnB,KAAMyB,OACN3B,QAAS,OAEXwnB,UAAW,CACTtnB,KAAM6K,UAER0c,OAAQ,CACNvnB,KAAM6K,UAER0b,YAAa,CACXvmB,KAAMyB,QAERuI,KAAM,CACJhK,KAAMyB,OACN3B,QAAS,IAEX0nB,SAAU,CACRxnB,KAAMiM,QACNnM,SAAS,GAEX2nB,UAAW,CACTznB,KAAMiM,QACNnM,SAAS,GAEX4nB,aAAc,CACZ1nB,KAAMiM,QACNnM,SAAS,GAEX6nB,cAAe,CACb3nB,KAAMiM,QACNnM,SAAS,GAEX8nB,WAAY,CACV5nB,KAAM4K,GACN9K,QAAS,IAEX+nB,WAAY,CACV7nB,KAAM4K,GACN9K,QAAS,IAEXgoB,cAAe,CACb9nB,KAAMyB,OACN3B,aAAS,GAEXgiB,MAAO,CACL9hB,KAAMyB,OACN3B,aAAS,GAEXioB,SAAU,CACR/nB,KAAM,CAACyB,OAAQD,QACf1B,QAAS,GAEXkoB,cAAe,CACbhoB,KAAMiM,QACNnM,SAAS,GAEXmoB,WAAY,CACVjoB,KAAMqB,EAAe,CAAC9E,OAAQ8D,MAAOoB,SACrC3B,QAAS,IAAMinB,GAAQ,OAGdmB,GAAa,CACxB,CAAClB,IAAsBtoB,IAAUhB,EAAAA,EAAAA,IAASgB,GAC1CypB,MAAQzpB,IAAUhB,EAAAA,EAAAA,IAASgB,GAC3B0pB,OAAS1pB,IAAUhB,EAAAA,EAAAA,IAASgB,GAC5B2pB,MAAQrb,GAAQA,aAAesb,WAC/BC,KAAOvb,GAAQA,aAAesb,WAC9B/pB,MAAO,KAAM,EACbiqB,WAAaxb,GAAQA,aAAeC,WACpCwb,WAAazb,GAAQA,aAAeC,WACpCyb,QAAU1b,GAAQA,aAAe2b,MACjCC,iBAAmB5b,GAAQA,aAAe6b,iBAC1CC,kBAAoB9b,GAAQA,aAAe6b,iBAC3CE,eAAiB/b,GAAQA,aAAe6b,kBC3GpCG,GAAuB,CAAC,QAAS,SACjCC,GAAkB,WACXC,GAAW,CAACC,EAAS,MAChC,MAAM,iBAAEC,GAAmB,EAArB,YAA4BC,GAAgBF,EAC5CG,GAAiBrmB,EAAAA,EAAAA,KAAS,MACN,MAAfomB,OAAsB,EAASA,EAAY3qB,QAAU,IAAIwP,OAAO8a,MAErEO,GAAWxmB,EAAAA,EAAAA,MACjB,OAAKwmB,GAIEtmB,EAAAA,EAAAA,KAAS,KACd,IAAI7F,EACJ,OAAO2B,EAAUxC,OAAO6E,QAAiC,OAAxBhE,EAAKmsB,EAAShgB,YAAiB,EAASnM,EAAGosB,QAAQ3jB,QAAO,EAAEnG,MAAU4pB,EAAe5qB,MAAM+B,SAASf,MAAU0pB,GAAoBH,GAAgBnrB,KAAK4B,WALxL4C,EAAU,YAAa,iGAChBW,EAAAA,EAAAA,KAAS,aCZb,SAASwmB,GAAUtB,GACxB,MAAMuB,GAAerrB,EAAAA,EAAAA,MACrB,SAASsrB,IACP,QAAmB,GAAfxB,EAAMzpB,MACR,OACF,MAAM,eAAEkrB,EAAF,aAAkBC,EAAlB,MAAgCnrB,GAAUypB,EAAMzpB,MACtD,GAAsB,MAAlBkrB,GAA0C,MAAhBC,EAC5B,OACF,MAAMC,EAAYprB,EAAMqrB,MAAM,EAAGvc,KAAKJ,IAAI,EAAGwc,IACvCI,EAAWtrB,EAAMqrB,MAAMvc,KAAKJ,IAAI,EAAGyc,IACzCH,EAAahrB,MAAQ,CACnBkrB,eAAAA,EACAC,aAAAA,EACAnrB,MAAAA,EACAorB,UAAAA,EACAE,SAAAA,GAGJ,SAASC,IACP,QAAmB,GAAf9B,EAAMzpB,YAAyC,GAAtBgrB,EAAahrB,MACxC,OACF,MAAM,MAAEA,GAAUypB,EAAMzpB,OAClBorB,UAAEA,EAAF,SAAaE,EAAb,eAAuBJ,GAAmBF,EAAahrB,MAC7D,QAAiB,GAAborB,QAAmC,GAAZE,QAAwC,GAAlBJ,EAC/C,OACF,IAAIM,EAAWxrB,EAAMQ,OACrB,GAAIR,EAAMyrB,SAASH,GACjBE,EAAWxrB,EAAMQ,OAAS8qB,EAAS9qB,YAC9B,GAAIR,EAAMiR,WAAWma,GAC1BI,EAAWJ,EAAU5qB,WAChB,CACL,MAAMkrB,EAAiBN,EAAUF,EAAiB,GAC5CS,EAAW3rB,EAAMoP,QAAQsc,EAAgBR,EAAiB,IAC9C,IAAdS,IACFH,EAAWG,EAAW,GAG1BlC,EAAMzpB,MAAM4rB,kBAAkBJ,EAAUA,GAE1C,MAAO,CAACP,EAAcM,GCxCZ,MAACM,GAAYje,GAAS,yCAAyCxO,KAAKwO,G,gUCoM1Eke,EAAc,CACpBC,OAAAA,SACA3J,OAAAA,WAUMyI,GAAW,UACXmB,GAAW,UACXlI,GAAQ,UAERmI,GAAiB,SAAQ,KAC/B,WAMA,MALA,+BACAC,EAAAA,iBAAAA,EAAAA,iBACAA,EAAAA,aAAAA,EAAAA,aACAA,EAAAA,iBAAAA,EAAAA,kBAEA,KAGMC,EAAQ3B,GAAS,CACvBG,aAAAA,EAAAA,EAAAA,KAAAA,IACA,0BAGM,KAANrf,EAAAA,SAAAC,GAAA,MACM,QAAN0X,GAAA,MACAH,gBAAAA,IAEMsJ,EAAYlhB,KACZmhB,EAAgB7gB,KAChB8gB,EAAUvmB,GAAa,SACvBwmB,EAAaxmB,GAAa,YAE1B0jB,GAAQ,UACR+C,GAAW,UAEXC,GAAU,SAAI,GACdC,GAAW,SAAI,GACfC,GAAc,SAAI,GAClBC,GAAkB,SAAI,GACtBC,GAAa,UACbC,GAAoB,QAAWrqB,EAAM8mB,YAErCtF,GAAO,SAAS,IAAMwF,EAAMzpB,OAASwsB,EAASxsB,QAE9C+sB,GAAiB,SAAS,KAChC,MACA,mDAIM,GAAN,oDACAC,GAAAA,EAAAA,EAAAA,KAAAA,IAAAA,GAAAA,EAAAA,SACAC,GAAAA,EAAAA,EAAAA,KAAAA,IAAAA,EAAAA,MAAAA,GAAAA,KACA,iBACAjB,EAAAA,MACAvpB,EAAAA,cAEA,iBACAA,EAAAA,WACAqqB,EAAAA,MAGA,CAAArE,OAAAA,EAAAA,WAeM,GAAN,SACA,OACA,cACA,GAAA1lB,OAAAA,EAAAA,cAMM,GAAN,iFACM,GAAN,SAGA,qBACA,2BACA,OAAA0pB,EAAAA,SACM,GAAN,SAEA,uBACA,oBAEAhqB,SAAAA,EAAAA,MACAA,aAAAA,EAAAA,QACA,uBACA,iBAEM,GAAN,0CAEA,+DACA,+GACAwjB,GAAAA,GAAAA,IACA,+BACA,OAEA,cACA,MAAAiH,GAAA,cACAL,EAAAA,MAAAA,CAEAM,MAAAA,eAAAA,EAAAA,GAAAA,WAGA,aAEA,WAAA7rB,EAAAA,SAAAonB,GAAA,EACA,qBAEA,YACAnB,GAAAA,EAAAA,EAAAA,IAAAA,GAAAA,EAAAA,aAAAA,EACA,+BACAuF,EAAAA,MAAAA,IACA,sBAGAA,EAAAA,MAAAA,CACA7E,UAAAA,GAAAA,EAAAA,OAAAA,YAIA,OACA,gBACA,uBAGAmF,EAAAA,MAAAA,EAAAA,QACA,MACA,SAAA7lB,GAAA,QAGA,MACA,4DAEA,gCAEA,MACA,OAGA,aACA,KACArE,EAAAA,MAAAA,UAAAA,cAAAA,WAAAA,EAAAA,IAAAA,KAAAA,EAAAA,cAAAA,IAAAA,EAAAA,GAAAA,QAAAA,MAAAA,iBAGAA,EAAAA,gBAAAA,UAGA,OAEAmqB,EAAAA,UACAA,EAAAA,WAIA,YACApC,IACA,UAAAjrB,GAAA,SACA,cAIAA,EAAAA,EAAAA,OAAAA,EAAAA,OAAAA,GAAAA,EAAAA,EAAAA,EAAAA,UAAAA,IAIA,SAGA,cAKAmkB,EAAAA,GAAAA,GACAA,EAAAA,QAAAA,SACA,UAEAmJ,IACA/B,MAGM,EAAN,IACApH,EAAAA,SAAAA,EAAAA,OAAAA,QAEA,MAEAA,EAAAA,mBAAAA,GACAwI,EAAAA,OAAAA,GAEA,OACA,MACAxI,EAAAA,oBAAAA,GAEA,MAAM,EAAN,kCACA,oBACAwI,EAAAA,OAAAA,GAAAA,IAEA,OACAxI,EAAAA,iBAAAA,GACA,UAEAwI,EAAAA,OAAAA,EACAY,EAAAA,KAIM,GAAN,KAEAX,EAAAA,OAAAA,EAAAA,MACAjD,MAGM,GAAN,UAEA,YACA,UACA,8BAGM,GAAN,KACA,MACA,0CAEA,OACA8C,EAAAA,OAAAA,EACAtI,EAAAA,QAAAA,IAGA,OACA,MACAsI,EAAAA,OAAAA,EAEAtI,EAAAA,OAAAA,GACA,kBACA,yEAIA,OACAuI,EAAAA,OAAAA,EAEAvI,EAAAA,aAAAA,IAEA,OAEAuI,EAAAA,OAAAA,EACAvI,EAAAA,aAAAA,IAEA,OACAA,EAAAA,UAAAA,IAIA,QAEA,MACA,+BAEA,QAEAA,EAAAA,GAAAA,IAKAA,EAAAA,SAAAA,IAMAA,EAAAA,SAEAA,EAAAA,QAAAA,K,OAEAlC,EAAAA,EAAAA,KAAAA,IAAAA,EAAAA,aAAAA,KACA,OAEAuL,EAAAA,EAAAA,KAAAA,IAAAA,MAEA,kBACA,8EAMAvL,EAAAA,EAAAA,IAAAA,GAAAA,IAAAA,OACAA,EAAAA,EAAAA,KAAAA,IAAAA,EAAAA,OAAAA,gBACA,UACAqL,IACAG,IAEAC,QAEApK,EAAAA,EAAAA,KAAAA,WACA,uBAEA1f,EAAAA,UAAAA,8DAIA0pB,IAEAI,UAEA,UAGAD,QAKAE,EAAAA,EAAAA,KAAAA,gBAEA,UAEAD,OAGAtJ,EAAAA,C,knJC1hBY,MAACwJ,GAAUnlB,GAAYolB,ICDtBC,GAAiBC,IAC5B,IAAKA,EACH,MAAO,CAAEC,QAAS7kB,EAAAA,GAAM8kB,YAAa9kB,EAAAA,GAAM+kB,UAAW/kB,EAAAA,IAExD,IAAIglB,GAAkB,EAClBC,GAAgB,EACpB,MAAMJ,EAAWhoB,IACXmoB,GAAmBC,GACrBL,EAAY/nB,GAEdmoB,EAAkBC,GAAgB,GAE9BH,EAAejoB,IACnBmoB,EAAkBnoB,EAAE9C,SAAW8C,EAAEqoB,eAE7BH,EAAaloB,IACjBooB,EAAgBpoB,EAAE9C,SAAW8C,EAAEqoB,eAEjC,MAAO,CAAEL,QAAAA,EAASC,YAAAA,EAAaC,UAAAA,ICLvB,IAACI,GAA6B,CAAEC,IACxCA,EAAYA,EAAY,QAAU,GAAK,OACvCA,EAAYA,EAAY,SAAW,GAAK,QACxCA,EAAYA,EAAY,SAAW,GAAK,QACxCA,EAAYA,EAAY,SAAW,GAAK,QACxCA,EAAYA,EAAY,cAAgB,IAAM,aAC9CA,EAAYA,EAAY,kBAAoB,IAAM,iBAClDA,EAAYA,EAAY,mBAAqB,IAAM,kBACnDA,EAAYA,EAAY,kBAAoB,KAAO,iBACnDA,EAAYA,EAAY,oBAAsB,KAAO,mBACrDA,EAAYA,EAAY,cAAgB,KAAO,aAC/CA,EAAYA,EAAY,iBAAmB,MAAQ,gBACnDA,EAAYA,EAAY,YAAc,GAAK,UAC3CA,EAAYA,EAAY,SAAW,GAAK,OACjCA,GAd+B,CAerCD,IAAc,IAsCL,MChECE,GAAehsB,EAAW,CACrCisB,KAAM,CACJntB,KAAMiM,QACNnM,SAAS,GAEXstB,gBAAiB,CACfptB,KAAMiM,QACNnM,SAAS,GAEXutB,aAAc,CACZrtB,KAAMqB,EAAe,CACnBI,OACApB,MACA9D,UAGJ+wB,OAAQ,CACNttB,KAAMqB,EAAe,CAACI,OAAQD,YAGrB+rB,GAAe,CAC1BxgB,MAAQC,GAAQA,aAAeC,YAEjC,QAAe/E,EAAAA,EAAAA,IAAgB,CAC7B/F,KAAM,YACNhB,MAAO+rB,GACPM,MAAOD,GACPE,MAAMtsB,GAAO,MAAEqhB,EAAF,KAASK,IACpB,MAAM5b,EAAKxC,GAAa,WAClBipB,EAAehpB,IACnBme,EAAK,QAASne,KAEV,QAAEgoB,EAAF,YAAWC,EAAX,UAAwBC,GAAcJ,GAAcrrB,EAAMisB,qBAAkB,EAASM,GAC3F,MAAO,IACEvsB,EAAMgsB,MAAOQ,EAAAA,EAAAA,IAAY,MAAO,CACrCC,MAAO,CAAC3mB,EAAGnD,IAAK3C,EAAMksB,cACtB1mB,MAAO,CACL2mB,OAAQnsB,EAAMmsB,QAEhBZ,QAAAA,EACAC,YAAAA,EACAC,UAAAA,GACC,EAACiB,EAAAA,EAAAA,IAAWrL,EAAO,YAAawK,GAAAA,MAAmBA,GAAAA,MAAmBA,GAAAA,MAAkB,CAAC,UAAW,YAAa,iBAAkBve,EAAAA,EAAAA,GAAE,MAAO,CAC7Imf,MAAOzsB,EAAMksB,aACb1mB,MAAO,CACL2mB,OAAQnsB,EAAMmsB,OACdQ,SAAU,QACVC,IAAK,MACLlC,MAAO,MACPmC,OAAQ,MACRC,KAAM,QAEP,EAACJ,EAAAA,EAAAA,IAAWrL,EAAO,gBCtDhB,MAAC0L,GAAYC,GCDZC,GAAa,CACxBC,IAAK,MACLC,MAAO,QACPC,MAAO,QACPN,KAAM,YACNO,GAAI,UACJ3C,MAAO,aACP4C,KAAM,YACNC,IAAK,SACLC,OAAQ,SACRC,UAAW,YACXC,YAAa,cACbC,OAAQ,SACRC,SAAU,WACVC,KAAM,OACNC,IAAK,OCfDC,GAA+B,6KACxBC,GAAa7qB,IAGxB,MAAMrB,EAAW6D,iBAAiBxC,GAClC,MAA6B,UAAtBrB,EAAS6qB,UAAwD,OAAzBxpB,EAAQ8qB,cAE5CC,GAA8B/qB,GAClCjE,MAAMC,KAAKgE,EAAQgrB,iBAAiBJ,KAA8BrpB,QAAQC,GAASypB,GAAYzpB,IAASqpB,GAAUrpB,KAE9GypB,GAAejrB,IAC1B,GAAIA,EAAQkrB,SAAW,GAA0B,IAArBlrB,EAAQkrB,UAAuD,OAArClrB,EAAQmrB,aAAa,YACzE,OAAO,EAET,GAAInrB,EAAQ6F,SACV,OAAO,EAET,OAAQ7F,EAAQorB,UACd,IAAK,IACH,QAASprB,EAAQqrB,MAAwB,WAAhBrrB,EAAQsrB,IAEnC,IAAK,QACH,QAA0B,WAAjBtrB,EAAQtE,MAAsC,SAAjBsE,EAAQtE,MAEhD,IAAK,SACL,IAAK,SACL,IAAK,WACH,OAAO,EAET,QACE,OAAO,IC9BA6vB,GAAK,CAACvrB,EAASof,EAAOoM,EAASC,GAAa,KACnDzrB,GAAWof,GAASoM,IACX,MAAXxrB,GAA2BA,EAAQwf,iBAAiBJ,EAAOoM,EAASC,KAG3DC,GAAM,CAAC1rB,EAASof,EAAOoM,EAASC,GAAa,KACpDzrB,GAAWof,GAASoM,IACX,MAAXxrB,GAA2BA,EAAQyf,oBAAoBL,EAAOoM,EAASC,KCJ9DE,GAAqB,uBAE5BC,GAAc,GACdC,GAAiBzrB,IAErB,GAA2B,IAAvBwrB,GAAYhxB,OACd,OACF,MAAMkxB,EAAmBF,GAAYA,GAAYhxB,OAAS,GAAG+wB,IAC7D,GAAIG,EAAiBlxB,OAAS,GAAKwF,EAAE2rB,OAASjC,GAAAA,IAAgB,CAC5D,GAAgC,IAA5BgC,EAAiBlxB,OAKnB,OAJAwF,EAAE4rB,sBACE1pB,SAAS2pB,gBAAkBH,EAAiB,IAC9CA,EAAiB,GAAG/H,SAIxB,MAAMmI,EAAgB9rB,EAAE+rB,SAClBC,EAAUhsB,EAAE9C,SAAWwuB,EAAiB,GACxCO,EAASjsB,EAAE9C,SAAWwuB,EAAiBA,EAAiBlxB,OAAS,GACnEwxB,GAAWF,IACb9rB,EAAE4rB,iBACFF,EAAiBA,EAAiBlxB,OAAS,GAAGmpB,SAE5CsI,IAAWH,IACb9rB,EAAE4rB,iBACFF,EAAiB,GAAG/H,WAUpBuI,GAAY,CAChBC,YAAY5qB,GACVA,EAAGgqB,IAAsBZ,GAA2BppB,GACpDiqB,GAAY1vB,KAAKyF,GACbiqB,GAAYhxB,QAAU,GACxB2wB,GAAGjpB,SAAU,UAAWupB,KAG5BW,QAAQ7qB,IACNimB,EAAAA,EAAAA,KAAS,KACPjmB,EAAGgqB,IAAsBZ,GAA2BppB,OAGxD8qB,YACEb,GAAYc,QACe,IAAvBd,GAAYhxB,QACd8wB,GAAIppB,SAAU,UAAWupB,MCtDlBd,GAA8B/qB,IACzC,MAAM2sB,EAAQ,GACRC,EAAStqB,SAASuqB,iBAAiB7sB,EAAS8sB,WAAWC,aAAc,CACzEC,WAAaC,IACX,MAAMC,EAAiC,UAAjBD,EAAKE,SAAqC,WAAdF,EAAKvxB,KACvD,OAAIuxB,EAAKpnB,UAAYonB,EAAKG,QAAUF,EAC3BJ,WAAWO,YACbJ,EAAK/B,UAAY,GAAK+B,IAAS3qB,SAAS2pB,cAAgBa,WAAWQ,cAAgBR,WAAWO,eAGzG,MAAOT,EAAOW,WACZZ,EAAMzwB,KAAK0wB,EAAOY,aACpB,OAAOb,GAEIc,GAAoB,CAACC,EAAUC,KAC1C,IAAK,MAAM3tB,KAAW0tB,EACpB,IAAKE,GAAS5tB,EAAS2tB,GACrB,OAAO3tB,GAGA4tB,GAAW,CAAC5tB,EAAS2tB,KAGhC,GAA6C,WAAzCnrB,iBAAiBxC,GAAS6tB,WAC5B,OAAO,EACT,MAAO7tB,EAAS,CACd,GAAI2tB,GAAa3tB,IAAY2tB,EAC3B,OAAO,EACT,GAA0C,SAAtCnrB,iBAAiBxC,GAAS8tB,QAC5B,OAAO,EACT9tB,EAAUA,EAAQ+tB,cAEpB,OAAO,GAEIC,GAAYL,IACvB,MAAMM,EAAYlD,GAA2B4C,GACvCO,EAAQT,GAAkBQ,EAAWN,GACrCQ,EAAOV,GAAkBQ,EAAUG,UAAWT,GACpD,MAAO,CAACO,EAAOC,IAEXE,GAAgBruB,GACbA,aAAmBsuB,kBAAoB,WAAYtuB,EAE/CuuB,GAAW,CAACvuB,EAASwuB,KAChC,GAAIxuB,GAAWA,EAAQ+jB,MAAO,CAC5B,MAAM0K,EAAqBnsB,SAAS2pB,cACpCjsB,EAAQ+jB,MAAM,CAAE2K,eAAe,IAC3B1uB,IAAYyuB,GAAsBJ,GAAaruB,IAAYwuB,GAC7DxuB,EAAQ2uB,WAId,SAASC,GAAgBC,EAAMrtB,GAC7B,MAAMstB,EAAO,IAAID,GACXE,EAAMF,EAAKrlB,QAAQhI,GAIzB,OAHa,IAATutB,GACFD,EAAKE,OAAOD,EAAK,GAEZD,EAET,MAAMG,GAAuB,KAC3B,IAAIC,EAAQ,GACZ,MAAMhzB,EAAQizB,IACZ,MAAMC,EAAeF,EAAM,GACvBE,GAAgBD,IAAUC,GAC5BA,EAAaC,QAEfH,EAAQN,GAAgBM,EAAOC,GAC/BD,EAAMI,QAAQH,IAEVltB,EAAUktB,IACd,IAAIr2B,EAAI8F,EACRswB,EAAQN,GAAgBM,EAAOC,GACwB,OAAtDvwB,EAAwB,OAAlB9F,EAAKo2B,EAAM,SAAc,EAASp2B,EAAGy2B,SAA2B3wB,EAAG6W,KAAK3c,IAEjF,MAAO,CACLoD,KAAAA,EACA+F,OAAAA,IAGSutB,GAAuB,CAAC9B,EAAUc,GAAe,KAC5D,MAAMC,EAAqBnsB,SAAS2pB,cACpC,IAAK,MAAMjsB,KAAW0tB,EAEpB,GADAa,GAASvuB,EAASwuB,GACdlsB,SAAS2pB,gBAAkBwC,EAC7B,QAGOgB,GAAiBR,KCxFjBS,GAAsB,iCACtBC,GAAuB,kCACvBC,GAA2B,CACtCC,YAAY,EACZC,SAAS,GAEEC,GAAoB,oBACpBC,GAAuB,qBACvBC,GAA2Bj1B,OAAO,eCL/C,IAAIk1B,GAA2B,GACnB,MAACC,GAAoB3E,IAC/B,MAAM4E,EAAiBhwB,IACrB,MAAMgf,EAAQhf,EACVgf,EAAMhkB,MAAQ0uB,GAAAA,KAChBoG,GAAyBG,SAASC,GAAsBA,EAAkBlR,OAG9E1B,EAAAA,EAAAA,KAAU,KACgC,IAApCwS,GAAyBt1B,QAC3B0H,SAASkd,iBAAiB,UAAW4Q,GAEnCr3B,GACFm3B,GAAyBh0B,KAAKsvB,OAElC+E,EAAAA,EAAAA,KAAgB,KACdL,GAA2BA,GAAyB3uB,QAAQ+uB,GAAsBA,IAAsB9E,IAChE,IAApC0E,GAAyBt1B,QACvB7B,GACFuJ,SAASmd,oBAAoB,UAAW2Q,OCc3CzsB,IAAaC,EAAAA,EAAAA,IAAa,CAC7B/F,KAAM,cACN2yB,cAAc,EACd3zB,MAAO,CACL4zB,KAAM9oB,QACN+oB,QAAS/oB,QACTgpB,YAAa14B,OACb24B,aAAc,CACZl1B,KAAM,CAACzD,OAAQkF,QACf3B,QAAS,UAGb0tB,MAAO,CACL6G,GACAC,GACA,UACA,WACA,qBACA,qBAEF7G,MAAMtsB,GAAO,KAAE0hB,IACb,MAAMsS,GAAa92B,EAAAA,EAAAA,MACf,IAAA+2B,EACAC,EAEJZ,IAAkB/Q,IACZviB,EAAM6zB,UAAYM,EAAWC,QAC/B1S,EAAK,oBAAqBa,MAI9B,MAAM4R,EAAyB,CAC7BC,QAAQ,EACR5B,QACErY,KAAKia,QAAS,GAEhB1B,SACEvY,KAAKia,QAAS,IAIZC,EAAa9wB,IACjB,IAAKvD,EAAM4zB,OAAS5zB,EAAM6zB,QAAS,OACnC,GAAIM,EAAWC,OAAQ,OAEvB,MAAM,IAAE71B,EAAF,OAAO+1B,EAAP,QAAeC,EAAf,QAAwBC,EAAxB,cAAiC5I,EAAjC,SAAgD0D,GAAa/rB,GAC7D,KAAEqwB,GAAS5zB,EACXy0B,EACJl2B,IAAQ0uB,GAAWC,MAAQoH,IAAWC,IAAYC,EAE9CE,EAAoBjvB,SAAS2pB,cACnC,GAAIqF,GAAaC,EAAmB,CAClC,MAAM5D,EAAYlF,GACXyF,EAAOC,GAAQH,GAASL,GACzB6D,EAAatD,GAASC,EACvBqD,EAMErF,GAAYoF,IAAsBpD,EAKrChC,GACA,CAAC+B,EAAOP,GAAWxxB,SAASo1B,KAE5BnxB,EAAE4rB,iBACEyE,GAAMlC,GAASJ,GAAM,GACzB5P,EAAK,wBATLne,EAAE4rB,iBACEyE,GAAMlC,GAASL,GAAO,GAC1B3P,EAAK,uBARHgT,IAAsB5D,IACxBvtB,EAAE4rB,iBACFzN,EAAK,0BAmBbpf,EAAAA,EAAAA,IAAQ8wB,GAA0B,CAChCwB,aAAcZ,EACdK,UAAAA,KAGF7U,EAAAA,EAAAA,KACE,IAAMxf,EAAM8zB,cACXA,IACKA,IACFE,EAAWz2B,MAAQu2B,KAGvB,CAAE92B,WAAW,KAGfwiB,EAAAA,EAAAA,IAAM,CAACwU,IAAa,EAAEa,IAAcC,MAC9BD,IACSA,EAAAA,iBAAiB,UAAWR,GAC5BQ,EAAAA,iBAAiB,UAAWE,GAC5BF,EAAAA,iBAAiB,WAAYG,IAEtCF,IACYA,EAAAA,oBAAoB,UAAWT,GAC/BS,EAAAA,oBAAoB,UAAWC,GAC/BD,EAAAA,oBAAoB,WAAYE,OAI5C,MAAAC,EAAe1xB,IACnBme,EAAKwR,GAAmB3vB,IAEpB2xB,EAAkB3xB,GAAame,EAAKyR,GAAsB5vB,GAE1DwxB,EAAaxxB,IACX,MAAA4xB,GAAgBx3B,EAAAA,EAAAA,IAAMq2B,GAC5B,IAAKmB,EAAe,OAEpB,MAAM10B,EAAS8C,EAAE9C,OACX20B,EAAkB30B,GAAU00B,EAAcnwB,SAASvE,GACrD20B,GAAiB1T,EAAK,UAAWne,GAEjC4wB,EAAWC,QAEXp0B,EAAM6zB,UACJuB,EACsBlB,EAAAA,EAExBxC,GAASwC,GAAuB,KAKhCc,EAAczxB,IACZ,MAAA4xB,GAAgBx3B,EAAAA,EAAAA,IAAMq2B,GACxB,IAAAG,EAAWC,QAAWe,EAE1B,GAAIn1B,EAAM6zB,QAELsB,EAAcnwB,SACZzB,EAAiB8xB,gBAGpB3D,GAASwC,GAAuB,OAE7B,CACL,MAAMzzB,EAAS8C,EAAE9C,OACX20B,EAAkB30B,GAAU00B,EAAcnwB,SAASvE,GACpD20B,GAAiB1T,EAAK,WAAYne,KAIhB,yBAEnBwnB,EAAAA,EAAAA,MACA,MAAAoK,GAAgBx3B,EAAAA,EAAAA,IAAMq2B,GAC5B,GAAImB,EAAe,CACjBvC,GAAevzB,KAAK80B,GACpB,MAAMvC,EAAqBnsB,SAAS2pB,cACX6E,EAAAA,EACnB,MAAAqB,EAAuBH,EAAcnwB,SAAS4sB,GACpD,IAAK0D,EAAsB,CACzB,MAAMC,EAAa,IAAI/N,MACrBqL,GACAE,IAEYoC,EAAAA,iBAAiBtC,GAAqBoC,GACpDE,EAAcK,cAAcD,GACvBA,EAAWE,mBACd1K,EAAAA,EAAAA,KAAS,KACP,IAAIgJ,EAAe/zB,EAAM+zB,cACpBx3B,EAAAA,EAAAA,IAASw3B,KACZrC,GAASqC,GACLtuB,SAAS2pB,gBAAkB2E,IACdA,EAAAA,UAGE,UAAjBA,GAEApB,GAAAA,GAA2BwC,IAC3B,GAIF1vB,SAAS2pB,gBAAkBwC,GACV,cAAjBmC,GAEArC,GAASyD,QAQD,aACZ,MAAAA,GAAgBx3B,EAAAA,EAAAA,IAAMq2B,GAE5B,GAAImB,EAAe,CACHA,EAAAA,oBAAoBtC,GAAqBoC,GAEvD,MAAMS,EAAgB,IAAIlO,MACxBsL,GACAC,IAEYoC,EAAAA,iBAAiBrC,GAAsBoC,GACrDC,EAAcK,cAAcE,GAEvBA,EAAcD,kBACR/D,GAA0B,MAA1BA,EAAmCuC,EAAUxuB,SAAAA,MAAA,GAG1C0vB,EAAAA,oBAAoBrC,GAAsBmC,GACxDrC,GAAextB,OAAO+uB,IA2BnB,OAvBPtT,EAAAA,EAAAA,KAAU,KACJ7gB,EAAM6zB,SACE8B,KAGZnW,EAAAA,EAAAA,KACE,IAAMxf,EAAM6zB,UACXA,IACKA,EACQ8B,IAEDC,WAMjBlC,EAAAA,EAAAA,KAAgB,KACV1zB,EAAM6zB,SACC+B,OAIN,CACLvB,UAAAA,M,gCAhRJwB,EAAAA,EAAAA,IAAoC,oBAA7BC,cAAgBruB,EAAS,Y,wICAtB,MAACsuB,GAAwBz5B,GAAQ,CAAC,MAAO+L,IAAgB/I,SAAShD,GCsB9E,IAAI05B,GAAU92B,MAAM82B,QAEpB,MCxBIC,GAA8B,iBAAV/zB,QAAsBA,QAAUA,OAAO9G,SAAWA,QAAU8G,OAEpF,MCAIg0B,GAA0B,iBAARlT,MAAoBA,MAAQA,KAAK5nB,SAAWA,QAAU4nB,KAGxEmT,GAAOF,IAAcC,IAAYxsB,SAAS,cAATA,GAErC,MCLIvL,GAASg4B,GAAAA,OAEb,MCFIC,GAAch7B,OAAOK,UAGrBC,GAAiB06B,GAAY16B,eAO7B26B,GAAuBD,GAAY/5B,SAGnCi6B,GAAiBn4B,GAASA,GAAAA,iBAAqBo4B,EASnD,SAASC,GAAUj5B,GACjB,IAAIk5B,EAAQ/6B,GAAekd,KAAKrb,EAAO+4B,IACnCI,EAAMn5B,EAAM+4B,IAEhB,IACE/4B,EAAM+4B,SAAkBC,EACxB,IAAII,GAAW,EACf,MAAOpzB,IAET,IAAIvF,EAASq4B,GAAqBzd,KAAKrb,GAQvC,OAPIo5B,IACEF,EACFl5B,EAAM+4B,IAAkBI,SAEjBn5B,EAAM+4B,KAGVt4B,EAGT,UC5CIo4B,GAAch7B,OAAOK,UAOrB46B,GAAuBD,GAAY/5B,SASvC,SAASu6B,GAAer5B,GACtB,OAAO84B,GAAqBzd,KAAKrb,GAGnC,UChBIs5B,GAAU,gBACVC,GAAe,qBAGfR,GAAiBn4B,GAASA,GAAAA,iBAAqBo4B,EASnD,SAASQ,GAAWx5B,GAClB,OAAa,MAATA,OACeg5B,IAAVh5B,EAAsBu5B,GAAeD,GAEtCP,IAAkBA,MAAkBl7B,OAAOmC,GAC/Ci5B,GAAUj5B,GACVq5B,GAAer5B,GAGrB,UCHA,SAASy5B,GAAaz5B,GACpB,OAAgB,MAATA,GAAiC,iBAATA,EAGjC,UCxBI05B,GAAY,kBAmBhB,SAASC,GAAS35B,GAChB,MAAuB,iBAATA,GACXy5B,GAAaz5B,IAAUw5B,GAAWx5B,IAAU05B,GAGjD,UCxBIE,GAAe,mDACfC,GAAgB,QAUpB,SAASC,GAAM95B,EAAOwG,GACpB,GAAIiyB,GAAQz4B,GACV,OAAO,EAET,IAAIsB,SAActB,EAClB,QAAY,UAARsB,GAA4B,UAARA,GAA4B,WAARA,GAC/B,MAATtB,IAAiB25B,GAAS35B,MAGvB65B,GAAcz6B,KAAKY,KAAW45B,GAAax6B,KAAKY,IAC1C,MAAVwG,GAAkBxG,KAASnC,OAAO2I,IAGvC,UCHA,SAASvF,GAASjB,GAChB,IAAIsB,SAActB,EAClB,OAAgB,MAATA,IAA0B,UAARsB,GAA4B,YAARA,GAG/C,UC1BIy4B,GAAW,yBACXC,GAAU,oBACVC,GAAS,6BACTC,GAAW,iBAmBf,SAASC,GAAWn6B,GAClB,IAAKiB,GAASjB,GACZ,OAAO,EAIT,IAAIm5B,EAAMK,GAAWx5B,GACrB,OAAOm5B,GAAOa,IAAWb,GAAOc,IAAUd,GAAOY,IAAYZ,GAAOe,GAGtE,UCjCIE,GAAaxB,GAAAA,sBAEjB,MCFIyB,GAAc,WAChB,IAAIC,EAAM,SAAS7d,KAAK2d,IAAcA,GAAAA,MAAmBA,GAAAA,KAAAA,UAA4B,IACrF,OAAOE,EAAO,iBAAmBA,EAAO,GAFxB,GAYlB,SAASC,GAASC,GAChB,QAASH,IAAeA,MAAcG,EAGxC,UClBIC,GAAYtuB,SAASjO,UAGrBw8B,GAAeD,GAAU37B,SAS7B,SAAS67B,GAASH,GAChB,GAAY,MAARA,EAAc,CAChB,IACE,OAAOE,GAAarf,KAAKmf,GACzB,MAAOx0B,IACT,IACE,OAAQw0B,EAAO,GACf,MAAOx0B,KAEX,MAAO,GAGT,UChBI40B,GAAe,sBAGfC,GAAe,8BAGfJ,GAAYtuB,SAASjO,UACrB26B,GAAch7B,OAAOK,UAGrBw8B,GAAeD,GAAU37B,SAGzBX,GAAiB06B,GAAY16B,eAG7B28B,GAAalf,OAAO,IACtB8e,GAAarf,KAAKld,IAAgB48B,QAAQH,GAAc,QACvDG,QAAQ,yDAA0D,SAAW,KAWhF,SAASC,GAAah7B,GACpB,IAAKiB,GAASjB,IAAUu6B,GAASv6B,GAC/B,OAAO,EAET,IAAIi7B,EAAUd,GAAWn6B,GAAS86B,GAAaD,GAC/C,OAAOI,EAAQ77B,KAAKu7B,GAAS36B,IAG/B,UCtCA,SAASk7B,GAAS10B,EAAQxF,GACxB,OAAiB,MAAVwF,OAAiBwyB,EAAYxyB,EAAOxF,GAG7C,UCDA,SAASm6B,GAAU30B,EAAQxF,GACzB,IAAIhB,EAAQk7B,GAAS10B,EAAQxF,GAC7B,OAAOg6B,GAAah7B,GAASA,OAAQg5B,EAGvC,UCbIoC,GAAeD,GAAUt9B,OAAQ,UAErC,MCIA,SAASw9B,KACPze,KAAK0e,SAAWF,GAAeA,GAAa,MAAQ,GACpDxe,KAAK/Z,KAAO,EAGd,UCJA,SAAS04B,GAAWv6B,GAClB,IAAIP,EAASmc,KAAK4e,IAAIx6B,WAAe4b,KAAK0e,SAASt6B,GAEnD,OADA4b,KAAK/Z,MAAQpC,EAAS,EAAI,EACnBA,EAGT,UCbIg7B,GAAiB,4BAGjB5C,GAAch7B,OAAOK,UAGrBC,GAAiB06B,GAAY16B,eAWjC,SAASu9B,GAAQ16B,GACf,IAAI26B,EAAO/e,KAAK0e,SAChB,GAAIF,GAAc,CAChB,IAAI36B,EAASk7B,EAAK36B,GAClB,OAAOP,IAAWg7B,QAAiBzC,EAAYv4B,EAEjD,OAAOtC,GAAekd,KAAKsgB,EAAM36B,GAAO26B,EAAK36B,QAAOg4B,EAGtD,UC1BIH,GAAch7B,OAAOK,UAGrBC,GAAiB06B,GAAY16B,eAWjC,SAASy9B,GAAQ56B,GACf,IAAI26B,EAAO/e,KAAK0e,SAChB,OAAOF,QAA8BpC,IAAd2C,EAAK36B,GAAsB7C,GAAekd,KAAKsgB,EAAM36B,GAG9E,UCnBIy6B,GAAiB,4BAYrB,SAASI,GAAQ76B,EAAKhB,GACpB,IAAI27B,EAAO/e,KAAK0e,SAGhB,OAFA1e,KAAK/Z,MAAQ+Z,KAAK4e,IAAIx6B,GAAO,EAAI,EACjC26B,EAAK36B,GAAQo6B,SAA0BpC,IAAVh5B,EAAuBy7B,GAAiBz7B,EAC9D4c,KAGT,UCTA,SAASkf,GAAKp5B,GACZ,IAAInC,GAAS,EACTC,EAAoB,MAAXkC,EAAkB,EAAIA,EAAQlC,OAE3Coc,KAAK/c,QACL,QAASU,EAAQC,EAAQ,CACvB,IAAIu7B,EAAQr5B,EAAQnC,GACpBqc,KAAKof,IAAID,EAAM,GAAIA,EAAM,KAK7BD,GAAK59B,UAAU2B,MAAQw7B,GACvBS,GAAK59B,UAAU,UAAYq9B,GAC3BO,GAAK59B,UAAU+9B,IAAMP,GACrBI,GAAK59B,UAAUs9B,IAAMI,GACrBE,GAAK59B,UAAU89B,IAAMH,GAErB,UCxBA,SAASK,KACPtf,KAAK0e,SAAW,GAChB1e,KAAK/Z,KAAO,EAGd,UCoBA,SAASs5B,GAAGn8B,EAAOo8B,GACjB,OAAOp8B,IAAUo8B,GAAUp8B,IAAUA,GAASo8B,IAAUA,EAG1D,UC1BA,SAASC,GAAaC,EAAOt7B,GAC3B,IAAIR,EAAS87B,EAAM97B,OACnB,MAAOA,IACL,GAAI27B,GAAGG,EAAM97B,GAAQ,GAAIQ,GACvB,OAAOR,EAGX,OAAQ,EAGV,UCjBI+7B,GAAa56B,MAAMzD,UAGnB02B,GAAS2H,GAAW3H,OAWxB,SAAS4H,GAAgBx7B,GACvB,IAAI26B,EAAO/e,KAAK0e,SACZ/6B,EAAQ87B,GAAaV,EAAM36B,GAE/B,GAAIT,EAAQ,EACV,OAAO,EAET,IAAIk8B,EAAYd,EAAKn7B,OAAS,EAO9B,OANID,GAASk8B,EACXd,EAAKe,MAEL9H,GAAOvZ,KAAKsgB,EAAMp7B,EAAO,KAEzBqc,KAAK/Z,MACA,EAGT,UCvBA,SAAS85B,GAAa37B,GACpB,IAAI26B,EAAO/e,KAAK0e,SACZ/6B,EAAQ87B,GAAaV,EAAM36B,GAE/B,OAAOT,EAAQ,OAAIy4B,EAAY2C,EAAKp7B,GAAO,GAG7C,UCPA,SAASq8B,GAAa57B,GACpB,OAAOq7B,GAAazf,KAAK0e,SAAUt6B,IAAQ,EAG7C,UCHA,SAAS67B,GAAa77B,EAAKhB,GACzB,IAAI27B,EAAO/e,KAAK0e,SACZ/6B,EAAQ87B,GAAaV,EAAM36B,GAQ/B,OANIT,EAAQ,KACRqc,KAAK/Z,KACP84B,EAAK75B,KAAK,CAACd,EAAKhB,KAEhB27B,EAAKp7B,GAAO,GAAKP,EAEZ4c,KAGT,UCZA,SAASkgB,GAAUp6B,GACjB,IAAInC,GAAS,EACTC,EAAoB,MAAXkC,EAAkB,EAAIA,EAAQlC,OAE3Coc,KAAK/c,QACL,QAASU,EAAQC,EAAQ,CACvB,IAAIu7B,EAAQr5B,EAAQnC,GACpBqc,KAAKof,IAAID,EAAM,GAAIA,EAAM,KAK7Be,GAAU5+B,UAAU2B,MAAQq8B,GAC5BY,GAAU5+B,UAAU,UAAYs+B,GAChCM,GAAU5+B,UAAU+9B,IAAMU,GAC1BG,GAAU5+B,UAAUs9B,IAAMoB,GAC1BE,GAAU5+B,UAAU89B,IAAMa,GAE1B,UC3BIE,GAAM5B,GAAUvC,GAAM,OAE1B,MCKA,SAASoE,KACPpgB,KAAK/Z,KAAO,EACZ+Z,KAAK0e,SAAW,CACd,KAAQ,IAAIQ,GACZ,IAAO,IAAKiB,IAAOD,IACnB,OAAU,IAAIhB,IAIlB,UCbA,SAASmB,GAAUj9B,GACjB,IAAIsB,SAActB,EAClB,MAAgB,UAARsB,GAA4B,UAARA,GAA4B,UAARA,GAA4B,WAARA,EACrD,cAAVtB,EACU,OAAVA,EAGP,UCJA,SAASk9B,GAAWh7B,EAAKlB,GACvB,IAAI26B,EAAOz5B,EAAIo5B,SACf,OAAO2B,GAAUj8B,GACb26B,EAAmB,iBAAP36B,EAAkB,SAAW,QACzC26B,EAAKz5B,IAGX,UCNA,SAASi7B,GAAen8B,GACtB,IAAIP,EAASy8B,GAAWtgB,KAAM5b,GAAK,UAAUA,GAE7C,OADA4b,KAAK/Z,MAAQpC,EAAS,EAAI,EACnBA,EAGT,UCNA,SAAS28B,GAAYp8B,GACnB,OAAOk8B,GAAWtgB,KAAM5b,GAAKi7B,IAAIj7B,GAGnC,UCJA,SAASq8B,GAAYr8B,GACnB,OAAOk8B,GAAWtgB,KAAM5b,GAAKw6B,IAAIx6B,GAGnC,UCHA,SAASs8B,GAAYt8B,EAAKhB,GACxB,IAAI27B,EAAOuB,GAAWtgB,KAAM5b,GACxB6B,EAAO84B,EAAK94B,KAIhB,OAFA84B,EAAKK,IAAIh7B,EAAKhB,GACd4c,KAAK/Z,MAAQ84B,EAAK94B,MAAQA,EAAO,EAAI,EAC9B+Z,KAGT,UCRA,SAAS2gB,GAAS76B,GAChB,IAAInC,GAAS,EACTC,EAAoB,MAAXkC,EAAkB,EAAIA,EAAQlC,OAE3Coc,KAAK/c,QACL,QAASU,EAAQC,EAAQ,CACvB,IAAIu7B,EAAQr5B,EAAQnC,GACpBqc,KAAKof,IAAID,EAAM,GAAIA,EAAM,KAK7BwB,GAASr/B,UAAU2B,MAAQm9B,GAC3BO,GAASr/B,UAAU,UAAYi/B,GAC/BI,GAASr/B,UAAU+9B,IAAMmB,GACzBG,GAASr/B,UAAUs9B,IAAM6B,GACzBE,GAASr/B,UAAU89B,IAAMsB,GAEzB,UC5BIE,GAAkB,sBA8CtB,SAASC,GAAQjD,EAAMkD,GACrB,GAAmB,mBAARlD,GAAmC,MAAZkD,GAAuC,mBAAZA,EAC3D,MAAM,IAAIC,UAAUH,IAEtB,IAAII,EAAW,WACb,IAAI19B,EAAO29B,UACP78B,EAAM08B,EAAWA,EAASI,MAAMlhB,KAAM1c,GAAQA,EAAK,GACnD69B,EAAQH,EAASG,MAErB,GAAIA,EAAMvC,IAAIx6B,GACZ,OAAO+8B,EAAM9B,IAAIj7B,GAEnB,IAAIP,EAAS+5B,EAAKsD,MAAMlhB,KAAM1c,GAE9B,OADA09B,EAASG,MAAQA,EAAM/B,IAAIh7B,EAAKP,IAAWs9B,EACpCt9B,GAGT,OADAm9B,EAASG,MAAQ,IAAKN,GAAQO,OAAST,IAChCK,EAITH,GAAQO,MAAQT,GAEhB,UCrEIU,GAAmB,IAUvB,SAASC,GAAc1D,GACrB,IAAI/5B,EAASg9B,GAAQjD,GAAM,SAASx5B,GAIlC,OAHI+8B,EAAMl7B,OAASo7B,IACjBF,EAAMl+B,QAEDmB,KAGL+8B,EAAQt9B,EAAOs9B,MACnB,OAAOt9B,EAGT,UCtBI09B,GAAa,mGAGbC,GAAe,WASfC,GAAeH,IAAc,SAASI,GACxC,IAAI79B,EAAS,GAOb,OAN6B,KAAzB69B,EAAOC,WAAW,IACpB99B,EAAOqB,KAAK,IAEdw8B,EAAOvD,QAAQoD,IAAY,SAAS3hB,EAAOgiB,EAAQC,EAAOC,GACxDj+B,EAAOqB,KAAK28B,EAAQC,EAAU3D,QAAQqD,GAAc,MAASI,GAAUhiB,MAElE/b,KAGT,MCjBA,SAASk+B,GAASrC,EAAOsC,GACvB,IAAIr+B,GAAS,EACTC,EAAkB,MAAT87B,EAAgB,EAAIA,EAAM97B,OACnCC,EAASkB,MAAMnB,GAEnB,QAASD,EAAQC,EACfC,EAAOF,GAASq+B,EAAStC,EAAM/7B,GAAQA,EAAO+7B,GAEhD,OAAO77B,EAGT,UCdIo+B,GAAW,IAGXC,GAAcl+B,GAASA,GAAAA,eAAmBo4B,EAC1C+F,GAAiBD,GAAcA,GAAYhgC,cAAWk6B,EAU1D,SAASgG,GAAah/B,GAEpB,GAAoB,iBAATA,EACT,OAAOA,EAET,GAAIy4B,GAAQz4B,GAEV,OAAO2+B,GAAS3+B,EAAOg/B,IAAgB,GAEzC,GAAIrF,GAAS35B,GACX,OAAO++B,GAAiBA,GAAe1jB,KAAKrb,GAAS,GAEvD,IAAIS,EAAUT,EAAQ,GACtB,MAAkB,KAAVS,GAAkB,EAAIT,IAAW6+B,GAAY,KAAOp+B,EAG9D,UCbA,SAAS3B,GAASkB,GAChB,OAAgB,MAATA,EAAgB,GAAKg/B,GAAah/B,GAG3C,UCdA,SAASi/B,GAASj/B,EAAOwG,GACvB,OAAIiyB,GAAQz4B,GACHA,EAEF85B,GAAM95B,EAAOwG,GAAU,CAACxG,GAASq+B,GAAav/B,GAASkB,IAGhE,UCjBI6+B,GAAW,IASf,SAASK,GAAMl/B,GACb,GAAoB,iBAATA,GAAqB25B,GAAS35B,GACvC,OAAOA,EAET,IAAIS,EAAUT,EAAQ,GACtB,MAAkB,KAAVS,GAAkB,EAAIT,IAAW6+B,GAAY,KAAOp+B,EAG9D,UCTA,SAAS0+B,GAAQ34B,EAAQ44B,GACvBA,EAAOH,GAASG,EAAM54B,GAEtB,IAAIjG,EAAQ,EACRC,EAAS4+B,EAAK5+B,OAElB,MAAiB,MAAVgG,GAAkBjG,EAAQC,EAC/BgG,EAASA,EAAO04B,GAAME,EAAK7+B,OAE7B,OAAQA,GAASA,GAASC,EAAUgG,OAASwyB,EAG/C,UCIA,SAASiD,GAAIz1B,EAAQ44B,EAAM/9B,GACzB,IAAIZ,EAAmB,MAAV+F,OAAiBwyB,EAAYmG,GAAQ34B,EAAQ44B,GAC1D,YAAkBpG,IAAXv4B,EAAuBY,EAAeZ,EAG/C,UChCA,GAAe,CACbgD,KAAM,KACN8D,GAAI,CACF83B,YAAa,CACXC,QAAS,KACTz/B,MAAO,QACP0/B,aAAc,eACdC,YAAa,gEAEfC,WAAY,CACVC,IAAK,MACLC,MAAO,QACPC,OAAQ,SACR//B,MAAO,QACPy/B,QAAS,KACTO,gBAAiB,8DACjBC,iBAAkB,mDAClBC,gBAAiB,kDACjBC,aAAc,gBACdC,WAAY,cACZC,WAAY,cACZC,UAAW,aACXC,UAAW,aACXC,QAAS,WACTC,QAAS,WACTC,SAAU,gBACVC,SAAU,YACVC,UAAW,iBACXC,UAAW,aACXC,KAAM,GACNC,OAAQ,UACRC,OAAQ,WACRC,OAAQ,QACRC,OAAQ,QACRC,OAAQ,MACRC,OAAQ,OACRC,OAAQ,OACRC,OAAQ,SACRC,OAAQ,YACRC,QAAS,UACTC,QAAS,WACTC,QAAS,WACTC,KAAM,OACNC,MAAO,CACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,OAEPC,UAAW,CACTP,IAAK,SACLC,IAAK,SACLC,IAAK,UACLC,IAAK,YACLC,IAAK,WACLC,IAAK,SACLC,IAAK,YAEPE,OAAQ,CACNC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,MACLC,IAAK,QAGTC,YAAa,CACXC,SAAU,kBACVC,SAAU,mBAEZ1O,OAAQ,CACN7pB,QAAS,UACTw4B,QAAS,mBACTC,OAAQ,UACRtb,YAAa,UAEfub,SAAU,CACRF,QAAS,mBACTx4B,QAAS,UACTmd,YAAa,SACbsb,OAAQ,WAEVE,WAAY,CACVC,KAAM,QACNC,SAAU,QACVC,MAAO,gBACPC,eAAgB,GAChBC,mBAAoB,gGAEtBC,OAAQ,CACNj4B,MAAO,qBAETk4B,OAAQ,CACNl4B,MAAO,qBAETm4B,WAAY,CACVC,MAAO,UACPxE,QAAS,KACTM,OAAQ,SACR/yB,MAAO,gBACPnB,MAAO,qBAETq4B,OAAQ,CACNC,UAAW,yBACX/T,OAAQ,SACRgU,QAAS,UACTC,SAAU,YAEZC,OAAQ,CACN5E,aAAc,iCACd6E,uBAAwB,mBACxBC,qBAAsB,kBAExBC,MAAO,CACLC,UAAW,UACXC,cAAe,UACfC,YAAa,QACbC,YAAa,MACbC,QAAS,OAEXC,KAAM,CACJL,UAAW,WAEbM,SAAU,CACR3B,QAAS,mBACTC,OAAQ,UACR2B,OAAQ,CAAC,SAAU,UACnBC,kBAAmB,gBACnBC,gBAAiB,gBACjBC,iBAAkB,6BAEpBC,MAAO,CACLr4B,MAAO,UAETs4B,WAAY,CACVrB,MAAO,QAETsB,WAAY,CACVC,kBAAmB,MACnBC,iBAAkB,QCjJZ,MAACC,GAAmBC,GAAW,CAACpG,EAAMr+B,IAAW0kC,GAAUrG,EAAMr+B,GAAQX,EAAAA,EAAAA,IAAMolC,IAC9EC,GAAY,CAACrG,EAAMr+B,EAAQykC,IAAWvJ,GAAIuJ,EAAQpG,EAAMA,GAAMrE,QAAQ,cAAc,CAAC2K,EAAG1kC,KACnG,IAAItC,EACJ,MAAQ,GAAkD,OAA/CA,EAAe,MAAVqC,OAAiB,EAASA,EAAOC,IAAgBtC,EAAM,IAAGsC,UAE/D2kC,GAAsBH,IACjC,MAAMI,GAAOrhC,EAAAA,EAAAA,KAAS,KAAMnE,EAAAA,EAAAA,IAAMolC,GAAQ/hC,OACpCoiC,GAAYC,EAAAA,EAAAA,IAAMN,GAAUA,GAAS7lC,EAAAA,EAAAA,IAAI6lC,GAC/C,MAAO,CACLI,KAAAA,EACAJ,OAAQK,EACRx1B,EAAGk1B,GAAgBC,KAGVO,GAAY,KACvB,MAAMP,EAASrhC,EAAgB,UAC/B,OAAOwhC,IAAmBphC,EAAAA,EAAAA,KAAS,IAAMihC,EAAOxlC,OAASgmC,OClBrDpX,IAASjvB,EAAAA,EAAAA,IAAI,GACNsmC,GAAY,KACvB,MAAMC,EAAgB/hC,EAAgB,SAAU,KAC1CgiC,GAAgB5hC,EAAAA,EAAAA,KAAS,IAAM2hC,EAAclmC,MAAQ4uB,GAAO5uB,QAC5DomC,EAAa,KACjBxX,GAAO5uB,QACAmmC,EAAcnmC,OAEvB,MAAO,CACLkmC,cAAAA,EACAC,cAAAA,EACAC,WAAAA,ICXSC,GAAe,CAACC,EAAWC,EAASC,KAC/C,IAAIC,EAAY,CACdC,QAAS,EACTC,QAAS,GAEX,MAAM1Y,EAAejoB,IACnB,MAAM4gC,EAAQ5gC,EAAE6gC,QACVC,EAAQ9gC,EAAE+gC,SACV,QAAEL,EAAF,QAAWC,GAAYF,EACvBO,EAAaV,EAAUtmC,MAAMinC,wBAC7BC,EAAaF,EAAWzX,KACxB4X,EAAYH,EAAW3X,IACvB+X,EAAcJ,EAAW9Z,MACzBma,EAAeL,EAAWlf,OAC1Bwf,EAAcp/B,SAASq/B,gBAAgBD,YACvCE,EAAet/B,SAASq/B,gBAAgBC,aACxCC,GAAWP,EAAaR,EACxBgB,GAAUP,EAAYR,EACtBgB,EAAUL,EAAcJ,EAAaE,EAAcV,EACnDkB,EAASJ,EAAeL,EAAYE,EAAeV,EACnDkB,EAAeC,IACnB,MAAMC,EAAQj5B,KAAKC,IAAID,KAAKJ,IAAIg4B,EAAUoB,EAAGjB,QAAUD,EAAOa,GAAUE,GAClEK,EAAQl5B,KAAKC,IAAID,KAAKJ,IAAIi4B,EAAUmB,EAAGf,QAAUD,EAAOY,GAASE,GACvEnB,EAAY,CACVC,QAASqB,EACTpB,QAASqB,GAEX1B,EAAUtmC,MAAMiI,MAAMw+B,UAAa,aAAYp+B,GAAQ0/B,OAAW1/B,GAAQ2/B,OAEtE9Z,EAAY,KAChBhmB,SAASmd,oBAAoB,YAAawiB,GAC1C3/B,SAASmd,oBAAoB,UAAW6I,IAE1ChmB,SAASkd,iBAAiB,YAAayiB,GACvC3/B,SAASkd,iBAAiB,UAAW8I,IAEjC+Z,EAAc,KACd1B,EAAQvmC,OAASsmC,EAAUtmC,OAC7BumC,EAAQvmC,MAAMolB,iBAAiB,YAAa6I,IAG1Cia,EAAe,KACf3B,EAAQvmC,OAASsmC,EAAUtmC,OAC7BumC,EAAQvmC,MAAMqlB,oBAAoB,YAAa4I,KAGnD3K,EAAAA,EAAAA,KAAU,MACR6kB,EAAAA,EAAAA,KAAY,KACN3B,EAAUxmC,MACZioC,IAEAC,WAIN/R,EAAAA,EAAAA,KAAgB,KACd+R,QChCJ,IAAIE,GACQ,MAACC,GAAoB,KAC/B,IAAI3pC,EACJ,IAAKC,EACH,OAAO,EACT,QAAuB,IAAnBypC,GACF,OAAOA,GACT,MAAME,EAAQpgC,SAASuf,cAAc,OACrC6gB,EAAMC,UAAY,qBAClBD,EAAMrgC,MAAMwrB,WAAa,SACzB6U,EAAMrgC,MAAMilB,MAAQ,QACpBob,EAAMrgC,MAAMmnB,SAAW,WACvBkZ,EAAMrgC,MAAMonB,IAAM,UAClBnnB,SAASwf,KAAKC,YAAY2gB,GAC1B,MAAME,EAAgBF,EAAMG,YAC5BH,EAAMrgC,MAAMygC,SAAW,SACvB,MAAMC,EAAQzgC,SAASuf,cAAc,OACrCkhB,EAAM1gC,MAAMilB,MAAQ,OACpBob,EAAM3gB,YAAYghB,GAClB,MAAMC,EAAkBD,EAAMF,YAG9B,OAF2B,OAA1B/pC,EAAK4pC,EAAMngB,aAA+BzpB,EAAG0pB,YAAYkgB,GAC1DF,GAAiBI,EAAgBI,EAC1BR,ICtCG,MAACS,GAAiBC,IAI5B,IAHKhD,EAAAA,EAAAA,IAAMgD,IACTplC,EAAW,kBAAmB,kDAE3B/E,GAAY2I,GAASY,SAASwf,KAAM,2BACvC,OAEF,IAAI0gB,EAAiB,EACjBW,GAAqB,EACrBC,EAAmB,IACnBC,EAA2B,EAC/B,MAAM/jB,EAAU,KACdtd,GAAYM,SAASwf,KAAM,2BACvBqhB,IACF7gC,SAASwf,KAAKzf,MAAMihC,aAAeF,KAGvC/mB,EAAAA,EAAAA,IAAM6mB,GAAU/pC,IACd,IAAKA,EAEH,YADAmmB,IAGF6jB,GAAsBzhC,GAASY,SAASwf,KAAM,2BAC1CqhB,IACFC,EAAmB9gC,SAASwf,KAAKzf,MAAMihC,aACvCD,EAA2BnmC,OAAOmM,SAASnH,GAASI,SAASwf,KAAM,gBAAiB,KAEtF0gB,EAAiBC,KACjB,MAAMc,EAAkBjhC,SAASq/B,gBAAgBC,aAAet/B,SAASwf,KAAKK,aACxEqhB,EAAgBthC,GAASI,SAASwf,KAAM,aAC1C0gB,EAAiB,IAAMe,GAAqC,WAAlBC,IAA+BL,IAC3E7gC,SAASwf,KAAKzf,MAAMihC,aAAgB,GAAED,EAA2Bb,OAEnE1gC,GAASQ,SAASwf,KAAM,+BAE1BlpB,EAAAA,EAAAA,KAAe,IAAM0mB,OC5CVmkB,GAAmB,CAACC,EAAQC,KACvC,IAAIC,GACJvnB,EAAAA,EAAAA,KAAM,IAAMqnB,EAAOtpC,QAAQjB,IACzB,IAAIL,EAAI8F,EACJzF,GACFyqC,EAAiBthC,SAAS2pB,eACtBiU,EAAAA,EAAAA,IAAMyD,KACkC,OAAzC/kC,GAAM9F,EAAK6qC,EAAavpC,OAAO2pB,QAA0BnlB,EAAG6W,KAAK3c,KAMlE8qC,EAAe7f,YCmLlBpgB,IAAaC,EAAAA,EAAAA,IAAa,CAC7B/F,KAAM,eACNgmC,WAAY,CACVvX,UAASA,IAEXwX,WAAY,CACVnlB,SADU,GAEVolB,YAFU,GAGV/b,QAHU,GAIV4B,UAJU,GAKVpmB,OALU,MAMPgD,IAELgqB,cAAc,EACd3zB,MAAO,CACLmnC,WAAY,CACVtoC,KAAMyB,OACNxB,UAAWi3B,IAEbqR,MAAO,CACLvoC,KAAMiM,QACNnM,SAAS,GAEX0oC,WAAY,CACVxoC,KAAMiM,QACNnM,SAAS,GAEX2oC,UAAW,CACTzoC,KAAMiM,QACNnM,SAAS,GAEX4oC,kBAAmB,CACjB1oC,KAAMiM,QACNnM,SAAS,GAEX6oC,mBAAoB,CAClB3oC,KAAMiM,QACNnM,SAAS,GAEX8oC,kBAAmB,CACjB5oC,KAAMiM,QACNnM,SAAS,GAEX+oC,OAAQ58B,QACRi5B,UAAWj5B,QACX68B,YAAa,CACXhpC,SAAS,EACTE,KAAMiM,SAERgmB,UAAW,CACTjyB,KAAMyB,OACN3B,QAAS,QAEXipC,QAAS,CACP/oC,KAAMyB,OACN3B,QAAS,KAGb0tB,MAAO,CAAC,SAAU,UAClBC,MAAMtsB,GAAO,KAAE0hB,IAEP,QAAE9T,GAAM01B,KACRx9B,EAAKxC,GAAa,eAClBukC,GAAU3qC,EAAAA,EAAAA,KAAI,IACd,WAAEymC,GAAeH,KAEjB3/B,GAAQge,EAAAA,EAAAA,IAA0B,CACtCimB,YAAa,KACbrkB,SAAU,KACVof,iBAAkB,GAClBkF,kBAAmB,GACnBnF,kBAAmB,GACnBoF,mBAAoB,GACpBC,YAAa,GACbC,YAAa,GACbC,0BAA0B,EAC1BC,2BAA2B,EAC3Br9B,KAAM,GACNs9B,aAAc,KACdC,iBAAkB,GAClBC,UAAW,OACXC,WAAY,KACZC,eAAgB,KAChBC,kBAAmB,GACnBtnC,QAAS,KACTunC,WAAW,EACXC,WAAY,GACZC,kBAAkB,EAClBC,mBAAmB,EACnBjqC,KAAM,GACNwiC,WAAO,EACP0H,WAAW,EACXC,OAAQ,GACRC,sBAAsB,EACtBC,qBAAqB,EACrBC,uBAAuB,EACvBC,mBAAoB,GAIpBC,eAAe,EACfld,OAAQwX,MAGJ2F,GAAYxnC,EAAAA,EAAAA,KAAS,KACzB,MAAMjD,EAAOgF,EAAMhF,KACZ,QAAGiH,EAAGpC,GAAG,OAAQ7E,IAAQA,GAAQoL,GAAkBpL,OAGtD0qC,EAAYxpB,KACZS,EAAUT,KAEVypB,EAAU/gC,IACd3G,EAAAA,EAAAA,KAAU,IAAK9B,EAAMmnC,aACrB,CAAErnC,MAAM,EAAM+I,MAAM,EAAMC,UAAU,IAGhC2gC,GAAgB3nC,EAAAA,EAAAA,KACpB,IAAM+B,EAAMkH,MAAQd,GAAkBpG,EAAMhF,OAAS,KAEjD6qC,GAAa5nC,EAAAA,EAAAA,KAAU,MAAO+B,EAAMzC,UACpCuoC,GAAUzsC,EAAAA,EAAAA,MACV0sC,GAAY1sC,EAAAA,EAAAA,MACZ2sC,GAAgB3sC,EAAAA,EAAAA,MAChB4sC,GAAW5sC,EAAAA,EAAAA,MACX6sC,GAAa7sC,EAAAA,EAAAA,MAEb8sC,GAAuB,SAAS,IAAMnmC,EAAMmkC,sBAElDxoB,EAAAA,EAAAA,KACE,IAAM3b,EAAM2kC,aACZyB,MAAAA,UACQlf,EAAAA,EAAAA,MACgB,WAAlB/qB,EAAM4nC,SAAgC,OAARtrC,GACvB4tC,MAGb,CAAEltC,WAAW,KAGfwiB,EAAAA,EAAAA,KACE,IAAMqoB,EAAQtqC,QACbjB,IACC,IAAIL,EAAK8F,EACH,IACoB,UAAtB,WAAuD,YAAjC/B,EAAkB,UAC1C6pC,EAAAA,MAAAA,OAAAA,EAAAA,OAAAA,EAAAA,EAAAA,YAAAA,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,OAEFhmC,EAAAA,OAAAA,KACgC,uBAErB,GACPknB,EAAAA,EAAAA,MAAa,WACG,MAChB,uBACD8e,EAAAA,MAAAA,OAAAA,EAAAA,KAAAA,EAAAA,EAAAA,WAIHhmC,EAAAA,mBAAAA,GAEJA,EAAAA,eAAAA,OAKA,SAAsB,2BAcA,aACpBgkC,EAAgB,QAEdA,EAAU,UAAa9c,EAAAA,EAAAA,KAAAA,KACxB,UACHrJ,EAAAA,SAAAA,EAAAA,YAlBEkiB,GAAe,QACf/iB,EAAAA,EAAAA,KAAAA,gBACK,UACL,qBACD6N,GAAAA,OAAAA,aAAAA,OAIOgF,EAAAA,EAAAA,KAAQ,KACd,qBACD7E,GAAAA,OAAAA,aAAAA,MAYgB,QAAkC,KACjD,qBACFsb,EAAAA,EAAAA,0BAAAA,QAAAA,WAKM,KAAgC,GAChCC,EAAe,IACjB,GAA6B,aAA7B,EAAO,UAEX,OADE7mC,EAAAA,iBACF,cAII,MACF,OAEe,WAAf,EAAe,SAAAylC,YAAAA,GAAA,OAIfnlC,EAAO,OAAAmlC,EACG,cACV,yCAGFqB,MAGI,OACE,GACE,WADF,EAAMzC,QACJ,CACF,QAAsB,eACf,gCAGL,OAFJ/jC,EAAAA,mBAAAA,EAAAA,mBAAAA,EAAAA,uBACAA,EAAAA,eAA6B,GACzB,EAEF,MAAI4kC,EAAAA,EAA0B,eAC5B,GACE,oBAAAA,EAA2B,CAC7B,QAAsB,gBACf,UAGP,OAFF5kC,EAAAA,mBAAAA,EAAAA,mBAAAA,EAAAA,uBACIA,EAAAA,eAAAA,GACyB,EAEpB,uBAGb,OAFIA,EAAAA,mBAAAA,EACFA,EAAAA,eAAAA,GACF,GAOM,OAHRA,EAAAA,mBAAAA,GAEAA,EAAAA,eAAwB,GAChB,GAER,OAEA,MAAM,EAAcimC,EAAM,MAAAQ,MACxB,SAAoB,OAAAC,EAAAA,UAShBC,EAAAA,KACJL,EAA8B,UAE9B,OACF,sBAGIK,KAUF,OALF,cAEOpE,GAAAA,GAELQ,GAAAA,GACA,KACA,WACA9gC,GAAAA,EACA2kC,aAAAA,EACA5C,QAAAA,EACA6B,WAAAA,EACAJ,UAAAA,EACAC,UAAAA,EACA/oB,QAAAA,EACAgpB,QAAAA,EACAC,cAAAA,EACAO,qBAAAA,EACAL,QAAAA,EACAE,cAAAA,EACAD,UAAAA,EACAE,SAAAA,EACAC,WAAAA,EACAM,QAAAA,EACAG,YAAAA,EACAE,iBAAAA,EACAC,mBAAAA,EACFP,iBAAAA,EACFD,aAAAA,EACDv8B,EAAAA,M,oKA5Vc,qBAjJIg9B,GAAAA,EAAAA,EAAAA,IAAAA,iBAAkB,yBAAkB,0BAAC,M,sBAgJvCC,aAAAA,EAAAA,MAAAA,EAAAA,IAAAA,GAAAA,EAAAA,MAAAA,YAAA,CA7IDlsC,SACI,aAAM,EAA6BmsC,EAAAA,EAAAA,KAC1C,8B,iBAEPrjC,EAwIM,GAAA7D,GAAA,eAAA6D,EAAAA,YAAAukB,KAAAA,EAAAA,OAAA,CAvICrtB,SACQ,sBACF,OACVosC,KAAAA,SACA,aAAKtjC,EAAAA,MACL,aAAK,OACL,mBAAS,iBAAe,EAAf,YACTglB,OAAO,uDAAwBlB,QAAAA,EAAAA,KAAAA,EAAAA,GAAAA,IAAAA,IAAAA,EAAAA,aAAAA,SAAAA,EAAAA,aAAAA,WAAAA,IAEhCC,YA6HgB,kFA5HdC,UAAAA,EAAAA,MAAAA,EAAAA,IAAAA,IAAAA,IAAAA,EAAAA,aAAAA,WAAAA,EAAAA,aAAAA,aAAAA,KAAA,EACUuf,EAAAA,EAAAA,IACM,GACfpX,KAAgB,GAChBC,QAAmB,oC,iBAEpBpsB,EAqHM,cAAAwjC,mBAAAA,EAAAA,kBAAA,CApHAtsC,SACE,sBAAsB,OAAkBzB,IAAAA,UAA2BuvB,OAAAA,EAAAA,EAAAA,IAAK,CAA2ChlB,EAAAA,GAAAA,IAAuBA,EAAAA,YAM/IA,EAAK3B,GAAAlC,GAAA,YAAa6D,EAAAA,WACV,gCACKjC,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,aAAAohB,SAAAA,KAGN2E,QAAK,OAAa7jB,EAAU,IAAAwjC,EAAAA,EAAAA,KAAAA,QA6B9B,YAxCsB,CAalB,OAAPzjC,EAAAA,YAAW,IAAJA,EAAAA,QAAI0jC,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAAC,MAADA,CAAA5sC,IAAAA,EAEZrB,IAQM,YARAuvB,OAAAA,EAAAA,EAAAA,IAAO,EAAA3mB,GAAA,EAAG,YAAC,EAEPslC,EAAAA,EAAAA,GAAAA,MAAAA,CAIE3e,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,WAHP,CAAiChlB,EAAAA,eAAAA,EAAAA,SAAAA,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,C,MAElCglB,OAAAA,EAAAA,EAAAA,IAAAA,CAAAA,EAAAA,GAAAA,EAAAA,UAAAA,EAAAA,aAA6B,C,2EAEjBwW,EAAAA,GAGR,eAAAoI,EAAAA,EAAAA,IAcC,YAAAD,EAAAA,EAAAA,GAAAA,OAAAA,MAAAA,EAAAA,EAAAA,IAAAA,EAAAA,OAAAA,IAbF,GACJ3jC,EAAAA,YAAO0jC,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAAK,SAAD,CACX5sC,IAAAA,EACAM,KAAAA,SAGA4tB,OAAAA,EAAAA,EAAAA,IAA0C,qB,wCAI3ClB,QAEU,6EAFA8I,UAAO3sB,EAAAA,KAAAA,EAAAA,IAAI4jC,EAAAA,EAAAA,KAACA,EAAAA,EAAAA,KAAAA,GAAAA,EAAAA,aAAAA,EAAAA,0BAAAA,QAAAA,WAAAA,CAAAA,YAAAA,CAAAA,YAAD,YACV,CAAA7e,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,WAAA,C,2CAkDT,cA9CI,GAAAtlB,MAAAkkC,EAAAA,EAAAA,IAAAA,QAAAA,IAAY,KAAKA,EAAAA,EAAAA,IAAE,QAAI,IAAAD,EAAAA,EAAAA,GAAC,MAADA,CAC/BrqB,GAwBM,YAxBA0L,OAAAA,EAAAA,EAAAA,IAAO,EAAA3mB,GAAA,EAAG,aAAC,SAEM,MAAe,CAI1B2mB,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,eAHP,CAAiChlB,EAAAA,gBAAAA,EAAAA,QAAAA,EAAAA,aAAAA,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,C,MAElCglB,OAAAA,EAAAA,EAAAA,IAAAA,CAAAA,EAAAA,GAAAA,EAAAA,UAAAA,EAAAA,aAA6B,C,2EAkBzBwW,EAAAA,GAhBuB,eAAAoI,EAAAA,EAAAA,IAAO,QAAD,GAAA5jC,EAAAA,aAAAA,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,IAAC,MAADA,CACjClJ,IAAAA,EAGWkuB,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,aADO,EAEboJ,EAAAA,EAAAA,IAAAA,EAAAA,OAAAA,UAA2B,sCAQpBsV,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,IAAAA,EAAAA,UAAAA,QAAAA,KAAAA,CAAA5sC,IAAAA,E,sDAAA,+BARoB,sD,MAEkBgtC,IAAAA,EAAAA,UAAAA,EAAAA,aAA1C,GAAkC,C,wBAExCC,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,IAAAA,EAAAA,yBACgB,GAAT/jC,EAAS,eAEbw7B,EAAAA,GACO,gBAKS,KAAOoI,EAAAA,EAAAA,IAAAA,QAAI,QAzBnB,SAmCb,cAAA5e,OARK,4BAEIue,EAAAA,EAAAA,IAAAA,EAAAA,CAAUjqB,GAAAA,EAAAA,QAClB7jB,IAAM,WACN6oB,WAAa,aACb,sBAAcre,EAAAA,KAAAA,EAAAA,GAAAA,GAAAA,EAAAA,WAAAA,GACd7I,KAAAA,EAAAA,UACAumB,YAAO,mBAAwB,+BAS5BqH,OAAAA,EAAAA,EAAAA,IAAAA,CAAAgf,QAAAA,EAAAA,gBANHpX,WAAO,2BAAI,YACN,qFAAA+W,EAAAA,EAAAA,GAAwD,OAAA3e,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,a,eAIzC,CAAAuE,WAAAA,EAAAA,mBAAAA,UAAAA,aAjBH0a,EAAAA,EAAAA,IAAAA,EAAAA,oBAAA,IAUlB,IAqCA,sBA1BW,GAAAnkC,KAEP6jC,EAAAA,EAAAA,GAAAA,MAAAA,CASI3e,OAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,UATJ,CAELhlB,EAAAA,mBAAAA,EAAAA,EAAAA,OAAyB,WACzBlJ,IAAO,EACP0J,QAAM,sBACNwkB,OAAAA,EAAAA,EAAAA,IAAAA,CAAAA,EAAAA,oBACAlhB,MAAAA,EAAQ,YAA2BnL,KAAAA,EAAAA,Q,eAEesH,EAAAA,GAAAA,GAAAA,EAAAA,aAAAA,WAAA2sB,UAAAA,EAAAA,KAAAA,EAAAA,IAAAA,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,KAA3BsX,GAAAA,EAAAA,aAAAA,WAAA,2B,gGAIxB1I,EAAI,GACC,wCAAAoI,EAAAA,EAAAA,IAAAA,QAAAA,IAAAA,EAAAA,EAAAA,KACK,WACTnuC,IAAAA,aACA2B,KAAO,UACPoJ,QAAU,uBACVwkB,OAAM,kCACNlhB,MAAAA,EAAAA,YACAvC,SAAAA,EAAAA,sBAAmC5I,KAAAA,EAAAA,Q,eAEiBsH,EAAAA,GAAAA,GAAAA,EAAAA,aAAAA,YAAA2sB,UAAAA,EAAAA,KAAAA,EAAAA,IAAAA,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,KAA5BsX,GAAAlkC,EAAAA,aAAAA,YAAA,2B,kGAXAw7B,EAAAA,GAGf,gFAdJ,IA1FkB,M,KANd,sEAVP,UAREA,EAAAA,GAGR,6D,0ICIb,MAAM2I,GAAkC,IAAItR,IACtCuR,GAAe,CAAC7rC,EAAO8wB,EAAWgb,EAAa,QACnD,MAAMC,GAAQz+B,EAAAA,EAAAA,GAAE0+B,GAAuBhsC,GAIvC,OAHA+rC,EAAMD,WAAaA,GACnBG,EAAAA,EAAAA,IAAOF,EAAOjb,GACdrrB,SAASwf,KAAKC,YAAY4L,EAAUob,mBAC7BH,EAAM1lC,WAET8lC,GAAe,IACZ1mC,SAASuf,cAAc,OAE1BonB,GAAc,CAACrvC,EAAS+uC,KAC5B,MAAMhb,EAAYqb,KAClBpvC,EAAQsvC,SAAW,MACjBJ,EAAAA,EAAAA,IAAO,KAAMnb,GACb8a,GAAgBpe,OAAOrlB,IAEzBpL,EAAQuvC,SAAYtD,IAClB,MAAMuD,EAAaX,GAAgBpS,IAAIrxB,GACvC,IAAIqkC,EAEFA,EADEzvC,EAAQgsC,UACA,CAAExrC,MAAO4K,EAAGqgC,WAAYQ,OAAAA,GAExBA,EAERjsC,EAAQ0mB,SACV1mB,EAAQ0mB,SAAS+oB,EAASpkB,EAAShgB,OAEpB,WAAX4gC,GAAkC,UAAXA,EACrBjsC,EAAQqrC,2BAAwC,WAAXY,EACvCuD,EAAWE,OAAO,SAElBF,EAAWE,OAAO,UAGpBF,EAAWC,QAAQA,IAIzB,MAAMpkB,EAAWyjB,GAAa9uC,EAAS+zB,EAAWgb,GAC5C3jC,EAAKigB,EAAShgB,MACpB,IAAK,MAAMtI,KAAQ/C,GACbqC,EAAAA,EAAAA,IAAOrC,EAAS+C,MAAUV,EAAAA,EAAAA,IAAO+I,EAAGR,OAAQ7H,KAC9CqI,EAAGrI,GAAQ/C,EAAQ+C,IAavB,OAVA0f,EAAAA,EAAAA,KAAM,IAAMrX,EAAG/G,UAAS,CAACsrC,EAAQC,MAC3BC,EAAAA,EAAAA,IAAQF,GACVtkB,EAAS/G,MAAM1iB,QAAU,IAAM,CAAC+tC,IACvBE,EAAAA,EAAAA,IAAQD,MAAYC,EAAAA,EAAAA,IAAQF,WAC9BtkB,EAAS/G,MAAM1iB,UAEvB,CACD3B,WAAW,IAEbmL,EAAG0/B,SAAU,EACN1/B,GAET,SAAS0kC,GAAW9vC,EAAS+uC,EAAa,MACxC,IAAK5vC,EACH,OAAO4wC,QAAQL,SACjB,IAAIhpB,EAQJ,OAPIlnB,EAAAA,EAAAA,IAASQ,KAAY6vC,EAAAA,EAAAA,IAAQ7vC,GAC/BA,EAAU,CACRqE,QAASrE,GAGX0mB,EAAW1mB,EAAQ0mB,SAEd,IAAIqpB,SAAQ,CAACN,EAASC,KAC3B,MAAMtkC,EAAKikC,GAAYrvC,EAAuB,MAAd+uC,EAAqBA,EAAae,GAAWtmC,UAC7EqlC,GAAgBrS,IAAIpxB,EAAI,CACtBpL,QAAAA,EACA0mB,SAAAA,EACA+oB,QAAAA,EACAC,OAAAA,OAIN,MAAMM,GAAuB,CAAC,QAAS,UAAW,UAC5CC,GAA2B,CAC/BC,MAAO,CAAEzF,oBAAoB,EAAOD,mBAAmB,GACvD1K,QAAS,CAAEgM,kBAAkB,GAC7BqE,OAAQ,CAAErE,kBAAkB,EAAME,WAAW,IAK/C,SAASoE,GAAkBvF,GACzB,MAAO,CAACxmC,EAASgsC,EAAarwC,EAAS+uC,KACrC,IAAIzK,EASJ,OARI7iC,EAAAA,EAAAA,IAAS4uC,IACXrwC,EAAUqwC,EACV/L,EAAQ,IAERA,EADSj9B,GAAYgpC,GACb,GAEAA,EAEHP,GAAWzxC,OAAOiyC,OAAO,CAC9BhM,MAAAA,EACAjgC,QAAAA,EACAvC,KAAM,MACHmuC,GAAyBpF,IAC3B7qC,EAAS,CACV6qC,QAAAA,IACEkE,IArBRiB,GAAqBvZ,SAASoU,IAC5BiF,GAAWjF,GAAWuF,GAAkBvF,MAuB1CiF,GAAW5jC,MAAQ,KACjB2iC,GAAgBpY,SAAQ,CAACyP,EAAG96B,KAC1BA,EAAGkiC,aAELuB,GAAgBxuC,SAElByvC,GAAWtmC,SAAW,KC5HjB,MAAC+mC,GAAcT,GACpBS,GAAYnnC,QAAWlE,IACrBqrC,GAAY/mC,SAAWtE,EAAIsE,SAC3BtE,EAAIN,OAAO6E,iBAAiB+mC,QAAUD,GACtCrrC,EAAIN,OAAO6E,iBAAiBgnC,YAAcF,GAC1CrrC,EAAIN,OAAO6E,iBAAiBinC,OAASH,GAAYL,MACjDhrC,EAAIN,OAAO6E,iBAAiBknC,SAAWJ,GAAYzQ,QACnD56B,EAAIN,OAAO6E,iBAAiBmnC,QAAUL,GAAYJ,QAGxC,MAACU,GAAeN,GCPfO,GAAgB,GAChBC,GAAsB/tC,EAAW,CAC5CguC,KAAM,CACJlvC,KAAMiM,QACNnM,SAAS,GAEXokC,OAAQ,CACNlkC,KAAMqB,EAAe9E,SAEvBgF,KAAM,CACJvB,KAAMyB,OACN7B,OAAQ4J,GACR1J,QAAS,IAEXqvC,OAAQ,CACNnvC,KAAMqB,EAAe9E,SAEvB6yC,qBAAsB,CACpBpvC,KAAMqB,EAAe9E,SAEvB8yC,mBAAoB,CAClBrvC,KAAMiM,QACNnM,SAAS,GAEXyC,QAAS,CACPvC,KAAMqB,EAAe9E,SAEvB+wB,OAAQ,CACNttB,KAAMwB,QAER2C,UAAW,CACTnE,KAAMyB,OACN3B,QAAS,SAGEoI,EAAAA,EAAAA,IAAgB,CAC7B/F,KAAM,mBACNhB,MAAO8tC,GACPxhB,MAAMtsB,GAAO,MAAEqhB,KACb7B,EAAAA,EAAAA,KAAM,IAAMxf,EAAMoB,UAAU9E,IAC1BlB,OAAOiyC,OAAOQ,GAAsB,MAAPvxC,EAAcA,EAAM,MAChD,CAAEU,WAAW,EAAMmxC,MAAM,IAC5B,MAAMxsC,EAASK,EAAoBhC,GACnC,MAAO,KAAM0sB,EAAAA,EAAAA,IAAWrL,EAAO,UAAW,CAAE1f,OAAkB,MAAVA,OAAiB,EAASA,EAAOpE,WC9C7E,MAAC6wC,GAAaruC,EAAW,CACnCxC,MAAO,CACLsB,KAAM,CAACyB,OAAQD,QACf1B,QAAS,IAEXsN,IAAK,CACHpN,KAAMwB,OACN1B,QAAS,IAEX0vC,MAAOvjC,QACPylB,OAAQzlB,QACRjM,KAAM,CACJA,KAAMyB,OACN7B,OAAQ,CAAC,UAAW,UAAW,UAAW,OAAQ,UAClDE,QAAS,Y,iGCePmH,EAAKxC,GAAa,SAElBgrC,GAAU,SAAQ,IACxB,WAEA,sBACA,0BAEA,e,OAGA3sB,EAAAA,CAEA2sB,QAAAA,I,smBCzCY,MAACC,GAAUvoC,GAAYwoC,ICDtBC,GAAe,CAAC,UAAW,OAAQ,UAAW,SAC9CC,GAAe3uC,EAAW,CACrCkoC,YAAa,CACXppC,KAAMyB,OACN3B,QAAS,IAEX+oC,OAAQ,CACN7oC,KAAMiM,QACNnM,SAAS,GAEXwpC,yBAA0B,CACxBtpC,KAAMiM,QACNnM,SAAS,GAEXgwC,SAAU,CACR9vC,KAAMwB,OACN1B,QAAS,KAEXoM,KAAM,CACJlM,KAAM4K,GACN9K,QAAS,IAEXoiB,GAAI,CACFliB,KAAMyB,OACN3B,QAAS,IAEXyC,QAAS,CACPvC,KAAMqB,EAAe,CACnBI,OACAlF,OACAsO,WAEF/K,QAAS,IAEXiwC,QAAS,CACP/vC,KAAMqB,EAAewJ,UACrBhL,UAAU,GAEZ4oC,UAAW,CACTzoC,KAAMiM,QACNnM,SAAS,GAEXE,KAAM,CACJA,KAAMyB,OACN7B,OAAQgwC,GACR9vC,QAAS,QAEXkwC,OAAQ,CACNhwC,KAAMwB,OACN1B,QAAS,IAEXwtB,OAAQ,CACNttB,KAAMwB,OACN1B,QAAS,GAEXmwC,SAAU,CACRjwC,KAAMiM,QACNnM,SAAS,GAEXowC,UAAW,CACTlwC,KAAMwB,OACN1B,QAAS,KAGAqwC,GAAe,CAC1BC,QAAS,KAAM,GCTZnoC,IAAaC,EAAAA,EAAAA,IAAa,CAC7B/F,KAAM,YAENimC,WAAY,CACVsH,QADU,GAEV5nC,OAFU,MAGPgD,IAGL3J,MAAO0uC,GACPriB,MAAO2iB,GAEP1iB,MAAMtsB,GACE,MAAA8F,EAAKxC,GAAa,WAClBukC,GAAU3qC,EAAAA,EAAAA,KAAI,GACdgyC,GAAYhyC,EAAAA,EAAAA,IAChB8C,EAAMnB,KAAuB,UAAfmB,EAAMnB,KAAmB,SAAWmB,EAAMnB,KAAQ,QAElE,IAAIswC,EAEE,MAAA7F,GAAYxnC,EAAAA,EAAAA,KAAS,KACzB,MAAMjD,EAAOmB,EAAMnB,KACZ,QAAGiH,EAAGpC,GAAG,OAAQ7E,IAAQA,GAAQoL,GAAkBpL,OAGtD4qC,GAAgB3nC,EAAAA,EAAAA,KAAS,IACtB9B,EAAM+K,MAAQd,GAAkBjK,EAAMnB,OAAS,KAGlDqpC,GAAcpmC,EAAAA,EAAAA,KAAwB,KAAM,CAChD8qB,IAAK,GAAG5sB,EAAM6uC,WACd1iB,OAAQnsB,EAAMmsB,WAGM,aAChBnsB,EAAM2uC,SAAW,KACfrxC,KAAM6xC,GAAcvyC,GAAa,KAC/BirC,EAAQtqC,OAAa0L,MACxBjJ,EAAM2uC,WAIS,aACRQ,MAAAA,GAAAA,IAGG,aACftH,EAAQtqC,OAAQ,EAGlB,SAASgqB,GAAQ,KAAE2H,IACbA,IAASjC,GAAWM,IAElBsa,EAAQtqC,OACJ0L,IAGGmmC,IAmBR,OAfPvuB,EAAAA,EAAAA,KAAU,KACGuuB,IACXvH,EAAQtqC,OAAQ,MAIhBiiB,EAAAA,EAAAA,KAAC,IAAKxf,EAAM+uC,YACZ,KACaM,IACAD,OAIE9sB,GAAAA,SAAU,UAAWiF,GAE/B,CACLzhB,GAAAA,EACAwjC,UAAAA,EACAG,cAAAA,EACAvB,YAAAA,EACAL,QAAAA,EACAqH,UAAAA,EAEAjmC,MAAAA,EACAomC,WAAAA,EACAD,WAAAA,M,6IA9IJE,EAAAA,EAAAA,IAwCa,MAvCVtuC,KAAMyG,EAAAA,GAAG9E,EAAC,QACV4sC,cAAc,EAAAX,QACd/D,aAAWnjC,EAAAA,KAAAA,EAAAA,GAAAA,GAAED,EAAK,oB,kBAEnB,IAkCM,WAlCN2jC,EAAAA,EAAAA,GAkCM,OAhCHrqB,GAAI,EAAAA,GACJ0L,OAAK,SAAYhlB,EAAAA,GAAG9E,IAAC,EAAe8E,EAAAA,GAAG1G,EAAE0G,EAAAA,OAAQA,EAAAA,OAASA,EAAI,MAAYA,EAAAA,GAAG7D,GAAE,SAAW6D,EAAM,QAAWA,EAAAA,GAAG7D,GAAE,WAAa6D,EAAS,WAAWA,EAAAA,cAOjJjC,OAAKgqC,EAAAA,EAAAA,IAAE/nC,EAAW,aACnBsjC,KAAK,QACJ0E,aAAU/nC,EAAE,KAAAA,EAAAA,GAAAA,IAAAA,IAAAA,EAAAA,YAAAA,EAAAA,cAAAA,IACZgoC,aAAUhoC,EAAE,KAAAA,EAAAA,GAAAA,IAAAA,IAAAA,EAAAA,YAAAA,EAAAA,cAAAA,KAAA,CAGLD,EAAAA,UAAS,IAAAM,EAAAA,EAAAA,OADjBunC,EAAAA,EAAAA,IAKE,GAAA/wC,IAAAA,EAHChB,MAAO,EAAAwxC,UACPlwC,KAAM,EAAAqwC,UACNziB,OAAKkjB,EAAAA,EAAAA,IAAE,EAAA7pC,GAAGvC,EAAC,8CAAA8nC,EAAAA,EAAAA,IAAC,QAADA,GAEC5jC,EAAAA,gBAAAA,EAAAA,EAAAA,OAAf6nC,EAAAA,EAAAA,IAEU,GAAA/wC,IAAAA,EAFqBkuB,OAAKkjB,EAAAA,EAAAA,IAAG,GAAA7pC,GAAGvC,EAAC,QAAUkE,EAAS,c,kBAC5D,IAAiC,GAAjC0jC,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,KAAiCyE,EAAAA,EAAAA,IAAjBnoC,EAAa,oB,KACrB,eAFK,oBAGfouB,EAAAA,EAAAA,IAMOpuB,EAAAA,OAAA,cANP,IAMO,CALKA,EAAAA,2BACEM,EAAAA,EAAAA,OAGZ8nC,EAAAA,EAAAA,IAAsD,MAAAtxC,IAAAA,GAAA,EADtD8sC,EAAAA,EAAAA,IAAAA,yFACAD,EAAAA,EAAAA,GAAsD,KAA3C3e,OAAKkjB,EAAAA,EAAAA,IAAE,EAAA7pC,GAAGvC,EAAC,YAAausC,UAAQ,EAAA1uC,SAAA,QAAA+F,KAAW,SAJ5CY,EAAAA,EAAAA,OAAV8nC,EAAAA,EAAAA,IAEI,KAAAtxC,IAAAA,EAFiCkuB,OAAK,QAAEhlB,EAAAA,GAAGlE,EAAC,cAC3CmoC,EAAAA,EAAAA,IAAAA,EAAAA,SAAO,OAKCjkC,EAAAA,YAAAA,EAAAA,EAAAA,OAAf6nC,EAAAA,EAAAA,IAEU,GAAA/wC,IAAAA,EAFiBkuB,OAAK,QAAEhlB,EAAAA,GAAGlE,EAAC,aAAegoB,SAAK2f,EAAAA,EAAAA,IAAOzjC,EAAK,kB,kBACpE,IAAS,EAATujC,EAAAA,EAAAA,IAAS,M,KACD,yBAFK,oBAGX,cAjCIvjC,EAAO,c,KAkCN,4B,kIC1Bf,MAAMsoC,GAAY,GAClB,IAAIC,GAAO,EACN,MAAC5uC,GAAU,SAASrE,EAAU,GAAIwF,GACrC,IAAKrG,EACH,MAAO,CAAE+M,MAAO,QAClB,GAAI7M,EAASyxC,GAAAA,MAAsBkC,GAAUhyC,QAAU8vC,GAAAA,IACrD,MAAO,CAAE5kC,MAAO,QAElB,KAAK2jC,EAAAA,EAAAA,IAAQ7vC,KAAYyB,EAAAA,EAAAA,IAASzB,IAAYA,EAAQ+xC,YAAalC,EAAAA,EAAAA,IAAQ7vC,EAAQqE,UAAY2uC,GAAUhyC,OAAQ,CAC/G,MAAMkyC,EAASF,GAAUG,MAAMvrC,IAC7B,IAAI1I,EAAI8F,EAAIouC,EACZ,MAAQ,GAA+D,OAA5DpuC,EAA6B,OAAvB9F,EAAK0I,EAAKwD,GAAGnI,YAAiB,EAAS/D,EAAGmF,SAAmBW,EAAK,OAAU,GAA4B,OAAzBouC,EAAKpzC,EAAQqE,SAAmB+uC,EAAK,QAEvI,GAAIF,EAGF,OAFAA,EAAO9nC,GAAG9B,UAAUrG,MAAM+uC,WAAa,EACvCkB,EAAO9nC,GAAG9B,UAAUrG,MAAMnB,MAAmB,MAAX9B,OAAkB,EAASA,EAAQ8B,OAAS,OACvE,CACLoK,MAAO,IAAMd,EAAG9B,UAAU+B,MAAMy/B,SAAU,KAI5CtrC,EAAAA,EAAAA,IAASQ,KAAY6vC,EAAAA,EAAAA,IAAQ7vC,MAC/BA,EAAU,CAAEqE,QAASrE,IAEvB,IAAIqzC,EAAiBrzC,EAAQ8xC,QAAU,GACvCkB,GAAUvc,SAAQ,EAAGrrB,GAAIkoC,MACvB,IAAIp0C,EACJm0C,KAAqC,OAAhBn0C,EAAKo0C,EAAIvrC,SAAc,EAAS7I,EAAGq0C,eAAiB,GAAK,MAEhFF,GAAkB,GAClB,MAAM,WAAEzM,GAAeH,KACjBziB,EAAM,WAAUivB,KAChBO,EAAcxzC,EAAQ6xC,QACtB5uC,EAAQ,CACZmsB,OAAQwX,OACL5mC,EACH8xC,OAAQuB,EACRrvB,GAAAA,EACA6tB,QAAS,KACP3lC,GAAM8X,EAAIwvB,KAGd,IAAIC,EAAW/qC,SAASwf,KACpB5gB,GAAUtH,EAAQyzC,UACpBA,EAAWzzC,EAAQyzC,UACVj0C,EAAAA,EAAAA,IAASQ,EAAQyzC,YAC1BA,EAAW/qC,SAASgrC,cAAc1zC,EAAQyzC,WAEvCnsC,GAAUmsC,KACbrvC,EAAU,YAAa,6EACvBqvC,EAAW/qC,SAASwf,MAEtB,MAAM6L,EAAYrrB,SAASuf,cAAc,OACzC8L,EAAUgV,UAAa,aAAY/kB,IACnC,MAAM2vB,EAAiB1wC,EAAMoB,QACvB+G,GAAKqkB,EAAAA,EAAAA,IAAYmkB,GAAoB3wC,GAAO03B,EAAAA,EAAAA,IAAWgZ,GAAkB,CAAE/xC,QAAS+xC,IAAmB9D,EAAAA,EAAAA,IAAQ8D,GAAkB,CAAE/xC,QAAS,IAAM+xC,GAAmB,MAQ3K,OAPAvoC,EAAG2jC,WAAavpC,GAAWnB,GAAQmF,SACnC4B,EAAGnI,MAAM4wC,UAAY,MACnB3E,EAAAA,EAAAA,IAAO,KAAMnb,KAEfmb,EAAAA,EAAAA,IAAO9jC,EAAI2oB,GACXif,GAAU1wC,KAAK,CAAE8I,GAAAA,IACjBqoC,EAAStrB,YAAY4L,EAAUob,mBACxB,CACLjjC,MAAO,IAAMd,EAAG9B,UAAU+B,MAAMy/B,SAAU,IAgBvC,SAAS5+B,GAAM8X,EAAIwvB,GACxB,MAAMre,EAAM6d,GAAUc,WAAU,EAAG1oC,GAAIkoC,KAAUtvB,IAAOsvB,EAAIhqC,UAAUrG,MAAM+gB,KAC5E,IAAa,IAATmR,EACF,OACF,MAAM,GAAE/pB,GAAO4nC,GAAU7d,GACzB,IAAK/pB,EACH,OACa,MAAfooC,GAA+BA,EAAYpoC,GAC3C,MAAM2oC,EAAgB3oC,EAAGrD,GAAGwrC,aAC5BP,GAAU5d,OAAOD,EAAK,GACtB,MAAM6e,EAAMhB,GAAUhyC,OACtB,KAAIgzC,EAAM,GAEV,IAAK,IAAI9iC,EAAIikB,EAAKjkB,EAAI8iC,EAAK9iC,IAAK,CAC9B,MAAM+iC,EAAM3wC,OAAOmM,SAASujC,GAAU9hC,GAAG9F,GAAGrD,GAAGU,MAAM,OAAQ,IAAMsrC,EAAgB,GACnFf,GAAU9hC,GAAG9F,GAAG9B,UAAUrG,MAAM6uC,OAASmC,GAGtC,SAASC,KACd,IAAIh1C,EACJ,IAAK,IAAIgS,EAAI8hC,GAAUhyC,OAAS,EAAGkQ,GAAK,EAAGA,IAAK,CAC9C,MAAMma,EAAW2nB,GAAU9hC,GAAG9F,GAAG9B,UACoB,OAApDpK,EAAiB,MAAZmsB,OAAmB,EAASA,EAAShgB,QAA0BnM,EAAGgN,SAnC5EwlC,GAAAA,SAAsB5vC,IACpBuC,GAAQvC,GAAQ,CAAC9B,EAAU,GAAI+uC,OACzBvvC,EAAAA,EAAAA,IAASQ,KAAY6vC,EAAAA,EAAAA,IAAQ7vC,MAC/BA,EAAU,CACRqE,QAASrE,IAGNqE,GAAQ,IACVrE,EACH8B,KAAAA,GACCitC,OA4BP1qC,GAAQ6vC,SAAWA,GACnB7vC,GAAQmF,SAAW,KCvHP,MAAC2qC,GAAY5qC,GAAoB6qC,GAAS,YCehDC,GAAeplC,KAAM,QAAa,mBAAoBA,EAAIA,KAAK,UAAeA,GAE9E,GAAa,CACjBygB,MAAO,YAEH,GAAa,CACjBA,MAAO,iBAEH,GAAa,CACjBA,MAAO,gBAGH,GAA0B2kB,IAAa,KAAmB,IAAAnO,GAAoB,KAAM,CACxFxW,MAAO,WACN,EAAc,IAAAwW,GAAoB,OAAQ,CAC3CxW,MAAO,kBACQ,IAAAwW,GAAoB,OAAQ,CAC3CxW,MAAO,gBACN,8BAA+B,KAE5B4kB,GAAa,CACjB5kB,MAAO,WAEH6kB,GAAa,CACjB7kB,MAAO,MAGH8kB,IAA0B,QAAiB,WAE3CC,GAA0BJ,IAAa,KAAmB,IAAAnO,GAAoB,KAAM,CACxFxW,MAAO,eACN,OAAQ,KAELglB,IAA0B,QAAiB,yBAE3CC,GAAc,CAClBjlB,MAAO,MAGHklB,GAA2BP,IAAa,KAAmB,IAAAnO,GAAoB,KAAM,CACzFxW,MAAO,QACN,SAAU,KAEPmlB,GAAc,CAClBnlB,MAAO,gBAGHolB,IAA2B,QAAmB,6fAAogB,GAEljBC,IAA2B,QAAmB,qLAA8L,EAAa,wDAA4D,EAAa,sSAAoT,EAAa,wDAA4D,EAAa,wDAA4D,EAAa,wDAA4D,EAAa,wDAA4D,EAAa,wDAA4D,EAAa,wDAA4D,EAAa,wDAA4D,EAAa,wDAA4D,EAAc,wDAA4D,EAAc,wDAA4D,EAAc,wDAA4D,EAAc,wDAA4D,EAAc,iFAAqF,GAEzkD,GAAc,CAClB9wC,KAAM,OAOR,OAA4B5F,OAAOiyC,OAAO,GAAa,CACrD/gB,MAAMylB,GACJ,MAAMC,GAAQ,UACRC,GAAQ,SACRC,GAAS,UACf,IAAI/0C,EAAQ,IACR,QACFg1C,EAAO,MACPC,EAAK,UACLC,IACE,QAAYJ,GACZK,GAAU,SAAS,IACdN,EAAMO,MAAMD,UAGrB,SAASE,IACP5E,GAAaX,MAAM,aAAamF,EAAM70C,aAAc,CAClD4qC,0BAA0B,EAC1B9G,MAAO,QACPqG,QAAQ,EACRmB,kBAAkB,EAClBvB,WAAW,EACXzE,iBAAkB,UAClBD,kBAAmB,QACnBkF,YAAa,SAAUkB,EAAQ5gB,EAAUqqB,GACxB,WAAXzJ,GACFkI,GAAU,CACR9vC,QAAS,gBACTvC,KAAM,YAER6zC,cAAcv1C,GACdA,EAAQ,KACRs1C,KACoB,YAAXzJ,IACc,KAAnBqJ,EAAU90C,OACZ2zC,GAAU,CACR9vC,QAAS,gBACTvC,KAAM,YAER6zC,cAAcv1C,GACdA,EAAQ,KACRs1C,IACAP,EAAO7yC,KAAK,gBAEZ6xC,GAAU,CACR9vC,QAAS,kBACTvC,KAAM,gBAOX1B,IACHA,EAAQw1C,aAAY1I,UAClB,UACQgI,EAAMW,aAAaN,EAAQ/0C,OAEV,KAAnB80C,EAAU90C,QACZm1C,cAAcv1C,GACdA,EAAQ,KACRywC,GAAa3kC,OAAM,GACnBipC,EAAO7yC,KAAK,gBAEd,MAAO+K,OACR,MAOP,OAHA,SAAU,KACR6nC,EAAMY,WAAWP,EAAQ/0C,UAEpB,CAACkK,EAAMC,KACZ,MAAMorC,EAAqB,IAE3B,OAAO,WAAc,QAAoB,KAAW,KAAM,EAAC,QAAaA,IAAqB,IAAA7P,GAAoB,MAAO,GAAY,EAAC,IAAAA,GAAoB,MAAO,GAAY,EAAC,IAAAA,GAAoB,MAAO,GAAY,CAAC,IAAY,IAAAA,GAAoB,MAAOoO,GAAY,EAAC,IAAApO,GAAoB,OAAQqO,GAAY,CAACC,GAAYC,GAAYC,IAAY,IAAAxO,GAAoB,KAAM,MAAM,SAAiB,QAAOqP,IAAW,MAAM,IAAArP,GAAoB,OAAQyO,GAAa,CAACC,IAAa,IAAA1O,GAAoB,KAAM2O,GAAa,KAAM,SAAiB,QAAOO,GAASY,UAAW,SAAUlB,IAAa,IAAA5O,GAAoB,MAAO,CAC/lBxW,MAAO,kBACN,CAACqlB,IAAa,IAAA7O,GAAoB,MAAO,CAC1CxW,MAAO,UACN,EAAC,IAAAwW,GAAoB,IAAK,CAC3BxW,MAAO,MACPlB,QAASinB,GACR,iBAAkB,Q,SCxJ3B,MAAMQ,IAA2B,QAAgB,GAAQ,CAAC,CAAC,YAAY,qBAEvE","sources":["webpack://shop/./node_modules/@vueuse/shared/index.mjs","webpack://shop/./node_modules/lodash-es/fromPairs.js","webpack://shop/../../../packages/utils/vue/props.ts","webpack://shop/../../../packages/components/icon/src/icon.ts","webpack://shop/../../../internal/build/plugin-vue:export-helper","webpack://shop/../../../packages/tokens/config-provider.ts","webpack://shop/../../../packages/utils/error.ts","webpack://shop/../../../packages/utils/objects.ts","webpack://shop/../../../packages/hooks/use-global-config/index.ts","webpack://shop/../../../packages/hooks/use-namespace/index.ts","webpack://shop/../../../packages/utils/types.ts","webpack://shop/../../../packages/utils/dom/style.ts","webpack://shop/../../../packages/components/icon/src/icon.vue","webpack://shop/../../../packages/utils/vue/install.ts","webpack://shop/../../../packages/components/icon/index.ts","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/_virtual/plugin-vue_export-helper.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/loading.mjs","webpack://shop/../../../packages/hooks/use-prop/index.ts","webpack://shop/../../../packages/constants/size.ts","webpack://shop/../../../packages/tokens/form.ts","webpack://shop/../../../packages/hooks/use-common-props/index.ts","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/close.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/success-filled.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/info-filled.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/warning-filled.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/circle-close-filled.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/circle-check.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/circle-close.mjs","webpack://shop/../../../packages/utils/vue/icon.ts","webpack://shop/../../../packages/components/button/src/button.ts","webpack://shop/./node_modules/@ctrl/tinycolor/dist/module/util.js","webpack://shop/./node_modules/@ctrl/tinycolor/dist/module/conversion.js","webpack://shop/./node_modules/@ctrl/tinycolor/dist/module/css-color-names.js","webpack://shop/./node_modules/@ctrl/tinycolor/dist/module/format-input.js","webpack://shop/./node_modules/@ctrl/tinycolor/dist/module/index.js","webpack://shop/../../../packages/components/button/src/button-custom.ts","webpack://shop/../../../packages/hooks/use-deprecated/index.ts","webpack://shop/../../../packages/tokens/button.ts","webpack://shop/../../../packages/hooks/use-id/index.ts","webpack://shop/../../../packages/hooks/use-form-item/index.ts","webpack://shop/../../../packages/components/button/src/button.vue","webpack://shop/../../../packages/components/button/src/button-group.ts","webpack://shop/../../../packages/components/button/src/button-group.vue","webpack://shop/../../../packages/components/button/index.ts","webpack://shop/./node_modules/@vueuse/core/index.mjs","webpack://shop/./node_modules/lodash-es/isNil.js","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/view.mjs","webpack://shop/./node_modules/@element-plus/icons-vue/dist/es/hide.mjs","webpack://shop/../../../packages/components/input/src/utils.ts","webpack://shop/../../../packages/utils/typescript.ts","webpack://shop/../../../packages/constants/event.ts","webpack://shop/../../../packages/components/input/src/input.ts","webpack://shop/../../../packages/hooks/use-attrs/index.ts","webpack://shop/../../../packages/hooks/use-cursor/index.ts","webpack://shop/../../../packages/utils/i18n.ts","webpack://shop/../../../packages/components/input/src/input.vue","webpack://shop/../../../packages/components/input/index.ts","webpack://shop/../../../packages/hooks/use-same-target/index.ts","webpack://shop/../../../packages/utils/vue/vnode.ts","webpack://shop/../../../packages/components/overlay/src/overlay.ts","webpack://shop/../../../packages/components/overlay/index.ts","webpack://shop/../../../packages/constants/aria.ts","webpack://shop/../../../packages/utils/dom/aria.ts","webpack://shop/../../../packages/utils/dom/event.ts","webpack://shop/../../../packages/directives/trap-focus/index.ts","webpack://shop/../../../packages/components/focus-trap/src/utils.ts","webpack://shop/../../../packages/components/focus-trap/src/tokens.ts","webpack://shop/../../../packages/hooks/use-escape-keydown/index.ts","webpack://shop/../../../packages/components/focus-trap/src/focus-trap.vue","webpack://shop/../../../packages/utils/vue/validator.ts","webpack://shop/./node_modules/lodash-es/isArray.js","webpack://shop/./node_modules/lodash-es/_freeGlobal.js","webpack://shop/./node_modules/lodash-es/_root.js","webpack://shop/./node_modules/lodash-es/_Symbol.js","webpack://shop/./node_modules/lodash-es/_getRawTag.js","webpack://shop/./node_modules/lodash-es/_objectToString.js","webpack://shop/./node_modules/lodash-es/_baseGetTag.js","webpack://shop/./node_modules/lodash-es/isObjectLike.js","webpack://shop/./node_modules/lodash-es/isSymbol.js","webpack://shop/./node_modules/lodash-es/_isKey.js","webpack://shop/./node_modules/lodash-es/isObject.js","webpack://shop/./node_modules/lodash-es/isFunction.js","webpack://shop/./node_modules/lodash-es/_coreJsData.js","webpack://shop/./node_modules/lodash-es/_isMasked.js","webpack://shop/./node_modules/lodash-es/_toSource.js","webpack://shop/./node_modules/lodash-es/_baseIsNative.js","webpack://shop/./node_modules/lodash-es/_getValue.js","webpack://shop/./node_modules/lodash-es/_getNative.js","webpack://shop/./node_modules/lodash-es/_nativeCreate.js","webpack://shop/./node_modules/lodash-es/_hashClear.js","webpack://shop/./node_modules/lodash-es/_hashDelete.js","webpack://shop/./node_modules/lodash-es/_hashGet.js","webpack://shop/./node_modules/lodash-es/_hashHas.js","webpack://shop/./node_modules/lodash-es/_hashSet.js","webpack://shop/./node_modules/lodash-es/_Hash.js","webpack://shop/./node_modules/lodash-es/_listCacheClear.js","webpack://shop/./node_modules/lodash-es/eq.js","webpack://shop/./node_modules/lodash-es/_assocIndexOf.js","webpack://shop/./node_modules/lodash-es/_listCacheDelete.js","webpack://shop/./node_modules/lodash-es/_listCacheGet.js","webpack://shop/./node_modules/lodash-es/_listCacheHas.js","webpack://shop/./node_modules/lodash-es/_listCacheSet.js","webpack://shop/./node_modules/lodash-es/_ListCache.js","webpack://shop/./node_modules/lodash-es/_Map.js","webpack://shop/./node_modules/lodash-es/_mapCacheClear.js","webpack://shop/./node_modules/lodash-es/_isKeyable.js","webpack://shop/./node_modules/lodash-es/_getMapData.js","webpack://shop/./node_modules/lodash-es/_mapCacheDelete.js","webpack://shop/./node_modules/lodash-es/_mapCacheGet.js","webpack://shop/./node_modules/lodash-es/_mapCacheHas.js","webpack://shop/./node_modules/lodash-es/_mapCacheSet.js","webpack://shop/./node_modules/lodash-es/_MapCache.js","webpack://shop/./node_modules/lodash-es/memoize.js","webpack://shop/./node_modules/lodash-es/_memoizeCapped.js","webpack://shop/./node_modules/lodash-es/_stringToPath.js","webpack://shop/./node_modules/lodash-es/_arrayMap.js","webpack://shop/./node_modules/lodash-es/_baseToString.js","webpack://shop/./node_modules/lodash-es/toString.js","webpack://shop/./node_modules/lodash-es/_castPath.js","webpack://shop/./node_modules/lodash-es/_toKey.js","webpack://shop/./node_modules/lodash-es/_baseGet.js","webpack://shop/./node_modules/lodash-es/get.js","webpack://shop/../../../packages/locale/lang/en.ts","webpack://shop/../../../packages/hooks/use-locale/index.ts","webpack://shop/../../../packages/hooks/use-z-index/index.ts","webpack://shop/../../../packages/hooks/use-draggable/index.ts","webpack://shop/../../../packages/utils/dom/scroll.ts","webpack://shop/../../../packages/hooks/use-lockscreen/index.ts","webpack://shop/../../../packages/hooks/use-restore-active/index.ts","webpack://shop/../../../packages/components/message-box/src/index.vue","webpack://shop/../../../packages/components/message-box/src/messageBox.ts","webpack://shop/../../../packages/components/message-box/index.ts","webpack://shop/../../../packages/components/config-provider/src/config-provider.ts","webpack://shop/../../../packages/components/badge/src/badge.ts","webpack://shop/../../../packages/components/badge/src/badge.vue","webpack://shop/../../../packages/components/badge/index.ts","webpack://shop/../../../packages/components/message/src/message.ts","webpack://shop/../../../packages/components/message/src/message.vue","webpack://shop/../../../packages/components/message/src/message-method.ts","webpack://shop/../../../packages/components/message/index.ts","webpack://shop/./src/pages/Pay/index.vue","webpack://shop/./src/pages/Pay/index.vue?e7fa"],"sourcesContent":["import { shallowRef, watchEffect, readonly, ref, watch, customRef, effectScope, provide, inject, getCurrentScope, onScopeDispose, isVue3, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted } from 'vue-demi';\n\nvar __defProp$8 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$5(__spreadValues$8({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  watch(source, () => {\n    dirty.value = true;\n    trigger();\n  }, { flush: \"sync\" });\n  return customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = fn();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set() {\n      }\n    };\n  });\n}\n\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return () => {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    provide(key, composable(...args));\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction __onlyVue3(name = \"this function\") {\n  if (isVue3)\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\n}\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  __onlyVue3();\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction logicAnd(...args) {\n  return computed(() => args.every((i) => unref(i)));\n}\n\nfunction logicNot(v) {\n  return computed(() => !unref(v));\n}\n\nfunction logicOr(...args) {\n  return computed(() => args.some((i) => unref(i)));\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$7({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn) {\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unref(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(keys.map((key) => {\n    const value = obj[key];\n    return [\n      key,\n      typeof value === \"function\" ? reactify(value.bind(obj)) : value\n    ];\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !keys.includes(e[0]))));\n}\n\nfunction reactivePick(obj, ...keys) {\n  return reactive(Object.fromEntries(keys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, unref(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nvar _a;\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    filter(() => fn.apply(this, args), { fn, thisArg: this, args });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  const filter = (invoke) => {\n    const duration = unref(ms);\n    const maxDuration = unref(options.maxWait);\n    if (timer)\n      clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return invoke();\n    }\n    if (maxDuration && !maxTimer) {\n      maxTimer = setTimeout(() => {\n        if (timer)\n          clearTimeout(timer);\n        maxTimer = null;\n        invoke();\n      }, maxDuration);\n    }\n    timer = setTimeout(() => {\n      if (maxTimer)\n        clearTimeout(maxTimer);\n      maxTimer = null;\n      invoke();\n    }, duration);\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  };\n  const filter = (invoke) => {\n    const duration = unref(ms);\n    const elapsed = Date.now() - lastExec;\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      timer = setTimeout(() => {\n        lastExec = Date.now();\n        isLeading = true;\n        clear();\n        invoke();\n      }, duration);\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive, pause, resume, eventFilter };\n}\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  if (ms <= 0)\n    return value;\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = true, leading = true) {\n  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(ref, {\n    get,\n    set,\n    untrackedGet,\n    silentSet,\n    peek,\n    lay\n  }, { enumerable: true });\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\"\n  } = options;\n  let stop1, stop2;\n  if (direction === \"both\" || direction === \"ltr\") {\n    stop1 = watch(left, (newValue) => right.value = newValue, { flush, deep, immediate });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    stop2 = watch(right, (newValue) => left.value = newValue, { flush, deep, immediate });\n  }\n  return () => {\n    stop1 == null ? void 0 : stop1();\n    stop2 == null ? void 0 : stop2();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$4(__spreadValues$6({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction until(r) {\n  let isNot = false;\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(r, (v) => {\n        if (condition(v) === !isNot) {\n          stop == null ? void 0 : stop();\n          resolve();\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).finally(() => {\n        stop == null ? void 0 : stop();\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    return toMatch((v) => v === unref(value), options);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(unref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(unref(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        isNot = !isNot;\n        return this;\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        isNot = !isNot;\n        return this;\n      }\n    };\n    return instance;\n  }\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = val;\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nconst formatDate = (date, formatStr) => {\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const matches = {\n    YY: String(years).slice(-2),\n    YYYY: years,\n    M: month + 1,\n    MM: `${month + 1}`.padStart(2, \"0\"),\n    D: String(days),\n    DD: `${days}`.padStart(2, \"0\"),\n    H: String(hours),\n    HH: `${hours}`.padStart(2, \"0\"),\n    h: `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: String(minutes),\n    mm: `${minutes}`.padStart(2, \"0\"),\n    s: String(seconds),\n    ss: `${seconds}`.padStart(2, \"0\"),\n    SSS: `${milliseconds}`.padStart(3, \"0\"),\n    d: day\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]);\n};\nconst normalizeDate = (date) => {\n  if (date === null)\n    return new Date(NaN);\n  if (date === void 0)\n    return new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\") {\n  return computed(() => formatDate(normalizeDate(unref(date)), unref(formatStr)));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    if (interval <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, unref(interval));\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval)) {\n    const stopWatch = watch(interval, () => {\n      if (immediate && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true\n  } = options;\n  const counter = ref(0);\n  const controls = useIntervalFn(() => counter.value += 1, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$5({\n      counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, () => ms.value = timestamp(), options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, unref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending,\n    start,\n    stop\n  };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false\n  } = options;\n  const controls = useTimeoutFn(noop, interval, options);\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$4({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const innerValue = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      innerValue.value = value;\n      return innerValue.value;\n    } else {\n      innerValue.value = innerValue.value === unref(truthyValue) ? unref(falsyValue) : unref(truthyValue);\n      return innerValue.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [innerValue, toggle];\n}\n\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(source, (...args) => {\n    current.value += 1;\n    if (current.value >= unref(count))\n      nextTick(() => stop());\n    cb(...args);\n  }, watchOptions);\n  return { count: current, stop };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$3(__spreadValues$3({}, watchOptions), {\n    eventFilter: debounceFilter(debounce, { maxWait })\n  }));\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(eventFilter, cb);\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, (...args) => {\n      if (!ignore.value)\n        filteredCb(...args);\n    }, watchOptions);\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, () => {\n      syncCounter.value++;\n    }, __spreadProps$2(__spreadValues$2({}, watchOptions), { flush: \"sync\" })));\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, (...args) => {\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore)\n        return;\n      filteredCb(...args);\n    }, watchOptions));\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter\n  }));\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps(__spreadValues({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, (v, ov, onInvalidate) => {\n    if (v)\n      cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { __onlyVue3, logicAnd as and, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, logicAnd, logicNot, logicOr, makeDestructurable, noop, normalizeDate, logicNot as not, now, objectPick, logicOr as or, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToggle, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchWithFilter, whenever };\n","/**\n * The inverse of `_.toPairs`; this method returns an object composed\n * from key-value `pairs`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} pairs The key-value pairs.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.fromPairs([['a', 1], ['b', 2]]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction fromPairs(pairs) {\n  var index = -1,\n      length = pairs == null ? 0 : pairs.length,\n      result = {};\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n  return result;\n}\n\nexport default fromPairs;\n","import { warn } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { isObject } from '../types'\nimport { hasOwn } from '../objects'\nimport type { ExtractPropTypes, PropType } from 'vue'\n\nconst wrapperKey = Symbol()\nexport type PropWrapper<T> = { [wrapperKey]: T }\n\nexport const propKey = '__elPropsReservedKey'\n\ntype ResolveProp<T> = ExtractPropTypes<{\n  key: { type: T; required: true }\n}>['key']\ntype ResolvePropType<T> = ResolveProp<T> extends { type: infer V }\n  ? V\n  : ResolveProp<T>\ntype ResolvePropTypeWithReadonly<T> = Readonly<T> extends Readonly<\n  Array<infer A>\n>\n  ? ResolvePropType<A[]>\n  : ResolvePropType<T>\n\ntype IfUnknown<T, V> = [unknown] extends [T] ? V : T\n\nexport type BuildPropOption<T, D extends BuildPropType<T, V, C>, R, V, C> = {\n  type?: T\n  values?: readonly V[]\n  required?: R\n  default?: R extends true\n    ? never\n    : D extends Record<string, unknown> | Array<any>\n    ? () => D\n    : (() => D) | D\n  validator?: ((val: any) => val is C) | ((val: any) => boolean)\n}\n\ntype _BuildPropType<T, V, C> =\n  | (T extends PropWrapper<unknown>\n      ? T[typeof wrapperKey]\n      : [V] extends [never]\n      ? ResolvePropTypeWithReadonly<T>\n      : never)\n  | V\n  | C\nexport type BuildPropType<T, V, C> = _BuildPropType<\n  IfUnknown<T, never>,\n  IfUnknown<V, never>,\n  IfUnknown<C, never>\n>\n\ntype _BuildPropDefault<T, D> = [T] extends [\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Record<string, unknown> | Array<any> | Function\n]\n  ? D\n  : D extends () => T\n  ? ReturnType<D>\n  : D\n\nexport type BuildPropDefault<T, D, R> = R extends true\n  ? { readonly default?: undefined }\n  : {\n      readonly default: Exclude<D, undefined> extends never\n        ? undefined\n        : Exclude<_BuildPropDefault<T, D>, undefined>\n    }\nexport type BuildPropReturn<T, D, R, V, C> = {\n  readonly type: PropType<BuildPropType<T, V, C>>\n  readonly required: IfUnknown<R, false>\n  readonly validator: ((val: unknown) => boolean) | undefined\n  [propKey]: true\n} & BuildPropDefault<\n  BuildPropType<T, V, C>,\n  IfUnknown<D, never>,\n  IfUnknown<R, false>\n>\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description  prop\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'large' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'large'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport function buildProp<\n  T = never,\n  D extends BuildPropType<T, V, C> = never,\n  R extends boolean = false,\n  V = never,\n  C = never\n>(\n  option: BuildPropOption<T, D, R, V, C>,\n  key?: string\n): BuildPropReturn<T, D, R, V, C> {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(option) || !!option[propKey]) return option as any\n\n  const { values, required, default: defaultValue, type, validator } = option\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = Array.from(values)\n            if (hasOwn(option, 'default')) {\n              allowedValues.push(defaultValue)\n            }\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  const prop: any = {\n    type:\n      isObject(type) && Object.getOwnPropertySymbols(type).includes(wrapperKey)\n        ? type[wrapperKey]\n        : type,\n    required: !!required,\n    validator: _validator,\n    [propKey]: true,\n  }\n  if (hasOwn(option, 'default')) prop.default = defaultValue\n\n  return prop as BuildPropReturn<T, D, R, V, C>\n}\n\ntype NativePropType = [\n  ((...args: any) => any) | { new (...args: any): any } | undefined | null\n]\n\nexport const buildProps = <\n  O extends {\n    [K in keyof O]: O[K] extends BuildPropReturn<any, any, any, any, any>\n      ? O[K]\n      : [O[K]] extends NativePropType\n      ? O[K]\n      : O[K] extends BuildPropOption<\n          infer T,\n          infer D,\n          infer R,\n          infer V,\n          infer C\n        >\n      ? D extends BuildPropType<T, V, C>\n        ? BuildPropOption<T, D, R, V, C>\n        : never\n      : never\n  }\n>(\n  props: O\n) =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as unknown as {\n    [K in keyof O]: O[K] extends { [propKey]: boolean }\n      ? O[K]\n      : [O[K]] extends NativePropType\n      ? O[K]\n      : O[K] extends BuildPropOption<\n          infer T,\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          infer _D,\n          infer R,\n          infer V,\n          infer C\n        >\n      ? BuildPropReturn<T, O[K]['default'], R, V, C>\n      : never\n  }\n\nexport const definePropType = <T>(val: any) =>\n  ({ [wrapperKey]: val } as PropWrapper<T>)\n","import { buildProps, definePropType } from '@element-plus/utils'\nimport type { ExtractPropTypes } from 'vue'\nimport type Icon from './icon.vue'\n\nexport const iconProps = buildProps({\n  size: {\n    type: definePropType<number | string>([Number, String]),\n  },\n  color: {\n    type: String,\n  },\n} as const)\nexport type IconProps = ExtractPropTypes<typeof iconProps>\nexport type IconInstance = InstanceType<typeof Icon>\n","\nexport default (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n}\n","import type { configProviderProps } from '@element-plus/components/config-provider'\nimport type { ExtractPropTypes, InjectionKey, Ref } from 'vue'\n\nexport type ConfigProviderContext = Partial<\n  ExtractPropTypes<typeof configProviderProps>\n>\n\nexport const configProviderContextKey: InjectionKey<\n  Ref<ConfigProviderContext>\n> = Symbol()\n","import { isString } from './types'\n\nclass ElementPlusError extends Error {\n  constructor(m: string) {\n    super(m)\n    this.name = 'ElementPlusError'\n  }\n}\n\nexport function throwError(scope: string, m: string): never {\n  throw new ElementPlusError(`[${scope}] ${m}`)\n}\n\nexport function debugWarn(err: Error): void\nexport function debugWarn(scope: string, message: string): void\nexport function debugWarn(scope: string | Error, message?: string): void {\n  if (process.env.NODE_ENV !== 'production') {\n    const error: Error = isString(scope)\n      ? new ElementPlusError(`[${scope}] ${message}`)\n      : scope\n    // eslint-disable-next-line no-console\n    console.warn(error)\n  }\n}\n","import { get, set } from 'lodash-unified'\nimport type { Entries } from 'type-fest'\nimport type { Arrayable } from '.'\n\nexport const keysOf = <T>(arr: T) => Object.keys(arr) as Array<keyof T>\nexport const entriesOf = <T>(arr: T) => Object.entries(arr) as Entries<T>\nexport { hasOwn } from '@vue/shared'\n\nexport const getProp = <T = any>(\n  obj: Record<string, any>,\n  path: Arrayable<string>,\n  defaultValue?: any\n): { value: T } => {\n  return {\n    get value() {\n      return get(obj, path, defaultValue)\n    },\n    set value(val: any) {\n      set(obj, path, val)\n    },\n  }\n}\n","import { computed, getCurrentInstance, inject, provide, ref, unref } from 'vue'\nimport { configProviderContextKey } from '@element-plus/tokens'\nimport { debugWarn, keysOf } from '@element-plus/utils'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { App, Ref } from 'vue'\nimport type { ConfigProviderContext } from '@element-plus/tokens'\n\n// this is meant to fix global methods like `ElMessage(opts)`, this way we can inject current locale\n// into the component as default injection value.\n// refer to: https://github.com/element-plus/element-plus/issues/2610#issuecomment-887965266\nconst globalConfig = ref<ConfigProviderContext>()\n\nexport function useGlobalConfig<\n  K extends keyof ConfigProviderContext,\n  D extends ConfigProviderContext[K]\n>(\n  key: K,\n  defaultValue?: D\n): Ref<Exclude<ConfigProviderContext[K], undefined> | D>\nexport function useGlobalConfig(): Ref<ConfigProviderContext>\nexport function useGlobalConfig(\n  key?: keyof ConfigProviderContext,\n  defaultValue = undefined\n) {\n  const config = getCurrentInstance()\n    ? inject(configProviderContextKey, globalConfig)\n    : globalConfig\n  if (key) {\n    return computed(() => config.value?.[key] ?? defaultValue)\n  } else {\n    return config\n  }\n}\n\nexport const provideGlobalConfig = (\n  config: MaybeRef<ConfigProviderContext>,\n  app?: App,\n  global = false\n) => {\n  const inSetup = !!getCurrentInstance()\n  const oldConfig = inSetup ? useGlobalConfig() : undefined\n\n  const provideFn = app?.provide ?? (inSetup ? provide : undefined)\n  if (!provideFn) {\n    debugWarn(\n      'provideGlobalConfig',\n      'provideGlobalConfig() can only be used inside setup().'\n    )\n    return\n  }\n\n  const context = computed(() => {\n    const cfg = unref(config)\n    if (!oldConfig?.value) return cfg\n    return mergeConfig(oldConfig.value, cfg)\n  })\n  provideFn(configProviderContextKey, context)\n  if (global || !globalConfig.value) {\n    globalConfig.value = context.value\n  }\n  return context\n}\n\nconst mergeConfig = (\n  a: ConfigProviderContext,\n  b: ConfigProviderContext\n): ConfigProviderContext => {\n  const keys = [...new Set([...keysOf(a), ...keysOf(b)])]\n  const obj = {}\n  for (const key of keys) {\n    obj[key] = b[key] ?? a[key]\n  }\n  return obj\n}\n","import { computed, unref } from 'vue'\nimport { useGlobalConfig } from '../use-global-config'\n\nexport const defaultNamespace = 'el'\nconst statePrefix = 'is-'\n\nconst _bem = (\n  namespace: string,\n  block: string,\n  blockSuffix: string,\n  element: string,\n  modifier: string\n) => {\n  let cls = `${namespace}-${block}`\n  if (blockSuffix) {\n    cls += `-${blockSuffix}`\n  }\n  if (element) {\n    cls += `__${element}`\n  }\n  if (modifier) {\n    cls += `--${modifier}`\n  }\n  return cls\n}\n\nexport const useNamespace = (block: string) => {\n  const globalConfig = useGlobalConfig('namespace')\n  const namespace = computed(() => globalConfig.value || defaultNamespace)\n  const b = (blockSuffix = '') =>\n    _bem(unref(namespace), block, blockSuffix, '', '')\n  const e = (element?: string) =>\n    element ? _bem(unref(namespace), block, '', element, '') : ''\n  const m = (modifier?: string) =>\n    modifier ? _bem(unref(namespace), block, '', '', modifier) : ''\n  const be = (blockSuffix?: string, element?: string) =>\n    blockSuffix && element\n      ? _bem(unref(namespace), block, blockSuffix, element, '')\n      : ''\n  const em = (element?: string, modifier?: string) =>\n    element && modifier\n      ? _bem(unref(namespace), block, '', element, modifier)\n      : ''\n  const bm = (blockSuffix?: string, modifier?: string) =>\n    blockSuffix && modifier\n      ? _bem(unref(namespace), block, blockSuffix, '', modifier)\n      : ''\n  const bem = (blockSuffix?: string, element?: string, modifier?: string) =>\n    blockSuffix && element && modifier\n      ? _bem(unref(namespace), block, blockSuffix, element, modifier)\n      : ''\n  const is: {\n    (name: string, state: boolean | undefined): string\n    (name: string): string\n  } = (name: string, ...args: [boolean | undefined] | []) => {\n    const state = args.length >= 1 ? args[0]! : true\n    return name && state ? `${statePrefix}${name}` : ''\n  }\n\n  // for css var\n  // --el-xxx: value;\n  const cssVar = (object: Record<string, string>) => {\n    const styles: Record<string, string> = {}\n    for (const key in object) {\n      styles[`--${namespace.value}-${key}`] = object[key]\n    }\n    return styles\n  }\n  // with block\n  const cssVarBlock = (object: Record<string, string>) => {\n    const styles: Record<string, string> = {}\n    for (const key in object) {\n      styles[`--${namespace.value}-${block}-${key}`] = object[key]\n    }\n    return styles\n  }\n\n  const cssVarName = (name: string) => `--${namespace.value}-${name}`\n  const cssVarBlockName = (name: string) =>\n    `--${namespace.value}-${block}-${name}`\n\n  return {\n    namespace,\n    b,\n    e,\n    m,\n    be,\n    em,\n    bm,\n    bem,\n    is,\n    // css\n    cssVar,\n    cssVarName,\n    cssVarBlock,\n    cssVarBlockName,\n  }\n}\n\nexport type UseNamespaceReturn = ReturnType<typeof useNamespace>\n","import { isArray, isObject } from '@vue/shared'\nimport { isNil } from 'lodash-unified'\n\nexport {\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  isDate,\n  isPromise,\n  isSymbol,\n} from '@vue/shared'\nexport { isBoolean, isNumber } from '@vueuse/core'\nexport { isVNode } from 'vue'\n\nexport const isUndefined = (val: any): val is undefined => val === undefined\n\nexport const isEmpty = (val: unknown) =>\n  (!val && val !== 0) ||\n  (isArray(val) && val.length === 0) ||\n  (isObject(val) && !Object.keys(val).length)\n\nexport const isElement = (e: unknown): e is Element => {\n  if (typeof Element === 'undefined') return false\n  return e instanceof Element\n}\n\nexport const isPropAbsent = (prop: unknown): prop is null | undefined => {\n  return isNil(prop)\n}\n","import { isClient } from '@vueuse/core'\nimport { isNumber, isObject, isString } from '../types'\nimport { camelize } from '../strings'\nimport { entriesOf, keysOf } from '../objects'\nimport { debugWarn } from '../error'\nimport type { CSSProperties } from 'vue'\n\nconst SCOPE = 'utils/dom/style'\n\nexport const classNameToArray = (cls = '') =>\n  cls.split(' ').filter((item) => !!item.trim())\n\nexport const hasClass = (el: Element, cls: string): boolean => {\n  if (!el || !cls) return false\n  if (cls.includes(' ')) throw new Error('className should not contain space.')\n  return el.classList.contains(cls)\n}\n\nexport const addClass = (el: Element, cls: string) => {\n  if (!el || !cls.trim()) return\n  el.classList.add(...classNameToArray(cls))\n}\n\nexport const removeClass = (el: Element, cls: string) => {\n  if (!el || !cls.trim()) return\n  el.classList.remove(...classNameToArray(cls))\n}\n\nexport const getStyle = (\n  element: HTMLElement,\n  styleName: keyof CSSProperties\n): string => {\n  if (!isClient || !element || !styleName) return ''\n\n  let key = camelize(styleName)\n  if (key === 'float') key = 'cssFloat'\n  try {\n    const style = element.style[styleName]\n    if (style) return style\n    const computed = document.defaultView?.getComputedStyle(element, '')\n    return computed ? computed[styleName] : ''\n  } catch {\n    return element.style[styleName]\n  }\n}\n\nexport const setStyle = (\n  element: HTMLElement,\n  styleName: CSSProperties | keyof CSSProperties,\n  value?: string | number\n) => {\n  if (!element || !styleName) return\n\n  if (isObject(styleName)) {\n    entriesOf(styleName).forEach(([prop, value]) =>\n      setStyle(element, prop, value)\n    )\n  } else {\n    const key = camelize(styleName)\n    element.style[key] = value\n  }\n}\n\nexport const removeStyle = (\n  element: HTMLElement,\n  style: CSSProperties | keyof CSSProperties\n) => {\n  if (!element || !style) return\n\n  if (isObject(style)) {\n    keysOf(style).forEach((prop) => removeStyle(element, prop))\n  } else {\n    setStyle(element, style, '')\n  }\n}\n\nexport function addUnit(value?: string | number, defaultUnit = 'px') {\n  if (!value) return ''\n  if (isString(value)) {\n    return value\n  } else if (isNumber(value)) {\n    return `${value}${defaultUnit}`\n  }\n  debugWarn(SCOPE, 'binding value must be a string or number')\n}\n","<template>\n  <i :class=\"ns.b()\" :style=\"style\" v-bind=\"$attrs\">\n    <slot />\n  </i>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed } from 'vue'\nimport { addUnit, isUndefined } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { iconProps } from './icon'\nimport type { CSSProperties } from 'vue'\n\ndefineOptions({\n  name: 'ElIcon',\n  inheritAttrs: false,\n})\nconst props = defineProps(iconProps)\nconst ns = useNamespace('icon')\n\nconst style = computed<CSSProperties>(() => {\n  if (!props.size && !props.color) return {}\n\n  return {\n    fontSize: isUndefined(props.size) ? undefined : addUnit(props.size),\n    '--color': props.color,\n  }\n})\n</script>\n","import { NOOP } from '@vue/shared'\n\nimport type { App } from 'vue'\nimport type { SFCInstallWithContext, SFCWithInstall } from './typescript'\n\nexport const withInstall = <T, E extends Record<string, any>>(\n  main: T,\n  extra?: E\n) => {\n  ;(main as SFCWithInstall<T>).install = (app): void => {\n    for (const comp of [main, ...Object.values(extra ?? {})]) {\n      app.component(comp.name, comp)\n    }\n  }\n\n  if (extra) {\n    for (const [key, comp] of Object.entries(extra)) {\n      ;(main as any)[key] = comp\n    }\n  }\n  return main as SFCWithInstall<T> & E\n}\n\nexport const withInstallFunction = <T>(fn: T, name: string) => {\n  ;(fn as SFCWithInstall<T>).install = (app: App) => {\n    ;(fn as SFCInstallWithContext<T>)._context = app._context\n    app.config.globalProperties[name] = fn\n  }\n\n  return fn as SFCInstallWithContext<T>\n}\n\nexport const withNoopInstall = <T>(component: T) => {\n  ;(component as SFCWithInstall<T>).install = NOOP\n\n  return component as SFCWithInstall<T>\n}\n","import { withInstall } from '@element-plus/utils'\n\nimport Icon from './src/icon.vue'\n\nexport const ElIcon = withInstall(Icon)\nexport default ElIcon\n\nexport * from './src/icon'\n","var _export_sfc = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};\n\nexport { _export_sfc as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"Loading\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar loading = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { loading as default };\n","import { computed, getCurrentInstance } from 'vue'\nimport type { ComputedRef } from 'vue'\n\nexport const useProp = <T>(name: string): ComputedRef<T | undefined> => {\n  const vm = getCurrentInstance()!\n  return computed(() => vm.proxy?.$props[name] ?? undefined)\n}\n","export const componentSizes = ['', 'default', 'small', 'large'] as const\n\nexport type ComponentSize = typeof componentSizes[number]\n\nexport const componentSizeMap = {\n  large: 40,\n  default: 32,\n  small: 24,\n} as const\n","import type { InjectionKey, SetupContext, UnwrapRef } from 'vue'\nimport type {\n  RuleItem,\n  ValidateError,\n  ValidateFieldsError,\n} from 'async-validator'\nimport type { ComponentSize } from '@element-plus/constants'\nimport type {\n  FormEmits,\n  FormItemProp,\n  FormItemProps,\n  FormLabelWidthContext,\n  FormProps,\n} from '@element-plus/components/form'\nimport type { Arrayable } from '@element-plus/utils'\n\nexport interface FormItemRule extends RuleItem {\n  trigger?: Arrayable<string>\n}\nexport type FormRules = Partial<Record<string, Arrayable<FormItemRule>>>\n\nexport type FormValidationResult = Promise<boolean>\nexport type FormValidateCallback = (\n  isValid: boolean,\n  invalidFields?: ValidateFieldsError\n) => void\nexport interface FormValidateFailure {\n  errors: ValidateError[] | null\n  fields: ValidateFieldsError\n}\n\nexport type FormContext = FormProps &\n  UnwrapRef<FormLabelWidthContext> & {\n    emit: SetupContext<FormEmits>['emit']\n\n    // expose\n    addField: (field: FormItemContext) => void\n    removeField: (field: FormItemContext) => void\n    resetFields: (props?: Arrayable<FormItemProp>) => void\n    clearValidate: (props?: Arrayable<FormItemProp>) => void\n    validateField: (\n      props?: Arrayable<FormItemProp>,\n      callback?: FormValidateCallback\n    ) => FormValidationResult\n  }\n\nexport interface FormItemContext extends FormItemProps {\n  $el: HTMLDivElement | undefined\n  size: ComponentSize\n  validateState: string\n  isGroup: boolean\n  labelId: string\n  inputIds: string[]\n  addInputId: (id: string) => void\n  removeInputId: (id: string) => void\n  validate: (\n    trigger: string,\n    callback?: FormValidateCallback\n  ) => FormValidationResult\n  resetField(): void\n  clearValidate(): void\n}\n\nexport const formContextKey: InjectionKey<FormContext> =\n  Symbol('formContextKey')\nexport const formItemContextKey: InjectionKey<FormItemContext> =\n  Symbol('formItemContextKey')\n","import { computed, inject, ref, unref } from 'vue'\nimport { formContextKey, formItemContextKey } from '@element-plus/tokens'\nimport { buildProp } from '@element-plus/utils'\nimport { componentSizes } from '@element-plus/constants'\nimport { useProp } from '../use-prop'\nimport { useGlobalConfig } from '../use-global-config'\nimport type { ComponentSize } from '@element-plus/constants'\nimport type { MaybeRef } from '@vueuse/core'\n\nexport const useSizeProp = buildProp({\n  type: String,\n  values: componentSizes,\n  required: false,\n} as const)\n\nexport const useSize = (\n  fallback?: MaybeRef<ComponentSize | undefined>,\n  ignore: Partial<Record<'prop' | 'form' | 'formItem' | 'global', boolean>> = {}\n) => {\n  const emptyRef = ref(undefined)\n\n  const size = ignore.prop ? emptyRef : useProp<ComponentSize>('size')\n  const globalConfig = ignore.global ? emptyRef : useGlobalConfig('size')\n  const form = ignore.form\n    ? { size: undefined }\n    : inject(formContextKey, undefined)\n  const formItem = ignore.formItem\n    ? { size: undefined }\n    : inject(formItemContextKey, undefined)\n\n  return computed(\n    (): ComponentSize =>\n      size.value ||\n      unref(fallback) ||\n      formItem?.size ||\n      form?.size ||\n      globalConfig.value ||\n      ''\n  )\n}\n\nexport const useDisabled = (fallback?: MaybeRef<boolean | undefined>) => {\n  const disabled = useProp<boolean>('disabled')\n  const form = inject(formContextKey, undefined)\n  return computed(\n    () => disabled.value || unref(fallback) || form?.disabled || false\n  )\n}\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"Close\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar close = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { close as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"SuccessFilled\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar successFilled = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { successFilled as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"InfoFilled\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar infoFilled = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { infoFilled as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"WarningFilled\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar warningFilled = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { warningFilled as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"CircleCloseFilled\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar circleCloseFilled = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { circleCloseFilled as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"CircleCheck\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z\"\n}, null, -1);\nconst _hoisted_3 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z\"\n}, null, -1);\nconst _hoisted_4 = [\n  _hoisted_2,\n  _hoisted_3\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_4);\n}\nvar circleCheck = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { circleCheck as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"CircleClose\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z\"\n}, null, -1);\nconst _hoisted_3 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z\"\n}, null, -1);\nconst _hoisted_4 = [\n  _hoisted_2,\n  _hoisted_3\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_4);\n}\nvar circleClose = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { circleClose as default };\n","import {\n  CircleCheck,\n  CircleClose,\n  CircleCloseFilled,\n  Close,\n  InfoFilled,\n  Loading,\n  SuccessFilled,\n  WarningFilled,\n} from '@element-plus/icons-vue'\nimport { definePropType } from './props'\nimport type { Component } from 'vue'\n\nexport const iconPropType = definePropType<string | Component>([\n  String,\n  Object,\n  Function,\n])\n\nexport const CloseComponents = {\n  Close,\n}\n\nexport const TypeComponents = {\n  Close,\n  SuccessFilled,\n  InfoFilled,\n  WarningFilled,\n  CircleCloseFilled,\n}\n\nexport const TypeComponentsMap = {\n  success: SuccessFilled,\n  warning: WarningFilled,\n  error: CircleCloseFilled,\n  info: InfoFilled,\n}\n\nexport const ValidateComponentsMap = {\n  validating: Loading,\n  success: CircleCheck,\n  error: CircleClose,\n}\n","import { useSizeProp } from '@element-plus/hooks'\nimport { buildProps, iconPropType } from '@element-plus/utils'\nimport { Loading } from '@element-plus/icons-vue'\nimport type { ExtractPropTypes } from 'vue'\nimport type button from './button.vue'\n\nexport const buttonTypes = [\n  'default',\n  'primary',\n  'success',\n  'warning',\n  'info',\n  'danger',\n  /**\n   * @deprecated\n   * Text type will be deprecated in the next major version (3.0.0)\n   */\n  'text',\n  '',\n] as const\nexport const buttonNativeTypes = ['button', 'submit', 'reset'] as const\n\nexport const buttonProps = buildProps({\n  size: useSizeProp,\n  disabled: Boolean,\n  type: {\n    type: String,\n    values: buttonTypes,\n    default: '',\n  },\n  icon: {\n    type: iconPropType,\n    default: '',\n  },\n  nativeType: {\n    type: String,\n    values: buttonNativeTypes,\n    default: 'button',\n  },\n  loading: Boolean,\n  loadingIcon: {\n    type: iconPropType,\n    default: () => Loading,\n  },\n  plain: Boolean,\n  text: Boolean,\n  link: Boolean,\n  bg: Boolean,\n  autofocus: Boolean,\n  round: Boolean,\n  circle: Boolean,\n  color: String,\n  dark: Boolean,\n  autoInsertSpace: {\n    type: Boolean,\n    default: undefined,\n  },\n} as const)\nexport const buttonEmits = {\n  click: (evt: MouseEvent) => evt instanceof MouseEvent,\n}\n\nexport type ButtonProps = ExtractPropTypes<typeof buttonProps>\nexport type ButtonEmits = typeof buttonEmits\n\nexport type ButtonType = ButtonProps['type']\nexport type ButtonNativeType = ButtonProps['nativeType']\n\nexport type ButtonInstance = InstanceType<typeof button>\n\nexport interface ButtonConfigContext {\n  autoInsertSpace?: boolean\n}\n","/**\n * Take input from [0, n] and return it as [0, 1]\n * @hidden\n */\nexport function bound01(n, max) {\n    if (isOnePointZero(n)) {\n        n = '100%';\n    }\n    var isPercent = isPercentage(n);\n    n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));\n    // Automatically convert percentage into number\n    if (isPercent) {\n        n = parseInt(String(n * max), 10) / 100;\n    }\n    // Handle floating point rounding errors\n    if (Math.abs(n - max) < 0.000001) {\n        return 1;\n    }\n    // Convert into [0, 1] range if it isn't already\n    if (max === 360) {\n        // If n is a hue given in degrees,\n        // wrap around out-of-range values into [0, 360] range\n        // then convert into [0, 1].\n        n = (n < 0 ? (n % max) + max : n % max) / parseFloat(String(max));\n    }\n    else {\n        // If n not a hue given in degrees\n        // Convert into [0, 1] range if it isn't already.\n        n = (n % max) / parseFloat(String(max));\n    }\n    return n;\n}\n/**\n * Force a number between 0 and 1\n * @hidden\n */\nexport function clamp01(val) {\n    return Math.min(1, Math.max(0, val));\n}\n/**\n * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\n * @hidden\n */\nexport function isOnePointZero(n) {\n    return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;\n}\n/**\n * Check to see if string passed in is a percentage\n * @hidden\n */\nexport function isPercentage(n) {\n    return typeof n === 'string' && n.indexOf('%') !== -1;\n}\n/**\n * Return a valid alpha value [0,1] with all invalid values being set to 1\n * @hidden\n */\nexport function boundAlpha(a) {\n    a = parseFloat(a);\n    if (isNaN(a) || a < 0 || a > 1) {\n        a = 1;\n    }\n    return a;\n}\n/**\n * Replace a decimal with it's percentage value\n * @hidden\n */\nexport function convertToPercentage(n) {\n    if (n <= 1) {\n        return \"\".concat(Number(n) * 100, \"%\");\n    }\n    return n;\n}\n/**\n * Force a hex value to have 2 characters\n * @hidden\n */\nexport function pad2(c) {\n    return c.length === 1 ? '0' + c : String(c);\n}\n","import { bound01, pad2 } from './util';\n// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n/**\n * Handle bounds / percentage checking to conform to CSS color spec\n * <http://www.w3.org/TR/css3-color/>\n * *Assumes:* r, g, b in [0, 255] or [0, 1]\n * *Returns:* { r, g, b } in [0, 255]\n */\nexport function rgbToRgb(r, g, b) {\n    return {\n        r: bound01(r, 255) * 255,\n        g: bound01(g, 255) * 255,\n        b: bound01(b, 255) * 255,\n    };\n}\n/**\n * Converts an RGB color value to HSL.\n * *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n * *Returns:* { h, s, l } in [0,1]\n */\nexport function rgbToHsl(r, g, b) {\n    r = bound01(r, 255);\n    g = bound01(g, 255);\n    b = bound01(b, 255);\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var h = 0;\n    var s = 0;\n    var l = (max + min) / 2;\n    if (max === min) {\n        s = 0;\n        h = 0; // achromatic\n    }\n    else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n            case r:\n                h = (g - b) / d + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) / d + 2;\n                break;\n            case b:\n                h = (r - g) / d + 4;\n                break;\n            default:\n                break;\n        }\n        h /= 6;\n    }\n    return { h: h, s: s, l: l };\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * (6 * t);\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\n/**\n * Converts an HSL color value to RGB.\n *\n * *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n * *Returns:* { r, g, b } in the set [0, 255]\n */\nexport function hslToRgb(h, s, l) {\n    var r;\n    var g;\n    var b;\n    h = bound01(h, 360);\n    s = bound01(s, 100);\n    l = bound01(l, 100);\n    if (s === 0) {\n        // achromatic\n        g = l;\n        b = l;\n        r = l;\n    }\n    else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return { r: r * 255, g: g * 255, b: b * 255 };\n}\n/**\n * Converts an RGB color value to HSV\n *\n * *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n * *Returns:* { h, s, v } in [0,1]\n */\nexport function rgbToHsv(r, g, b) {\n    r = bound01(r, 255);\n    g = bound01(g, 255);\n    b = bound01(b, 255);\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var h = 0;\n    var v = max;\n    var d = max - min;\n    var s = max === 0 ? 0 : d / max;\n    if (max === min) {\n        h = 0; // achromatic\n    }\n    else {\n        switch (max) {\n            case r:\n                h = (g - b) / d + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) / d + 2;\n                break;\n            case b:\n                h = (r - g) / d + 4;\n                break;\n            default:\n                break;\n        }\n        h /= 6;\n    }\n    return { h: h, s: s, v: v };\n}\n/**\n * Converts an HSV color value to RGB.\n *\n * *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n * *Returns:* { r, g, b } in the set [0, 255]\n */\nexport function hsvToRgb(h, s, v) {\n    h = bound01(h, 360) * 6;\n    s = bound01(s, 100);\n    v = bound01(v, 100);\n    var i = Math.floor(h);\n    var f = h - i;\n    var p = v * (1 - s);\n    var q = v * (1 - f * s);\n    var t = v * (1 - (1 - f) * s);\n    var mod = i % 6;\n    var r = [v, q, p, p, t, v][mod];\n    var g = [t, v, v, q, p, p][mod];\n    var b = [p, p, t, v, v, q][mod];\n    return { r: r * 255, g: g * 255, b: b * 255 };\n}\n/**\n * Converts an RGB color to hex\n *\n * Assumes r, g, and b are contained in the set [0, 255]\n * Returns a 3 or 6 character hex\n */\nexport function rgbToHex(r, g, b, allow3Char) {\n    var hex = [\n        pad2(Math.round(r).toString(16)),\n        pad2(Math.round(g).toString(16)),\n        pad2(Math.round(b).toString(16)),\n    ];\n    // Return a 3 character hex if possible\n    if (allow3Char &&\n        hex[0].startsWith(hex[0].charAt(1)) &&\n        hex[1].startsWith(hex[1].charAt(1)) &&\n        hex[2].startsWith(hex[2].charAt(1))) {\n        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n    }\n    return hex.join('');\n}\n/**\n * Converts an RGBA color plus alpha transparency to hex\n *\n * Assumes r, g, b are contained in the set [0, 255] and\n * a in [0, 1]. Returns a 4 or 8 character rgba hex\n */\n// eslint-disable-next-line max-params\nexport function rgbaToHex(r, g, b, a, allow4Char) {\n    var hex = [\n        pad2(Math.round(r).toString(16)),\n        pad2(Math.round(g).toString(16)),\n        pad2(Math.round(b).toString(16)),\n        pad2(convertDecimalToHex(a)),\n    ];\n    // Return a 4 character hex if possible\n    if (allow4Char &&\n        hex[0].startsWith(hex[0].charAt(1)) &&\n        hex[1].startsWith(hex[1].charAt(1)) &&\n        hex[2].startsWith(hex[2].charAt(1)) &&\n        hex[3].startsWith(hex[3].charAt(1))) {\n        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n    }\n    return hex.join('');\n}\n/**\n * Converts an RGBA color to an ARGB Hex8 string\n * Rarely used, but required for \"toFilter()\"\n */\nexport function rgbaToArgbHex(r, g, b, a) {\n    var hex = [\n        pad2(convertDecimalToHex(a)),\n        pad2(Math.round(r).toString(16)),\n        pad2(Math.round(g).toString(16)),\n        pad2(Math.round(b).toString(16)),\n    ];\n    return hex.join('');\n}\n/** Converts a decimal to a hex value */\nexport function convertDecimalToHex(d) {\n    return Math.round(parseFloat(d) * 255).toString(16);\n}\n/** Converts a hex value to a decimal */\nexport function convertHexToDecimal(h) {\n    return parseIntFromHex(h) / 255;\n}\n/** Parse a base-16 hex value into a base-10 integer */\nexport function parseIntFromHex(val) {\n    return parseInt(val, 16);\n}\nexport function numberInputToObject(color) {\n    return {\n        r: color >> 16,\n        g: (color & 0xff00) >> 8,\n        b: color & 0xff,\n    };\n}\n","// https://github.com/bahamas10/css-color-names/blob/master/css-color-names.json\n/**\n * @hidden\n */\nexport var names = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    goldenrod: '#daa520',\n    gold: '#ffd700',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    lavenderblush: '#fff0f5',\n    lavender: '#e6e6fa',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32',\n};\n","import { convertHexToDecimal, hslToRgb, hsvToRgb, parseIntFromHex, rgbToRgb } from './conversion';\nimport { names } from './css-color-names';\nimport { boundAlpha, convertToPercentage } from './util';\n/**\n * Given a string or object, convert that input to RGB\n *\n * Possible string inputs:\n * ```\n * \"red\"\n * \"#f00\" or \"f00\"\n * \"#ff0000\" or \"ff0000\"\n * \"#ff000000\" or \"ff000000\"\n * \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n * \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n * \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n * \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n * \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n * \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n * \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n * ```\n */\nexport function inputToRGB(color) {\n    var rgb = { r: 0, g: 0, b: 0 };\n    var a = 1;\n    var s = null;\n    var v = null;\n    var l = null;\n    var ok = false;\n    var format = false;\n    if (typeof color === 'string') {\n        color = stringInputToObject(color);\n    }\n    if (typeof color === 'object') {\n        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {\n            rgb = rgbToRgb(color.r, color.g, color.b);\n            ok = true;\n            format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';\n        }\n        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {\n            s = convertToPercentage(color.s);\n            v = convertToPercentage(color.v);\n            rgb = hsvToRgb(color.h, s, v);\n            ok = true;\n            format = 'hsv';\n        }\n        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {\n            s = convertToPercentage(color.s);\n            l = convertToPercentage(color.l);\n            rgb = hslToRgb(color.h, s, l);\n            ok = true;\n            format = 'hsl';\n        }\n        if (Object.prototype.hasOwnProperty.call(color, 'a')) {\n            a = color.a;\n        }\n    }\n    a = boundAlpha(a);\n    return {\n        ok: ok,\n        format: color.format || format,\n        r: Math.min(255, Math.max(rgb.r, 0)),\n        g: Math.min(255, Math.max(rgb.g, 0)),\n        b: Math.min(255, Math.max(rgb.b, 0)),\n        a: a,\n    };\n}\n// <http://www.w3.org/TR/css3-values/#integers>\nvar CSS_INTEGER = '[-\\\\+]?\\\\d+%?';\n// <http://www.w3.org/TR/css3-values/#number-value>\nvar CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?';\n// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\nvar CSS_UNIT = \"(?:\".concat(CSS_NUMBER, \")|(?:\").concat(CSS_INTEGER, \")\");\n// Actual matching.\n// Parentheses and commas are optional, but not required.\n// Whitespace can take the place of commas or opening paren\nvar PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\".concat(CSS_UNIT, \")[,|\\\\s]+(\").concat(CSS_UNIT, \")[,|\\\\s]+(\").concat(CSS_UNIT, \")\\\\s*\\\\)?\");\nvar PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\".concat(CSS_UNIT, \")[,|\\\\s]+(\").concat(CSS_UNIT, \")[,|\\\\s]+(\").concat(CSS_UNIT, \")[,|\\\\s]+(\").concat(CSS_UNIT, \")\\\\s*\\\\)?\");\nvar matchers = {\n    CSS_UNIT: new RegExp(CSS_UNIT),\n    rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),\n    rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),\n    hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),\n    hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),\n    hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),\n    hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),\n    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n};\n/**\n * Permissive string parsing.  Take in a number of formats, and output an object\n * based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\n */\nexport function stringInputToObject(color) {\n    color = color.trim().toLowerCase();\n    if (color.length === 0) {\n        return false;\n    }\n    var named = false;\n    if (names[color]) {\n        color = names[color];\n        named = true;\n    }\n    else if (color === 'transparent') {\n        return { r: 0, g: 0, b: 0, a: 0, format: 'name' };\n    }\n    // Try to match string input using regular expressions.\n    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n    // Just return an object and let the conversion functions handle that.\n    // This way the result will be the same whether the tinycolor is initialized with string or object.\n    var match = matchers.rgb.exec(color);\n    if (match) {\n        return { r: match[1], g: match[2], b: match[3] };\n    }\n    match = matchers.rgba.exec(color);\n    if (match) {\n        return { r: match[1], g: match[2], b: match[3], a: match[4] };\n    }\n    match = matchers.hsl.exec(color);\n    if (match) {\n        return { h: match[1], s: match[2], l: match[3] };\n    }\n    match = matchers.hsla.exec(color);\n    if (match) {\n        return { h: match[1], s: match[2], l: match[3], a: match[4] };\n    }\n    match = matchers.hsv.exec(color);\n    if (match) {\n        return { h: match[1], s: match[2], v: match[3] };\n    }\n    match = matchers.hsva.exec(color);\n    if (match) {\n        return { h: match[1], s: match[2], v: match[3], a: match[4] };\n    }\n    match = matchers.hex8.exec(color);\n    if (match) {\n        return {\n            r: parseIntFromHex(match[1]),\n            g: parseIntFromHex(match[2]),\n            b: parseIntFromHex(match[3]),\n            a: convertHexToDecimal(match[4]),\n            format: named ? 'name' : 'hex8',\n        };\n    }\n    match = matchers.hex6.exec(color);\n    if (match) {\n        return {\n            r: parseIntFromHex(match[1]),\n            g: parseIntFromHex(match[2]),\n            b: parseIntFromHex(match[3]),\n            format: named ? 'name' : 'hex',\n        };\n    }\n    match = matchers.hex4.exec(color);\n    if (match) {\n        return {\n            r: parseIntFromHex(match[1] + match[1]),\n            g: parseIntFromHex(match[2] + match[2]),\n            b: parseIntFromHex(match[3] + match[3]),\n            a: convertHexToDecimal(match[4] + match[4]),\n            format: named ? 'name' : 'hex8',\n        };\n    }\n    match = matchers.hex3.exec(color);\n    if (match) {\n        return {\n            r: parseIntFromHex(match[1] + match[1]),\n            g: parseIntFromHex(match[2] + match[2]),\n            b: parseIntFromHex(match[3] + match[3]),\n            format: named ? 'name' : 'hex',\n        };\n    }\n    return false;\n}\n/**\n * Check to see if it looks like a CSS unit\n * (see `matchers` above for definition).\n */\nexport function isValidCSSUnit(color) {\n    return Boolean(matchers.CSS_UNIT.exec(String(color)));\n}\n","import { numberInputToObject, rgbaToHex, rgbToHex, rgbToHsl, rgbToHsv } from './conversion';\nimport { names } from './css-color-names';\nimport { inputToRGB } from './format-input';\nimport { bound01, boundAlpha, clamp01 } from './util';\nvar TinyColor = /** @class */ (function () {\n    function TinyColor(color, opts) {\n        if (color === void 0) { color = ''; }\n        if (opts === void 0) { opts = {}; }\n        var _a;\n        // If input is already a tinycolor, return itself\n        if (color instanceof TinyColor) {\n            // eslint-disable-next-line no-constructor-return\n            return color;\n        }\n        if (typeof color === 'number') {\n            color = numberInputToObject(color);\n        }\n        this.originalInput = color;\n        var rgb = inputToRGB(color);\n        this.originalInput = color;\n        this.r = rgb.r;\n        this.g = rgb.g;\n        this.b = rgb.b;\n        this.a = rgb.a;\n        this.roundA = Math.round(100 * this.a) / 100;\n        this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;\n        this.gradientType = opts.gradientType;\n        // Don't let the range of [0,255] come back in [0,1].\n        // Potentially lose a little bit of precision here, but will fix issues where\n        // .5 gets interpreted as half of the total, instead of half of 1\n        // If it was supposed to be 128, this was already taken care of by `inputToRgb`\n        if (this.r < 1) {\n            this.r = Math.round(this.r);\n        }\n        if (this.g < 1) {\n            this.g = Math.round(this.g);\n        }\n        if (this.b < 1) {\n            this.b = Math.round(this.b);\n        }\n        this.isValid = rgb.ok;\n    }\n    TinyColor.prototype.isDark = function () {\n        return this.getBrightness() < 128;\n    };\n    TinyColor.prototype.isLight = function () {\n        return !this.isDark();\n    };\n    /**\n     * Returns the perceived brightness of the color, from 0-255.\n     */\n    TinyColor.prototype.getBrightness = function () {\n        // http://www.w3.org/TR/AERT#color-contrast\n        var rgb = this.toRgb();\n        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n    };\n    /**\n     * Returns the perceived luminance of a color, from 0-1.\n     */\n    TinyColor.prototype.getLuminance = function () {\n        // http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        var rgb = this.toRgb();\n        var R;\n        var G;\n        var B;\n        var RsRGB = rgb.r / 255;\n        var GsRGB = rgb.g / 255;\n        var BsRGB = rgb.b / 255;\n        if (RsRGB <= 0.03928) {\n            R = RsRGB / 12.92;\n        }\n        else {\n            // eslint-disable-next-line prefer-exponentiation-operator\n            R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);\n        }\n        if (GsRGB <= 0.03928) {\n            G = GsRGB / 12.92;\n        }\n        else {\n            // eslint-disable-next-line prefer-exponentiation-operator\n            G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n        }\n        if (BsRGB <= 0.03928) {\n            B = BsRGB / 12.92;\n        }\n        else {\n            // eslint-disable-next-line prefer-exponentiation-operator\n            B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n        }\n        return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n    };\n    /**\n     * Returns the alpha value of a color, from 0-1.\n     */\n    TinyColor.prototype.getAlpha = function () {\n        return this.a;\n    };\n    /**\n     * Sets the alpha value on the current color.\n     *\n     * @param alpha - The new alpha value. The accepted range is 0-1.\n     */\n    TinyColor.prototype.setAlpha = function (alpha) {\n        this.a = boundAlpha(alpha);\n        this.roundA = Math.round(100 * this.a) / 100;\n        return this;\n    };\n    /**\n     * Returns the object as a HSVA object.\n     */\n    TinyColor.prototype.toHsv = function () {\n        var hsv = rgbToHsv(this.r, this.g, this.b);\n        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };\n    };\n    /**\n     * Returns the hsva values interpolated into a string with the following format:\n     * \"hsva(xxx, xxx, xxx, xx)\".\n     */\n    TinyColor.prototype.toHsvString = function () {\n        var hsv = rgbToHsv(this.r, this.g, this.b);\n        var h = Math.round(hsv.h * 360);\n        var s = Math.round(hsv.s * 100);\n        var v = Math.round(hsv.v * 100);\n        return this.a === 1 ? \"hsv(\".concat(h, \", \").concat(s, \"%, \").concat(v, \"%)\") : \"hsva(\".concat(h, \", \").concat(s, \"%, \").concat(v, \"%, \").concat(this.roundA, \")\");\n    };\n    /**\n     * Returns the object as a HSLA object.\n     */\n    TinyColor.prototype.toHsl = function () {\n        var hsl = rgbToHsl(this.r, this.g, this.b);\n        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };\n    };\n    /**\n     * Returns the hsla values interpolated into a string with the following format:\n     * \"hsla(xxx, xxx, xxx, xx)\".\n     */\n    TinyColor.prototype.toHslString = function () {\n        var hsl = rgbToHsl(this.r, this.g, this.b);\n        var h = Math.round(hsl.h * 360);\n        var s = Math.round(hsl.s * 100);\n        var l = Math.round(hsl.l * 100);\n        return this.a === 1 ? \"hsl(\".concat(h, \", \").concat(s, \"%, \").concat(l, \"%)\") : \"hsla(\".concat(h, \", \").concat(s, \"%, \").concat(l, \"%, \").concat(this.roundA, \")\");\n    };\n    /**\n     * Returns the hex value of the color.\n     * @param allow3Char will shorten hex value to 3 char if possible\n     */\n    TinyColor.prototype.toHex = function (allow3Char) {\n        if (allow3Char === void 0) { allow3Char = false; }\n        return rgbToHex(this.r, this.g, this.b, allow3Char);\n    };\n    /**\n     * Returns the hex value of the color -with a # appened.\n     * @param allow3Char will shorten hex value to 3 char if possible\n     */\n    TinyColor.prototype.toHexString = function (allow3Char) {\n        if (allow3Char === void 0) { allow3Char = false; }\n        return '#' + this.toHex(allow3Char);\n    };\n    /**\n     * Returns the hex 8 value of the color.\n     * @param allow4Char will shorten hex value to 4 char if possible\n     */\n    TinyColor.prototype.toHex8 = function (allow4Char) {\n        if (allow4Char === void 0) { allow4Char = false; }\n        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);\n    };\n    /**\n     * Returns the hex 8 value of the color -with a # appened.\n     * @param allow4Char will shorten hex value to 4 char if possible\n     */\n    TinyColor.prototype.toHex8String = function (allow4Char) {\n        if (allow4Char === void 0) { allow4Char = false; }\n        return '#' + this.toHex8(allow4Char);\n    };\n    /**\n     * Returns the object as a RGBA object.\n     */\n    TinyColor.prototype.toRgb = function () {\n        return {\n            r: Math.round(this.r),\n            g: Math.round(this.g),\n            b: Math.round(this.b),\n            a: this.a,\n        };\n    };\n    /**\n     * Returns the RGBA values interpolated into a string with the following format:\n     * \"RGBA(xxx, xxx, xxx, xx)\".\n     */\n    TinyColor.prototype.toRgbString = function () {\n        var r = Math.round(this.r);\n        var g = Math.round(this.g);\n        var b = Math.round(this.b);\n        return this.a === 1 ? \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\") : \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(this.roundA, \")\");\n    };\n    /**\n     * Returns the object as a RGBA object.\n     */\n    TinyColor.prototype.toPercentageRgb = function () {\n        var fmt = function (x) { return \"\".concat(Math.round(bound01(x, 255) * 100), \"%\"); };\n        return {\n            r: fmt(this.r),\n            g: fmt(this.g),\n            b: fmt(this.b),\n            a: this.a,\n        };\n    };\n    /**\n     * Returns the RGBA relative values interpolated into a string\n     */\n    TinyColor.prototype.toPercentageRgbString = function () {\n        var rnd = function (x) { return Math.round(bound01(x, 255) * 100); };\n        return this.a === 1\n            ? \"rgb(\".concat(rnd(this.r), \"%, \").concat(rnd(this.g), \"%, \").concat(rnd(this.b), \"%)\")\n            : \"rgba(\".concat(rnd(this.r), \"%, \").concat(rnd(this.g), \"%, \").concat(rnd(this.b), \"%, \").concat(this.roundA, \")\");\n    };\n    /**\n     * The 'real' name of the color -if there is one.\n     */\n    TinyColor.prototype.toName = function () {\n        if (this.a === 0) {\n            return 'transparent';\n        }\n        if (this.a < 1) {\n            return false;\n        }\n        var hex = '#' + rgbToHex(this.r, this.g, this.b, false);\n        for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b[0], value = _b[1];\n            if (hex === value) {\n                return key;\n            }\n        }\n        return false;\n    };\n    TinyColor.prototype.toString = function (format) {\n        var formatSet = Boolean(format);\n        format = format !== null && format !== void 0 ? format : this.format;\n        var formattedString = false;\n        var hasAlpha = this.a < 1 && this.a >= 0;\n        var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith('hex') || format === 'name');\n        if (needsAlphaFormat) {\n            // Special case for \"transparent\", all other non-alpha formats\n            // will return rgba when there is transparency.\n            if (format === 'name' && this.a === 0) {\n                return this.toName();\n            }\n            return this.toRgbString();\n        }\n        if (format === 'rgb') {\n            formattedString = this.toRgbString();\n        }\n        if (format === 'prgb') {\n            formattedString = this.toPercentageRgbString();\n        }\n        if (format === 'hex' || format === 'hex6') {\n            formattedString = this.toHexString();\n        }\n        if (format === 'hex3') {\n            formattedString = this.toHexString(true);\n        }\n        if (format === 'hex4') {\n            formattedString = this.toHex8String(true);\n        }\n        if (format === 'hex8') {\n            formattedString = this.toHex8String();\n        }\n        if (format === 'name') {\n            formattedString = this.toName();\n        }\n        if (format === 'hsl') {\n            formattedString = this.toHslString();\n        }\n        if (format === 'hsv') {\n            formattedString = this.toHsvString();\n        }\n        return formattedString || this.toHexString();\n    };\n    TinyColor.prototype.toNumber = function () {\n        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);\n    };\n    TinyColor.prototype.clone = function () {\n        return new TinyColor(this.toString());\n    };\n    /**\n     * Lighten the color a given amount. Providing 100 will always return white.\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.lighten = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        var hsl = this.toHsl();\n        hsl.l += amount / 100;\n        hsl.l = clamp01(hsl.l);\n        return new TinyColor(hsl);\n    };\n    /**\n     * Brighten the color a given amount, from 0 to 100.\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.brighten = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        var rgb = this.toRgb();\n        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n        return new TinyColor(rgb);\n    };\n    /**\n     * Darken the color a given amount, from 0 to 100.\n     * Providing 100 will always return black.\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.darken = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        var hsl = this.toHsl();\n        hsl.l -= amount / 100;\n        hsl.l = clamp01(hsl.l);\n        return new TinyColor(hsl);\n    };\n    /**\n     * Mix the color with pure white, from 0 to 100.\n     * Providing 0 will do nothing, providing 100 will always return white.\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.tint = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        return this.mix('white', amount);\n    };\n    /**\n     * Mix the color with pure black, from 0 to 100.\n     * Providing 0 will do nothing, providing 100 will always return black.\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.shade = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        return this.mix('black', amount);\n    };\n    /**\n     * Desaturate the color a given amount, from 0 to 100.\n     * Providing 100 will is the same as calling greyscale\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.desaturate = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        var hsl = this.toHsl();\n        hsl.s -= amount / 100;\n        hsl.s = clamp01(hsl.s);\n        return new TinyColor(hsl);\n    };\n    /**\n     * Saturate the color a given amount, from 0 to 100.\n     * @param amount - valid between 1-100\n     */\n    TinyColor.prototype.saturate = function (amount) {\n        if (amount === void 0) { amount = 10; }\n        var hsl = this.toHsl();\n        hsl.s += amount / 100;\n        hsl.s = clamp01(hsl.s);\n        return new TinyColor(hsl);\n    };\n    /**\n     * Completely desaturates a color into greyscale.\n     * Same as calling `desaturate(100)`\n     */\n    TinyColor.prototype.greyscale = function () {\n        return this.desaturate(100);\n    };\n    /**\n     * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n     * Values outside of this range will be wrapped into this range.\n     */\n    TinyColor.prototype.spin = function (amount) {\n        var hsl = this.toHsl();\n        var hue = (hsl.h + amount) % 360;\n        hsl.h = hue < 0 ? 360 + hue : hue;\n        return new TinyColor(hsl);\n    };\n    /**\n     * Mix the current color a given amount with another color, from 0 to 100.\n     * 0 means no mixing (return current color).\n     */\n    TinyColor.prototype.mix = function (color, amount) {\n        if (amount === void 0) { amount = 50; }\n        var rgb1 = this.toRgb();\n        var rgb2 = new TinyColor(color).toRgb();\n        var p = amount / 100;\n        var rgba = {\n            r: (rgb2.r - rgb1.r) * p + rgb1.r,\n            g: (rgb2.g - rgb1.g) * p + rgb1.g,\n            b: (rgb2.b - rgb1.b) * p + rgb1.b,\n            a: (rgb2.a - rgb1.a) * p + rgb1.a,\n        };\n        return new TinyColor(rgba);\n    };\n    TinyColor.prototype.analogous = function (results, slices) {\n        if (results === void 0) { results = 6; }\n        if (slices === void 0) { slices = 30; }\n        var hsl = this.toHsl();\n        var part = 360 / slices;\n        var ret = [this];\n        for (hsl.h = (hsl.h - ((part * results) >> 1) + 720) % 360; --results;) {\n            hsl.h = (hsl.h + part) % 360;\n            ret.push(new TinyColor(hsl));\n        }\n        return ret;\n    };\n    /**\n     * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js\n     */\n    TinyColor.prototype.complement = function () {\n        var hsl = this.toHsl();\n        hsl.h = (hsl.h + 180) % 360;\n        return new TinyColor(hsl);\n    };\n    TinyColor.prototype.monochromatic = function (results) {\n        if (results === void 0) { results = 6; }\n        var hsv = this.toHsv();\n        var h = hsv.h;\n        var s = hsv.s;\n        var v = hsv.v;\n        var res = [];\n        var modification = 1 / results;\n        while (results--) {\n            res.push(new TinyColor({ h: h, s: s, v: v }));\n            v = (v + modification) % 1;\n        }\n        return res;\n    };\n    TinyColor.prototype.splitcomplement = function () {\n        var hsl = this.toHsl();\n        var h = hsl.h;\n        return [\n            this,\n            new TinyColor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),\n            new TinyColor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l }),\n        ];\n    };\n    /**\n     * Compute how the color would appear on a background\n     */\n    TinyColor.prototype.onBackground = function (background) {\n        var fg = this.toRgb();\n        var bg = new TinyColor(background).toRgb();\n        return new TinyColor({\n            r: bg.r + (fg.r - bg.r) * fg.a,\n            g: bg.g + (fg.g - bg.g) * fg.a,\n            b: bg.b + (fg.b - bg.b) * fg.a,\n        });\n    };\n    /**\n     * Alias for `polyad(3)`\n     */\n    TinyColor.prototype.triad = function () {\n        return this.polyad(3);\n    };\n    /**\n     * Alias for `polyad(4)`\n     */\n    TinyColor.prototype.tetrad = function () {\n        return this.polyad(4);\n    };\n    /**\n     * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)\n     * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...\n     */\n    TinyColor.prototype.polyad = function (n) {\n        var hsl = this.toHsl();\n        var h = hsl.h;\n        var result = [this];\n        var increment = 360 / n;\n        for (var i = 1; i < n; i++) {\n            result.push(new TinyColor({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));\n        }\n        return result;\n    };\n    /**\n     * compare color vs current color\n     */\n    TinyColor.prototype.equals = function (color) {\n        return this.toRgbString() === new TinyColor(color).toRgbString();\n    };\n    return TinyColor;\n}());\nexport { TinyColor };\n// kept for backwards compatability with v1\nexport function tinycolor(color, opts) {\n    if (color === void 0) { color = ''; }\n    if (opts === void 0) { opts = {}; }\n    return new TinyColor(color, opts);\n}\n","import { computed } from 'vue'\nimport { TinyColor } from '@ctrl/tinycolor'\nimport { useDisabled, useNamespace } from '@element-plus/hooks'\nimport type { ButtonProps } from './button'\n\nexport function darken(color: TinyColor, amount = 20) {\n  return color.mix('#141414', amount).toString()\n}\n\nexport function useButtonCustomStyle(props: ButtonProps) {\n  const _disabled = useDisabled()\n  const ns = useNamespace('button')\n\n  // calculate hover & active color by custom color\n  // only work when custom color\n  return computed(() => {\n    let styles: Record<string, string> = {}\n\n    const buttonColor = props.color\n\n    if (buttonColor) {\n      const color = new TinyColor(buttonColor)\n      const activeBgColor = props.dark\n        ? color.tint(20).toString()\n        : darken(color, 20)\n\n      if (props.plain) {\n        styles = ns.cssVarBlock({\n          'bg-color': props.dark\n            ? darken(color, 90)\n            : color.tint(90).toString(),\n          'text-color': buttonColor,\n          'border-color': props.dark\n            ? darken(color, 50)\n            : color.tint(50).toString(),\n          'hover-text-color': `var(${ns.cssVarName('color-white')})`,\n          'hover-bg-color': buttonColor,\n          'hover-border-color': buttonColor,\n          'active-bg-color': activeBgColor,\n          'active-text-color': `var(${ns.cssVarName('color-white')})`,\n          'active-border-color': activeBgColor,\n        })\n\n        if (_disabled.value) {\n          styles[ns.cssVarBlockName('disabled-bg-color')] = props.dark\n            ? darken(color, 90)\n            : color.tint(90).toString()\n          styles[ns.cssVarBlockName('disabled-text-color')] = props.dark\n            ? darken(color, 50)\n            : color.tint(50).toString()\n          styles[ns.cssVarBlockName('disabled-border-color')] = props.dark\n            ? darken(color, 80)\n            : color.tint(80).toString()\n        }\n      } else {\n        const hoverBgColor = props.dark\n          ? darken(color, 30)\n          : color.tint(30).toString()\n        const textColor = color.isDark()\n          ? `var(${ns.cssVarName('color-white')})`\n          : `var(${ns.cssVarName('color-black')})`\n        styles = ns.cssVarBlock({\n          'bg-color': buttonColor,\n          'text-color': textColor,\n          'border-color': buttonColor,\n          'hover-bg-color': hoverBgColor,\n          'hover-text-color': textColor,\n          'hover-border-color': hoverBgColor,\n          'active-bg-color': activeBgColor,\n          'active-border-color': activeBgColor,\n        })\n\n        if (_disabled.value) {\n          const disabledButtonColor = props.dark\n            ? darken(color, 50)\n            : color.tint(50).toString()\n          styles[ns.cssVarBlockName('disabled-bg-color')] = disabledButtonColor\n          styles[ns.cssVarBlockName('disabled-text-color')] = props.dark\n            ? 'rgba(255, 255, 255, 0.5)'\n            : `var(${ns.cssVarName('color-white')})`\n          styles[ns.cssVarBlockName('disabled-border-color')] =\n            disabledButtonColor\n        }\n      }\n    }\n\n    return styles\n  })\n}\n","import { unref, watch } from 'vue'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { MaybeRef } from '@vueuse/core'\n\ntype DeprecationParam = {\n  from: string\n  replacement: string\n  scope: string\n  version: string\n  ref: string\n  type?: 'API' | 'Slot' | 'Event'\n}\n\nexport const useDeprecated = (\n  { from, replacement, scope, version, ref, type = 'API' }: DeprecationParam,\n  condition: MaybeRef<boolean>\n) => {\n  watch(\n    () => unref(condition),\n    (val) => {\n      if (val) {\n        debugWarn(\n          scope,\n          `${type} ${from} is about to be deprecated in version ${version}, please use ${replacement} instead.\nFor more detail, please visit: ${ref}\n`\n        )\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n}\n","import type { InjectionKey } from 'vue'\n\nimport type { ButtonProps } from '@element-plus/components/button'\n\nexport interface ButtonGroupContext {\n  size?: ButtonProps['size']\n  type?: ButtonProps['type']\n}\n\nexport const buttonGroupContextKey: InjectionKey<ButtonGroupContext> = Symbol(\n  'buttonGroupContextKey'\n)\n","import { computed, inject, unref } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { InjectionKey, Ref } from 'vue'\nimport type { MaybeRef } from '@vueuse/core'\n\nexport type ElIdInjectionContext = {\n  prefix: number\n  current: number\n}\n\nconst defaultIdInjection = {\n  prefix: Math.floor(Math.random() * 10000),\n  current: 0,\n}\n\nexport const ID_INJECTION_KEY: InjectionKey<ElIdInjectionContext> =\n  Symbol('elIdInjection')\n\nexport const useId = (deterministicId?: MaybeRef<string>): Ref<string> => {\n  const idInjection = inject(ID_INJECTION_KEY, defaultIdInjection)\n\n  if (!isClient && idInjection === defaultIdInjection) {\n    debugWarn(\n      'IdInjection',\n      `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed\nusage: app.provide(ID_INJECTION_KEY, {\n  prefix: number,\n  current: number,\n})`\n    )\n  }\n\n  const idRef = computed(\n    () =>\n      unref(deterministicId) ||\n      `el-id-${idInjection.prefix}-${idInjection.current++}`\n  )\n\n  return idRef\n}\n","import {\n  computed,\n  inject,\n  onMounted,\n  onUnmounted,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport { formContextKey, formItemContextKey } from '@element-plus/tokens'\nimport { useId } from '../use-id'\nimport type { FormItemContext } from '@element-plus/tokens'\nimport type { ComputedRef, Ref, WatchStopHandle } from 'vue'\n\nexport const useFormItem = () => {\n  const form = inject(formContextKey, undefined)\n  const formItem = inject(formItemContextKey, undefined)\n  return {\n    form,\n    formItem,\n  }\n}\n\nexport type IUseFormItemInputCommonProps = {\n  id?: string\n  label?: string | number | boolean | Record<string, any>\n}\n\nexport const useFormItemInputId = (\n  props: Partial<IUseFormItemInputCommonProps>,\n  {\n    formItemContext,\n    disableIdGeneration,\n    disableIdManagement,\n  }: {\n    formItemContext?: FormItemContext\n    disableIdGeneration?: ComputedRef<boolean> | Ref<boolean>\n    disableIdManagement?: ComputedRef<boolean> | Ref<boolean>\n  }\n) => {\n  if (!disableIdGeneration) {\n    disableIdGeneration = ref<boolean>(false)\n  }\n  if (!disableIdManagement) {\n    disableIdManagement = ref<boolean>(false)\n  }\n\n  const inputId = ref<string>()\n  let idUnwatch: WatchStopHandle | undefined = undefined\n\n  const isLabeledByFormItem = computed<boolean>(() => {\n    return !!(\n      !props.label &&\n      formItemContext &&\n      formItemContext.inputIds &&\n      formItemContext.inputIds?.length <= 1\n    )\n  })\n\n  // Generate id for ElFormItem label if not provided as prop\n  onMounted(() => {\n    idUnwatch = watch(\n      [toRef(props, 'id'), disableIdGeneration] as any,\n      ([id, disableIdGeneration]: [string, boolean]) => {\n        const newId = id ?? (!disableIdGeneration ? useId().value : undefined)\n        if (newId !== inputId.value) {\n          if (formItemContext?.removeInputId) {\n            inputId.value && formItemContext.removeInputId(inputId.value)\n            if (!disableIdManagement?.value && !disableIdGeneration && newId) {\n              formItemContext.addInputId(newId)\n            }\n          }\n          inputId.value = newId\n        }\n      },\n      { immediate: true }\n    )\n  })\n\n  onUnmounted(() => {\n    idUnwatch && idUnwatch()\n    if (formItemContext?.removeInputId) {\n      inputId.value && formItemContext.removeInputId(inputId.value)\n    }\n  })\n\n  return {\n    isLabeledByFormItem,\n    inputId,\n  }\n}\n","<template>\n  <button\n    ref=\"_ref\"\n    :class=\"[\n      ns.b(),\n      ns.m(_type),\n      ns.m(_size),\n      ns.is('disabled', _disabled),\n      ns.is('loading', loading),\n      ns.is('plain', plain),\n      ns.is('round', round),\n      ns.is('circle', circle),\n      ns.is('text', text),\n      ns.is('link', link),\n      ns.is('has-bg', bg),\n    ]\"\n    :aria-disabled=\"_disabled || loading\"\n    :disabled=\"_disabled || loading\"\n    :autofocus=\"autofocus\"\n    :type=\"nativeType\"\n    :style=\"buttonStyle\"\n    @click=\"handleClick\"\n  >\n    <template v-if=\"loading\">\n      <slot v-if=\"$slots.loading\" name=\"loading\" />\n      <el-icon v-else :class=\"ns.is('loading')\">\n        <component :is=\"loadingIcon\" />\n      </el-icon>\n    </template>\n    <el-icon v-else-if=\"icon || $slots.icon\">\n      <component :is=\"icon\" v-if=\"icon\" />\n      <slot v-else name=\"icon\" />\n    </el-icon>\n    <span\n      v-if=\"$slots.default\"\n      :class=\"{ [ns.em('text', 'expand')]: shouldAddSpace }\"\n    >\n      <slot />\n    </span>\n  </button>\n</template>\n\n<script lang=\"ts\" setup>\nimport { Text, computed, inject, ref, useSlots } from 'vue'\nimport { ElIcon } from '@element-plus/components/icon'\nimport {\n  useDeprecated,\n  useDisabled,\n  useFormItem,\n  useGlobalConfig,\n  useNamespace,\n  useSize,\n} from '@element-plus/hooks'\nimport { buttonGroupContextKey } from '@element-plus/tokens'\nimport { buttonEmits, buttonProps } from './button'\nimport { useButtonCustomStyle } from './button-custom'\n\ndefineOptions({\n  name: 'ElButton',\n})\n\nconst props = defineProps(buttonProps)\nconst emit = defineEmits(buttonEmits)\nconst slots = useSlots()\n\nuseDeprecated(\n  {\n    from: 'type.text',\n    replacement: 'type.link',\n    version: '3.0.0',\n    scope: 'props',\n    ref: 'https://element-plus.org/en-US/component/button.html#button-attributes',\n  },\n  computed(() => props.type === 'text')\n)\n\nconst buttonGroupContext = inject(buttonGroupContextKey, undefined)\nconst globalConfig = useGlobalConfig('button')\nconst ns = useNamespace('button')\nconst { form } = useFormItem()\nconst _size = useSize(computed(() => buttonGroupContext?.size))\nconst _disabled = useDisabled()\nconst _ref = ref<HTMLButtonElement>()\n\nconst _type = computed(() => props.type || buttonGroupContext?.type || '')\nconst autoInsertSpace = computed(\n  () => props.autoInsertSpace ?? globalConfig.value?.autoInsertSpace ?? false\n)\n\n// add space between two characters in Chinese\nconst shouldAddSpace = computed(() => {\n  const defaultSlot = slots.default?.()\n  if (autoInsertSpace.value && defaultSlot?.length === 1) {\n    const slot = defaultSlot[0]\n    if (slot?.type === Text) {\n      const text = slot.children as string\n      return /^\\p{Unified_Ideograph}{2}$/u.test(text.trim())\n    }\n  }\n  return false\n})\n\nconst buttonStyle = useButtonCustomStyle(props)\n\nconst handleClick = (evt: MouseEvent) => {\n  if (props.nativeType === 'reset') {\n    form?.resetFields()\n  }\n  emit('click', evt)\n}\n\ndefineExpose({\n  /** @description button html element */\n  ref: _ref,\n  /** @description button size */\n  size: _size,\n  /** @description button type */\n  type: _type,\n  /** @description button disabled */\n  disabled: _disabled,\n  /** @description whether adding space */\n  shouldAddSpace,\n})\n</script>\n","import { buttonProps } from './button'\n\nimport type { ExtractPropTypes } from 'vue'\nimport type buttonGroup from './button-group.vue'\n\nexport const buttonGroupProps = {\n  size: buttonProps.size,\n  type: buttonProps.type,\n} as const\nexport type ButtonGroupProps = ExtractPropTypes<typeof buttonGroupProps>\n\nexport type ButtonGroupInstance = InstanceType<typeof buttonGroup>\n","<template>\n  <div :class=\"`${ns.b('group')}`\">\n    <slot />\n  </div>\n</template>\n<script lang=\"ts\" setup>\nimport { provide, reactive, toRef } from 'vue'\nimport { buttonGroupContextKey } from '@element-plus/tokens'\nimport { useNamespace } from '@element-plus/hooks'\nimport { buttonGroupProps } from './button-group'\n\ndefineOptions({\n  name: 'ElButtonGroup',\n})\nconst props = defineProps(buttonGroupProps)\nprovide(\n  buttonGroupContextKey,\n  reactive({\n    size: toRef(props, 'size'),\n    type: toRef(props, 'type'),\n  })\n)\nconst ns = useNamespace('button')\n</script>\n","import { withInstall, withNoopInstall } from '@element-plus/utils'\nimport Button from './src/button.vue'\nimport ButtonGroup from './src/button-group.vue'\n\nexport const ElButton = withInstall(Button, {\n  ButtonGroup,\n})\nexport const ElButtonGroup = withNoopInstall(ButtonGroup)\nexport default ElButton\n\nexport * from './src/button'\n","import { noop, isClient, isString, tryOnScopeDispose, tryOnMounted, promiseTimeout, tryOnBeforeMount, increaseWithUnit, clamp, useTimeoutFn, pausableWatch, createEventHook, isFunction, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, containsProp, until, isDef, throttleFilter, useDebounceFn, useThrottleFn, isObject, isNumber, useIntervalFn, syncRef, objectPick, tryOnUnmounted, isIOS, watchWithFilter, identity } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, watchEffect, computed, inject, unref, watch, getCurrentInstance, customRef, onUpdated, reactive, shallowRef, onMounted, markRaw, getCurrentScope, isVue2, set, del, readonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nconst createUnrefFn = (fn) => {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => unref(i)));\n  };\n};\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = unref(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let event;\n  let listener;\n  let options;\n  if (isString(args[0])) {\n    [event, listener, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, event, listener, options] = args;\n  }\n  if (!target)\n    return noop;\n  let cleanup = noop;\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (!el)\n      return;\n    el.addEventListener(event, listener, options);\n    cleanup = () => {\n      el.removeEventListener(event, listener, options);\n      cleanup = noop;\n    };\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore, capture = true } = options;\n  if (!window)\n    return;\n  const shouldListen = ref(true);\n  let fallback;\n  const listener = (event) => {\n    window.clearTimeout(fallback);\n    const el = unrefElement(target);\n    const composedPath = event.composedPath();\n    if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value)\n      return;\n    if (ignore && ignore.length > 0) {\n      if (ignore.some((target2) => {\n        const el2 = unrefElement(target2);\n        return el2 && (event.target === el2 || composedPath.includes(el2));\n      }))\n        return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen.value = !!el && !e.composedPath().includes(el);\n    }, { passive: true }),\n    useEventListener(window, \"pointerup\", (e) => {\n      fallback = window.setTimeout(() => listener(e), 50);\n    }, { passive: true })\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nvar __defProp$h = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$h = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$j.call(b, prop))\n      __defNormalProp$h(a, prop, b[prop]);\n  if (__getOwnPropSymbols$j)\n    for (var prop of __getOwnPropSymbols$j(b)) {\n      if (__propIsEnum$j.call(b, prop))\n        __defNormalProp$h(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nconst createKeyPredicate = (keyFilter) => {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  else if (keyFilter)\n    return () => true;\n  else\n    return () => false;\n};\nfunction onKeyStroke(key, handler, options = {}) {\n  const { target = defaultWindow, eventName = \"keydown\", passive = false } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$h({}, options), { eventName: \"keydown\" }));\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$h({}, options), { eventName: \"keypress\" }));\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$8(__spreadValues$h({}, options), { eventName: \"keyup\" }));\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  const elementRef = computed(() => unrefElement(target));\n  let timeout = null;\n  function clear() {\n    if (timeout != null) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  }\n  function onDown(ev) {\n    var _a;\n    clear();\n    timeout = setTimeout(() => handler(ev), (_a = options == null ? void 0 : options.delay) != null ? _a : DEFAULT_DELAY);\n  }\n  useEventListener(elementRef, \"pointerdown\", onDown);\n  useEventListener(elementRef, \"pointerup\", clear);\n  useEventListener(elementRef, \"pointerleave\", clear);\n}\n\nconst isFocusedElementEditable = () => {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n};\nconst isTypedCharValid = ({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) => {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  return false;\n};\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  const { window = defaultWindow } = options;\n  const counter = ref(0);\n  if (window) {\n    useEventListener(window, \"blur\", () => counter.value += 1, true);\n    useEventListener(window, \"focus\", () => counter.value += 1, true);\n  }\n  return computed(() => {\n    counter.value;\n    return window == null ? void 0 : window.document.activeElement;\n  });\n}\n\nfunction useAsyncQueue(tasks, options = {}) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop\n  } = options;\n  const promiseState = {\n    pending: \"pending\",\n    rejected: \"rejected\",\n    fulfilled: \"fulfilled\"\n  };\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      return curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n    }).catch((e) => {\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    resetOnExecute = true,\n    shallow = true\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = ref(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n    } catch (e) {\n      error.value = e;\n      onError(e);\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  return {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = unref(target);\n        if (_target === void 0 || _target === null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  watch(target, execute, { immediate: true });\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery({ navigator = defaultNavigator } = {}) {\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = navigator && \"getBattery\" in navigator;\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      for (const event of events)\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = Boolean(window && \"matchMedia\" in window);\n  let mediaQuery;\n  const matches = ref(false);\n  const update = () => {\n    if (!isSupported)\n      return;\n    if (!mediaQuery)\n      mediaQuery = window.matchMedia(query);\n    matches.value = mediaQuery.matches;\n  };\n  tryOnBeforeMount(() => {\n    update();\n    if (!mediaQuery)\n      return;\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", update);\n    else\n      mediaQuery.addListener(update);\n    tryOnScopeDispose(() => {\n      if (\"removeEventListener\" in mediaQuery)\n        mediaQuery.removeEventListener(\"change\", update);\n      else\n        mediaQuery.removeListener(update);\n    });\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\n\nvar __defProp$g = Object.defineProperty;\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$g = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$i.call(b, prop))\n      __defNormalProp$g(a, prop, b[prop]);\n  if (__getOwnPropSymbols$i)\n    for (var prop of __getOwnPropSymbols$i(b)) {\n      if (__propIsEnum$i.call(b, prop))\n        __defNormalProp$g(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greater = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greater(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return __spreadValues$g({\n    greater,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    }\n  }, shortcutMethods);\n}\n\nconst useBroadcastChannel = (options) => {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = window && \"BroadcastChannel\" in window;\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = ref(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n};\n\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\n  const buildState = (trigger) => {\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window == null ? void 0 : window.location) || {};\n    return {\n      trigger,\n      state: state2,\n      length,\n      hash,\n      host,\n      hostname,\n      href,\n      origin,\n      pathname,\n      port,\n      protocol,\n      search\n    };\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction useClamp(value, min, max) {\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, unref(min), unref(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, unref(min), unref(max));\n    }\n  });\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const events = [\"copy\", \"cut\"];\n  const isSupported = Boolean(navigator && \"clipboard\" in navigator);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    navigator.clipboard.readText().then((value) => {\n      text.value = value;\n    });\n  }\n  if (isSupported && read) {\n    for (const event of events)\n      useEventListener(event, updateText);\n  }\n  async function copy(value = unref(source)) {\n    if (isSupported && value != null) {\n      await navigator.clipboard.writeText(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\n_global[globalKey] = _global[globalKey] || {};\nconst handlers = _global[globalKey];\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : Array.isArray(rawInit) ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nfunction useStorage(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = unref(initialValue);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, () => write(data.value), { flush, deep, eventFilter });\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", update);\n  update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null)\n        storage.removeItem(key);\n      else\n        storage.setItem(key, serializer.write(v));\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      const rawValue = event ? event.newValue : storage.getItem(key);\n      if (rawValue == null) {\n        if (writeDefaults && rawInit !== null)\n          storage.setItem(key, serializer.write(rawInit));\n        return rawInit;\n      } else if (typeof rawValue !== \"string\") {\n        return rawValue;\n      } else {\n        return serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    } finally {\n      resumeWatch();\n    }\n  }\n  function update(event) {\n    if (event && event.key !== key)\n      return;\n    data.value = read(event);\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nvar __defProp$f = Object.defineProperty;\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$f = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$h.call(b, prop))\n      __defNormalProp$f(a, prop, b[prop]);\n  if (__getOwnPropSymbols$h)\n    for (var prop of __getOwnPropSymbols$h(b)) {\n      if (__propIsEnum$h.call(b, prop))\n        __defNormalProp$f(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef\n  } = options;\n  const modes = __spreadValues$f({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, options.modes || {});\n  const preferredDark = usePreferredDark({ window });\n  const preferredMode = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? ref(\"auto\") : useStorage(storageKey, \"auto\", storage, { window, listenToStorageChanges }));\n  const state = computed({\n    get() {\n      return store.value === \"auto\" ? preferredMode.value : store.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  const updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector2, attribute2, value) => {\n    const el = window == null ? void 0 : window.document.querySelector(selector2);\n    if (!el)\n      return;\n    if (attribute2 === \"class\") {\n      const current = value.split(/\\s/g);\n      Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n        if (current.includes(v))\n          el.classList.add(v);\n        else\n          el.classList.remove(v);\n      });\n    } else {\n      el.setAttribute(attribute2, value);\n    }\n  });\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  return state;\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, { window = defaultWindow } = {}) {\n  const variable = ref(\"\");\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  watch([elRef, () => unref(prop)], ([el, prop2]) => {\n    if (el && window)\n      variable.value = window.getComputedStyle(el).getPropertyValue(prop2);\n  }, { immediate: true });\n  watch(variable, (val) => {\n    var _a;\n    if ((_a = elRef.value) == null ? void 0 : _a.style)\n      elRef.value.style.setProperty(unref(prop), val);\n  });\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const count = ref(0);\n  onUpdated(() => {\n    count.value += 1;\n  });\n  onMounted(() => {\n    count.value += 1;\n  });\n  return computed(() => {\n    count.value;\n    return vm.proxy.$el;\n  });\n}\n\nfunction useCycleList(list, options) {\n  var _a;\n  const state = shallowRef((_a = options == null ? void 0 : options.initialValue) != null ? _a : list[0]);\n  const index = computed({\n    get() {\n      var _a2;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const length = list.length;\n    const index2 = (i % length + length) % length;\n    const value = list[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nvar __defProp$e = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$e = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$g.call(b, prop))\n      __defNormalProp$e(a, prop, b[prop]);\n  if (__getOwnPropSymbols$g)\n    for (var prop of __getOwnPropSymbols$g(b)) {\n      if (__propIsEnum$g.call(b, prop))\n        __defNormalProp$e(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode(__spreadProps$7(__spreadValues$e({}, options), {\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\");\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  }));\n  const preferredDark = usePreferredDark({ window });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      if (v === preferredDark.value)\n        mode.value = \"auto\";\n      else\n        mode.value = v ? \"dark\" : \"light\";\n    }\n  });\n  return isDark;\n}\n\nconst fnClone = (v) => JSON.parse(JSON.stringify(v));\nconst fnBypass = (v) => v;\nconst fnSetSource = (source, value) => source.value = value;\nfunction defaultDump(clone) {\n  return clone ? isFunction(clone) ? clone : fnClone : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? isFunction(clone) ? clone : fnClone : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Infinity);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nvar __defProp$d = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$d = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$f.call(b, prop))\n      __defNormalProp$d(a, prop, b[prop]);\n  if (__getOwnPropSymbols$f)\n    for (var prop of __getOwnPropSymbols$f(b)) {\n      if (__propIsEnum$f.call(b, prop))\n        __defNormalProp$d(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(source, commit, { deep, flush, eventFilter: composedFilter });\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, __spreadProps$6(__spreadValues$d({}, options), { clone: options.clone || deep, setSource }));\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return __spreadProps$6(__spreadValues$d({}, manualHistory), {\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  });\n}\n\nvar __defProp$c = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$c = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$e.call(b, prop))\n      __defNormalProp$c(a, prop, b[prop]);\n  if (__getOwnPropSymbols$e)\n    for (var prop of __getOwnPropSymbols$e(b)) {\n      if (__propIsEnum$e.call(b, prop))\n        __defNormalProp$c(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, __spreadProps$5(__spreadValues$c({}, options), { eventFilter: filter }));\n  return __spreadValues$c({}, history);\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {\n      acceleration.value = event.acceleration;\n      accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n      rotationRate.value = event.rotationRate;\n      interval.value = event.interval;\n    });\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = Boolean(window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nconst DEVICE_PIXEL_RATIO_SCALES = [\n  1,\n  1.325,\n  1.4,\n  1.5,\n  1.8,\n  2,\n  2.4,\n  2.5,\n  2.75,\n  3,\n  3.5,\n  4\n];\nfunction useDevicePixelRatio({\n  window = defaultWindow\n} = {}) {\n  if (!window) {\n    return {\n      pixelRatio: ref(1)\n    };\n  }\n  const pixelRatio = ref(window.devicePixelRatio);\n  const handleDevicePixelRatio = () => {\n    pixelRatio.value = window.devicePixelRatio;\n  };\n  useEventListener(window, \"resize\", handleDevicePixelRatio, { passive: true });\n  DEVICE_PIXEL_RATIO_SCALES.forEach((dppx) => {\n    const mqlMin = useMediaQuery(`screen and (min-resolution: ${dppx}dppx)`);\n    const mqlMax = useMediaQuery(`screen and (max-resolution: ${dppx}dppx)`);\n    watch([mqlMin, mqlMax], handleDevicePixelRatio);\n  });\n  return { pixelRatio };\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = Boolean(navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  let isSupported = false;\n  const permissionGranted = ref(false);\n  async function update() {\n    if (!isSupported)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n  }\n  async function ensurePermissions() {\n    if (!isSupported)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      stream.getTracks().forEach((t) => t.stop());\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (navigator) {\n    isSupported = Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n    if (isSupported) {\n      if (requestPermissions)\n        ensurePermissions();\n      useEventListener(navigator.mediaDevices, \"devicechange\", update);\n      update();\n    }\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = Boolean((_b = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _b.getDisplayMedia);\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nvar __defProp$b = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const draggingElement = (_a = options.draggingElement) != null ? _a : defaultWindow;\n  const position = ref((_b = options.initialValue) != null ? _b : { x: 0, y: 0 });\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (options.pointerTypes)\n      return options.pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (unref(options.preventDefault))\n      e.preventDefault();\n    if (unref(options.stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (unref(options.exact) && e.target !== unref(target))\n      return;\n    const rect = unref(target).getBoundingClientRect();\n    const pos = {\n      x: e.pageX - rect.left,\n      y: e.pageY - rect.top\n    };\n    if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    position.value = {\n      x: e.pageX - pressedDelta.value.x,\n      y: e.pageY - pressedDelta.value.y\n    };\n    (_a2 = options.onMove) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    useEventListener(target, \"pointerdown\", start, true);\n    useEventListener(draggingElement, \"pointermove\", move, true);\n    useEventListener(draggingElement, \"pointerup\", end, true);\n  }\n  return __spreadProps$4(__spreadValues$b({}, toRefs(position)), {\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(() => `left:${position.value.x}px;top:${position.value.y}px;`)\n  });\n}\n\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useResizeObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\n  let observer;\n  const isSupported = window && \"ResizeObserver\" in window;\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported && window && el) {\n      observer = new ResizeObserver(callback);\n      observer.observe(el, observerOptions);\n    }\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  let rafId = null;\n  function loop() {\n    if (!isActive.value || !window)\n      return;\n    fn();\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useElementByPoint(options) {\n  const element = ref(null);\n  const { x, y } = options;\n  const controls = useRafFn(() => {\n    element.value = document.elementFromPoint(unref(x), unref(y));\n  });\n  return __spreadValues$a({\n    element\n  }, controls);\n}\n\nfunction useElementHover(el) {\n  const isHovered = ref(false);\n  useEventListener(el, \"mouseenter\", () => isHovered.value = true);\n  useEventListener(el, \"mouseleave\", () => isHovered.value = false);\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  useResizeObserver(target, ([entry]) => {\n    width.value = entry.contentRect.width;\n    height.value = entry.contentRect.height;\n  }, options);\n  watch(() => unrefElement(target), (ele) => {\n    width.value = ele ? initialSize.width : 0;\n    height.value = ele ? initialSize.height : 0;\n  });\n  return {\n    width,\n    height\n  };\n}\n\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\n  const elementIsVisible = ref(false);\n  const testBounding = () => {\n    if (!window)\n      return;\n    const document = window.document;\n    if (!unref(element)) {\n      elementIsVisible.value = false;\n    } else {\n      const rect = unref(element).getBoundingClientRect();\n      elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;\n    }\n  };\n  tryOnMounted(testBounding);\n  if (window)\n    tryOnMounted(() => useEventListener(unref(scrollTarget) || window, \"scroll\", testBounding, { capture: false, passive: true }));\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || [];\n    listeners.push(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    const index = listeners.indexOf(listener);\n    if (index > -1)\n      listeners.splice(index, 1);\n    if (!listeners.length)\n      events.delete(key);\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = ref(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = Boolean(typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = isRef(newIcon) ? newIcon : ref(newIcon);\n  const applyIcon = (icon) => {\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(favicon, (i, o) => {\n    if (isString(i) && i !== o)\n      applyIcon(i);\n  }, { immediate: true });\n  return favicon;\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\",\n  formData: \"multipart/form-data\"\n};\nfunction isFetchOptions(obj) {\n  return containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\n}\nfunction headersToObject(headers) {\n  if (headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction createFetch(config = {}) {\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => config.baseUrl ? joinPaths(unref(config.baseUrl), unref(url)) : unref(url));\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = __spreadValues$9(__spreadValues$9({}, options), args[0]);\n      } else {\n        fetchOptions = __spreadProps$3(__spreadValues$9(__spreadValues$9({}, fetchOptions), args[0]), {\n          headers: __spreadValues$9(__spreadValues$9({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\n        });\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1]))\n      options = __spreadValues$9(__spreadValues$9({}, options), args[1]);\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = { immediate: true, refetch: false, timeout: 0 };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = __spreadValues$9(__spreadValues$9({}, options), args[0]);\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = __spreadValues$9(__spreadValues$9({}, options), args[1]);\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort && controller)\n      controller.abort();\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    controller = void 0;\n    if (supportsAbort) {\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = __spreadProps$3(__spreadValues$9({}, fetchOptions), {\n        signal: controller.signal\n      });\n    }\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(unref(config.payload)) : unref(config.payload);\n    }\n    let isCanceled = false;\n    const context = { url: unref(url), options: __spreadValues$9(__spreadValues$9({}, defaultFetchOptions), fetchOptions), cancel: () => {\n      isCanceled = true;\n    } };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(context.url, __spreadProps$3(__spreadValues$9(__spreadValues$9({}, defaultFetchOptions), context.options), {\n        headers: __spreadValues$9(__spreadValues$9({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\n      })).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (options.afterFetch && statusCode.value >= 200 && statusCode.value < 300)\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\n        data.value = responseData;\n        if (!fetchResponse.ok)\n          throw new Error(fetchResponse.statusText);\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError)\n          ({ data: responseData, error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\n        data.value = responseData;\n        error.value = errorData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  watch(() => [\n    unref(url),\n    unref(options.refetch)\n  ], () => unref(options.refetch) && execute(), { deep: true });\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(() => [\n            unref(config.payload),\n            unref(options.refetch)\n          ], () => unref(options.refetch) && execute(), { deep: true });\n        }\n        if (!payloadType && unref(payload) && Object.getPrototypeOf(unref(payload)) === Object.prototype)\n          config.payloadType = \"json\";\n        return __spreadProps$3(__spreadValues$9({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return __spreadProps$3(__spreadValues$9({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    setTimeout(execute, 0);\n  return __spreadProps$3(__spreadValues$9({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  });\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = unref(options);\n  const window = _window;\n  const isSupported = Boolean(window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported)\n      return;\n    const [handle] = await window.showOpenFilePicker(__spreadValues$8(__spreadValues$8({}, unref(options)), _options));\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$8(__spreadValues$8({}, unref(options)), _options));\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$8(__spreadValues$8({}, unref(options)), _options));\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    if (unref(dataType) === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    if (unref(dataType) === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    if (unref(dataType) === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => unref(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false } = options;\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed({\n    get() {\n      return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;\n    },\n    set(value) {\n      var _a, _b;\n      if (!value && focused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      if (value && !focused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(targetElement, () => {\n    focused.value = initialValue;\n  }, { immediate: true, flush: \"post\" });\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst functionsMap = [\n  [\n    \"requestFullscreen\",\n    \"exitFullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fullscreenchange\",\n    \"fullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullscreen\",\n    \"webkitExitFullscreen\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullScreen\",\n    \"webkitCancelFullScreen\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCancelFullScreen\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"mozRequestFullScreen\",\n    \"mozCancelFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozfullscreenchange\",\n    \"mozfullscreenerror\"\n  ],\n  [\n    \"msRequestFullscreen\",\n    \"msExitFullscreen\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"MSFullscreenChange\",\n    \"MSFullscreenError\"\n  ]\n];\nfunction useFullscreen(target, options = {}) {\n  const { document = defaultDocument, autoExit = false } = options;\n  const targetRef = target || (document == null ? void 0 : document.querySelector(\"html\"));\n  const isFullscreen = ref(false);\n  let isSupported = false;\n  let map = functionsMap[0];\n  if (!document) {\n    isSupported = false;\n  } else {\n    for (const m of functionsMap) {\n      if (m[1] in document) {\n        map = m;\n        isSupported = true;\n        break;\n      }\n    }\n  }\n  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;\n  async function exit() {\n    if (!isSupported)\n      return;\n    if (document == null ? void 0 : document[ELEMENT])\n      await document[EXIT]();\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported)\n      return;\n    await exit();\n    const target2 = unrefElement(targetRef);\n    if (target2) {\n      await target2[REQUEST]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    if (isFullscreen.value)\n      await exit();\n    else\n      await enter();\n  }\n  if (document) {\n    useEventListener(document, EVENT, () => {\n      isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);\n    }, false);\n  }\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = navigator && \"getGamepads\" in navigator;\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      hapticActuators,\n      index: gamepad.index,\n      mapping: gamepad.mapping,\n      connected: gamepad.connected,\n      timestamp: gamepad.timestamp,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = navigator && \"geolocation\" in navigator;\n  const locatedAt = ref(null);\n  const error = ref(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Infinity,\n    longitude: Infinity,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  if (isSupported) {\n    watcher = navigator.geolocation.watchPosition(updatePosition, (err) => error.value = err, {\n      enableHighAccuracy,\n      maximumAge,\n      timeout\n    });\n  }\n  tryOnScopeDispose(() => {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const onEvent = createFilterWrapper(eventFilter, () => {\n    idle.value = false;\n    lastActive.value = timestamp();\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  });\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n  }\n  timer = setTimeout(() => idle.value = true, timeout);\n  return { idle, lastActive };\n}\n\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    }\n  } = options;\n  const x = ref(0);\n  const y = ref(0);\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  if (element) {\n    const onScrollEnd = useDebounceFn((e) => {\n      isScrolling.value = false;\n      directions.left = false;\n      directions.right = false;\n      directions.top = false;\n      directions.bottom = false;\n      onStop(e);\n    }, throttle + idle);\n    const onScrollHandler = (e) => {\n      const eventTarget = e.target === document ? e.target.documentElement : e.target;\n      const scrollLeft = eventTarget.scrollLeft;\n      directions.left = scrollLeft < x.value;\n      directions.right = scrollLeft > x.value;\n      arrivedState.left = scrollLeft <= 0 + (offset.left || 0);\n      arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0);\n      x.value = scrollLeft;\n      const scrollTop = eventTarget.scrollTop;\n      directions.top = scrollTop < y.value;\n      directions.bottom = scrollTop > y.value;\n      arrivedState.top = scrollTop <= 0 + (offset.top || 0);\n      arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0);\n      y.value = scrollTop;\n      isScrolling.value = true;\n      onScrollEnd(e);\n      onScroll(e);\n    };\n    useEventListener(element, \"scroll\", throttle ? useThrottleFn(onScrollHandler, throttle) : onScrollHandler, eventListenerOptions);\n  }\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions\n  };\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const state = reactive(useScroll(element, __spreadProps$2(__spreadValues$7({}, options), {\n    offset: __spreadValues$7({\n      bottom: (_a = options.distance) != null ? _a : 0\n    }, options.offset)\n  })));\n  watch(() => state.arrivedState.bottom, (v) => {\n    if (v)\n      onLoadMore(state);\n  });\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow\n  } = options;\n  const isSupported = window && \"IntersectionObserver\" in window;\n  let cleanup = noop;\n  const stopWatch = isSupported ? watch(() => ({\n    el: unrefElement(target),\n    root: unrefElement(root)\n  }), ({ el, root: root2 }) => {\n    cleanup();\n    if (!el)\n      return;\n    const observer = new IntersectionObserver(callback, {\n      root: root2,\n      rootMargin,\n      threshold\n    });\n    observer.observe(el);\n    cleanup = () => {\n      observer.disconnect();\n      cleanup = noop;\n    };\n  }, { immediate: true, flush: \"post\" }) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = { toJSON() {\n    return {};\n  }, current };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (code) {\n      if (value)\n        current.add(e.code);\n      else\n        current.delete(e.code);\n    }\n    for (const key2 of values)\n      setRefs(key2, value);\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  if (target) {\n    useEventListener(target, \"keydown\", (e) => {\n      updateRefs(e, true);\n      return onEventFired(e);\n    }, { passive });\n    useEventListener(target, \"keyup\", (e) => {\n      updateRefs(e, false);\n      return onEventFired(e);\n    }, { passive });\n  }\n  const proxy = new Proxy(refs, {\n    get(target2, prop, rec) {\n      if (typeof prop !== \"string\")\n        return Reflect.get(target2, prop, rec);\n      prop = prop.toLowerCase();\n      if (prop in aliasMap)\n        prop = aliasMap[prop];\n      if (!(prop in refs)) {\n        if (/[+_-]/.test(prop)) {\n          const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n          refs[prop] = computed(() => keys.every((key) => unref(proxy[key])));\n        } else {\n          refs[prop] = ref(false);\n        }\n      }\n      const r = Reflect.get(target2, prop, rec);\n      return useReactive ? unref(r) : r;\n    }\n  });\n  return proxy;\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction usingElRef(source, cb) {\n  if (unref(source))\n    cb(unref(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = __spreadValues$6(__spreadValues$6({}, defaultOptions), options);\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = isNumber(track) ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = isNumber(track) ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = unref(target);\n    if (!el)\n      return;\n    const src = unref(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (isString(src))\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = unref(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch(volume, (vol) => {\n    const el = unref(target);\n    if (!el)\n      return;\n    el.volume = vol;\n  });\n  watch(muted, (mute) => {\n    const el = unref(target);\n    if (!el)\n      return;\n    el.muted = mute;\n  });\n  watch(rate, (rate2) => {\n    const el = unref(target);\n    if (!el)\n      return;\n    el.playbackRate = rate2;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = unref(options.tracks);\n    const el = unref(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = unref(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = unref(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = unref(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = unref(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(unref(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, \"waiting\", () => waiting.value = true);\n  useEventListener(target, \"playing\", () => waiting.value = false);\n  useEventListener(target, \"ratechange\", () => rate.value = unref(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = unref(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = unref(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    volume,\n    muted,\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nconst getMapVue2Compat = () => {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => Object.prototype.hasOwnProperty.call(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n};\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = typeof performance !== \"undefined\" && \"memory\" in performance;\n  if (isSupported) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  onMounted(() => {\n    isMounted.value = true;\n  });\n  return isMounted;\n}\n\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    eventFilter\n  } = options;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const mouseHandler = (event) => {\n    if (type === \"page\") {\n      x.value = event.pageX;\n      y.value = event.pageY;\n    } else if (type === \"client\") {\n      x.value = event.clientX;\n      y.value = event.clientY;\n    }\n    sourceType.value = \"mouse\";\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const touch2 = event.touches[0];\n      if (type === \"page\") {\n        x.value = touch2.pageX;\n        y.value = touch2.pageY;\n      } else if (type === \"client\") {\n        x.value = touch2.clientX;\n        y.value = touch2.clientY;\n      }\n      sourceType.value = \"touch\";\n    }\n  };\n  const mouseHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});\n  };\n  const touchHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});\n  };\n  if (window) {\n    useEventListener(window, \"mousemove\", mouseHandlerWrapper, { passive: true });\n    useEventListener(window, \"dragover\", mouseHandlerWrapper, { passive: true });\n    if (touch) {\n      useEventListener(window, \"touchstart\", touchHandlerWrapper, { passive: true });\n      useEventListener(window, \"touchmove\", touchHandlerWrapper, { passive: true });\n      if (resetOnTouchEnds)\n        useEventListener(window, \"touchend\", reset, { passive: true });\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(false);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch([targetRef, x, y], () => {\n      const el = unrefElement(targetRef);\n      if (!el)\n        return;\n      const {\n        left,\n        top,\n        width,\n        height\n      } = el.getBoundingClientRect();\n      elementPositionX.value = left + window.pageXOffset;\n      elementPositionY.value = top + window.pageYOffset;\n      elementHeight.value = height;\n      elementWidth.value = width;\n      const elX = x.value - elementPositionX.value;\n      const elY = y.value - elementPositionY.value;\n      isOutside.value = elX < 0 || elY < 0 || elX > elementWidth.value || elY > elementHeight.value;\n      if (handleOutside || !isOutside.value) {\n        elementX.value = elX;\n        elementY.value = elY;\n      }\n    }, { immediate: true });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\n    useEventListener(window, \"drop\", onReleased, { passive: true });\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useMutationObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$1(_a, [\"window\"]);\n  let observer;\n  const isSupported = window && \"MutationObserver\" in window;\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported && window && el) {\n      observer = new MutationObserver(callback);\n      observer.observe(el, mutationOptions);\n    }\n  }, { immediate: true });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst useNavigatorLanguage = (options = {}) => {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = Boolean(navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n};\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = Boolean(navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(new Date());\n  const update = () => now.value = new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return __spreadValues$5({\n      now\n    }, controls);\n  } else {\n    return now;\n  }\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Infinity,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\n  const pageCount = computed(() => Math.ceil(unref(total) / unref(currentPageSize)));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\n    useEventListener(target, \"pointermove\", handler, { passive: true });\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\n  }\n  return __spreadProps$1(__spreadValues$4({}, toRefs(state)), {\n    isInside\n  });\n}\n\nvar SwipeDirection = /* @__PURE__ */ ((SwipeDirection2) => {\n  SwipeDirection2[\"UP\"] = \"UP\";\n  SwipeDirection2[\"RIGHT\"] = \"RIGHT\";\n  SwipeDirection2[\"DOWN\"] = \"DOWN\";\n  SwipeDirection2[\"LEFT\"] = \"LEFT\";\n  SwipeDirection2[\"NONE\"] = \"NONE\";\n  return SwipeDirection2;\n})(SwipeDirection || {});\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"NONE\" /* NONE */;\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"LEFT\" /* LEFT */ : \"RIGHT\" /* RIGHT */;\n    } else {\n      return diffY.value > 0 ? \"UP\" /* UP */ : \"DOWN\" /* DOWN */;\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = ref(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const filterEvent = (e) => {\n    if (options.pointerTypes)\n      return options.pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!filterEvent(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!filterEvent(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!filterEvent(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nconst useScreenOrientation = (options = {}) => {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = !!(window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n};\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${src}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = unref(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${src}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(() => unref(element), (el) => {\n    if (el) {\n      const ele = el;\n      initialOverflow = ele.style.overflow;\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const ele = unref(element);\n    if (!ele || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(ele, \"touchmove\", preventDefault, { passive: false });\n    }\n    ele.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const ele = unref(element);\n    if (!ele || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    ele.style.overflow = initialOverflow;\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = _navigator && \"canShare\" in _navigator;\n  const share = async (overrideOptions = {}) => {\n    if (isSupported) {\n      const data = __spreadValues$3(__spreadValues$3({}, unref(shareOptions)), unref(overrideOptions));\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = ref(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = Boolean(SpeechRecognition);\n  let recognition;\n  if (isSupported) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = unref(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = unref(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  var _a, _b;\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = Boolean(synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const voiceInfo = {\n    lang: ((_a = options.voice) == null ? void 0 : _a.lang) || \"default\",\n    name: ((_b = options.voice) == null ? void 0 : _b.name) || \"\"\n  };\n  const spokenText = ref(text || \"\");\n  const lang = ref(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = unref(lang);\n    options.voice && (utterance2.voice = options.voice);\n    utterance2.pitch = pitch;\n    utterance2.rate = rate;\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      utterance2.lang = unref(lang);\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  if (isSupported) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    voiceInfo,\n    utterance,\n    error,\n    toggle,\n    speak\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = unref(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => setTimeout(() => read(e), 0));\n  if (storage) {\n    watchWithFilter(data, async () => {\n      try {\n        if (data.value == null)\n          await storage.removeItem(key);\n        else\n          await storage.setItem(key, await serializer.write(data.value));\n      } catch (e) {\n        onError(e);\n      }\n    }, {\n      flush,\n      deep,\n      eventFilter\n    });\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    el.type = \"text/css\";\n    el.id = id;\n    if (options.media)\n      el.media = options.media;\n    document.head.appendChild(el);\n    if (isLoaded.value)\n      return;\n    stop = watch(cssRef, (value) => {\n      el.innerText = value;\n    }, { immediate: true });\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    load();\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  const ranges = new Array(rangeCount);\n  for (let i = 0; i < rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n    ranges[i] = range;\n  }\n  return ranges;\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, __spreadProps(__spreadValues$2({}, options), { eventFilter: filter }));\n  return __spreadValues$2({}, history);\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Infinity, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`\n};\nconst DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    max,\n    updateInterval = 3e4,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER\n  } = options;\n  const { abs, round } = Math;\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\n  function getTimeago(from, now2) {\n    var _a2;\n    const diff = +now2 - +from;\n    const absDiff = abs(diff);\n    if (absDiff < 6e4)\n      return messages.justNow;\n    if (typeof max === \"number\" && absDiff > max)\n      return fullDateFormatter(new Date(from));\n    if (typeof max === \"string\") {\n      const unitMax = (_a2 = UNITS.find((i) => i.name === max)) == null ? void 0 : _a2.max;\n      if (unitMax && absDiff > unitMax)\n        return fullDateFormatter(new Date(from));\n    }\n    for (const unit of UNITS) {\n      if (absDiff < unit.max)\n        return format(diff, unit);\n    }\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  function format(diff, unit) {\n    const val = round(abs(diff) / unit.value);\n    const past = diff > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  const timeAgo = computed(() => getTimeago(new Date(unref(time)), unref(now.value)));\n  if (exposeControls) {\n    return __spreadValues$1({\n      timeAgo\n    }, controls);\n  } else {\n    return timeAgo;\n  }\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval);\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate }) : useIntervalFn(update, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues({\n      timestamp: ts\n    }, controls);\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument,\n    observe = false,\n    titleTemplate = \"%s\"\n  } = options;\n  const title = ref((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  watch(title, (t, o) => {\n    if (isString(t) && t !== o && document)\n      document.title = titleTemplate.replace(\"%s\", t);\n  }, { immediate: true });\n  if (observe && document) {\n    useMutationObserver((_b = document.head) == null ? void 0 : _b.querySelector(\"title\"), () => {\n      if (document && document.title !== title.value)\n        title.value = titleTemplate.replace(\"%s\", document.title);\n    }, { childList: true });\n  }\n  return title;\n}\n\nconst TransitionPresets = {\n  linear: identity,\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction useTransition(source, options = {}) {\n  const {\n    delay = 0,\n    disabled = false,\n    duration = 1e3,\n    onFinished = noop,\n    onStarted = noop,\n    transition = identity\n  } = options;\n  const currentTransition = computed(() => {\n    const t = unref(transition);\n    return isFunction(t) ? t : createEasingFunction(t);\n  });\n  const sourceValue = computed(() => {\n    const s = unref(source);\n    return isNumber(s) ? s : s.map(unref);\n  });\n  const sourceVector = computed(() => isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);\n  const outputVector = ref(sourceVector.value.slice(0));\n  let currentDuration;\n  let diffVector;\n  let endAt;\n  let startAt;\n  let startVector;\n  const { resume, pause } = useRafFn(() => {\n    const now = Date.now();\n    const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);\n    outputVector.value = startVector.map((val, i) => {\n      var _a;\n      return val + ((_a = diffVector[i]) != null ? _a : 0) * currentTransition.value(progress);\n    });\n    if (progress >= 1) {\n      pause();\n      onFinished();\n    }\n  }, { immediate: false });\n  const start = () => {\n    pause();\n    currentDuration = unref(duration);\n    diffVector = outputVector.value.map((n, i) => {\n      var _a, _b;\n      return ((_a = sourceVector.value[i]) != null ? _a : 0) - ((_b = outputVector.value[i]) != null ? _b : 0);\n    });\n    startVector = outputVector.value.slice(0);\n    startAt = Date.now();\n    endAt = startAt + currentDuration;\n    resume();\n    onStarted();\n  };\n  const timeout = useTimeoutFn(start, delay, { immediate: false });\n  watch(sourceVector, () => {\n    if (unref(disabled)) {\n      outputVector.value = sourceVector.value.slice(0);\n    } else {\n      if (unref(delay) <= 0)\n        start();\n      else\n        timeout.start();\n    }\n  }, { deep: true });\n  return computed(() => {\n    const targetVector = unref(disabled) ? sourceVector : outputVector;\n    return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;\n  });\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(state, () => {\n    const params = new URLSearchParams(\"\");\n    Object.keys(state).forEach((key) => {\n      const mapEntry = state[key];\n      if (Array.isArray(mapEntry))\n        mapEntry.forEach((value) => params.append(key, value));\n      else if (removeNullishValues && mapEntry == null)\n        params.delete(key);\n      else if (removeFalsyValues && !mapEntry)\n        params.delete(key);\n      else\n        params.set(key, mapEntry);\n    });\n    write(params);\n  }, { deep: true });\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState({}, \"\", window.location.pathname + constructQuery(params));\n    resume();\n  }\n  function onChanged() {\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b, _c;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const videoDeviceId = ref(options.videoDeviceId);\n  const audioDeviceId = ref(options.audioDeviceId);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = Boolean((_c = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _c.getUserMedia);\n  const stream = shallowRef();\n  function getDeviceOptions(device) {\n    if (device.value === \"none\" || device.value === false)\n      return false;\n    if (device.value == null)\n      return true;\n    return {\n      deviceId: device.value\n    };\n  }\n  async function _start() {\n    if (!isSupported || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(videoDeviceId),\n      audio: getDeviceOptions(audioDeviceId)\n    });\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  watch([videoDeviceId, audioDeviceId], () => {\n    if (autoSwitch.value && stream.value)\n      restart();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    videoDeviceId,\n    audioDeviceId,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c;\n  const {\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$options) == null ? void 0 : _c.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = eventName || event || `update:${key}`;\n  const getValue = () => isDef(props[key]) ? props[key] : defaultValue;\n  if (passive) {\n    const proxy = ref(getValue());\n    watch(() => props[key], (v) => proxy.value = v);\n    watch(proxy, (v) => {\n      if (v !== props[key] || deep)\n        _emit(event, v);\n    }, {\n      deep\n    });\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        _emit(event, value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props)\n    ret[key] = useVModel(props, key, emit, options);\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = typeof navigator !== \"undefined\" && \"vibrate\" in navigator;\n  const patternRef = ref(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(vibrate, interval, {\n      immediate: false,\n      immediateCallback: false\n    });\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const containerRef = ref();\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = (containerHeight) => {\n    if (typeof itemHeight === \"number\")\n      return Math.ceil(containerHeight / itemHeight);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const height = itemHeight(i);\n      sum += height;\n      if (sum >= containerHeight) {\n        capacity = i;\n        break;\n      }\n    }\n    return capacity - start;\n  };\n  const getOffset = (scrollTop) => {\n    if (typeof itemHeight === \"number\")\n      return Math.floor(scrollTop / itemHeight) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const height = itemHeight(i);\n      sum += height;\n      if (sum >= scrollTop) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n  const calculateRange = () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(element.scrollTop);\n      const viewCapacity = getViewCapacity(element.clientHeight);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n  const totalHeight = computed(() => {\n    if (typeof itemHeight === \"number\")\n      return source.value.length * itemHeight;\n    return source.value.reduce((sum, _, index) => sum + itemHeight(index), 0);\n  });\n  const getDistanceTop = (index) => {\n    if (typeof itemHeight === \"number\") {\n      const height2 = index * itemHeight;\n      return height2;\n    }\n    const height = source.value.slice(0, index).reduce((sum, _, i) => sum + itemHeight(i), 0);\n    return height;\n  };\n  const scrollTo = (index) => {\n    if (containerRef.value) {\n      containerRef.value.scrollTop = getDistanceTop(index);\n      calculateRange();\n    }\n  };\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  const containerStyle = { overflowY: \"auto\" };\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\n\nconst useWakeLock = (options = {}) => {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = navigator && \"wakeLock\" in navigator;\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n};\n\nconst useWebNotification = (defaultOptions = {}) => {\n  const {\n    window = defaultWindow\n  } = defaultOptions;\n  const isSupported = !!window && \"Notification\" in window;\n  const notification = ref(null);\n  const requestPermission = async () => {\n    if (!isSupported)\n      return;\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\n      await Notification.requestPermission();\n  };\n  const onClick = createEventHook();\n  const onShow = createEventHook();\n  const onError = createEventHook();\n  const onClose = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported)\n      return;\n    await requestPermission();\n    const options = Object.assign({}, defaultOptions, overrides);\n    notification.value = new Notification(options.title || \"\", options);\n    notification.value.onclick = (event) => onClick.trigger(event);\n    notification.value.onshow = (event) => onShow.trigger(event);\n    notification.value.onerror = (event) => onError.trigger(event);\n    notification.value.onclose = (event) => onClose.trigger(event);\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  tryOnMounted(async () => {\n    if (isSupported)\n      await requestPermission();\n  });\n  tryOnScopeDispose(close);\n  if (isSupported && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n};\n\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const wsRef = ref();\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  const close = (code = 1e3, reason) => {\n    if (!wsRef.value)\n      return;\n    explicitlyClosed = true;\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    const ws = new WebSocket(url, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    explicitlyClosed = false;\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = \"ping\",\n      interval = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(() => send(message, false), interval, { immediate: false });\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (immediate)\n    _init();\n  if (autoClose) {\n    useEventListener(window, \"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    close();\n    retried = 0;\n    _init();\n  };\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(url, workerOptions, options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = function post2(val) {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(val);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    worker.value = new Worker(url, workerOptions);\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nconst jobRunner = (userFunc) => (e) => {\n  const userFuncArgs = e.data[0];\n  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n    postMessage([\"SUCCESS\", result]);\n  }).catch((error) => {\n    postMessage([\"ERROR\", error]);\n  });\n};\n\nconst depsParser = (deps) => {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n};\n\nconst createWorkerBlobUrl = (fn, deps) => {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n};\n\nconst useWebWorkerFn = (fn, options = {}) => {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(() => workerTerminate(\"TIMEOUT_EXPIRED\"), timeout);\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\"[useWebWorkerFn] You can only run one instance of the worker at a time.\");\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n};\n\nfunction useWindowFocus({ window = defaultWindow } = {}) {\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll({ window = defaultWindow } = {}) {\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const x = ref(window.pageXOffset);\n  const y = ref(window.pageYOffset);\n  useEventListener(\"scroll\", () => {\n    x.value = window.pageXOffset;\n    y.value = window.pageYOffset;\n  }, {\n    capture: false,\n    passive: true\n  });\n  return { x, y };\n}\n\nfunction useWindowSize({ window = defaultWindow, initialWidth = Infinity, initialHeight = Infinity } = {}) {\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      width.value = window.innerWidth;\n      height.value = window.innerHeight;\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, SwipeDirection, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, computedAsync, computedInject, createFetch, createUnrefFn, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAsyncQueue, useAsyncState, useBase64, useBattery, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClamp, useClipboard, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useOffsetPagination, useOnline, usePageLeave, useParallax, usePermission, usePointer, usePointerSwipe, usePreferredColorScheme, usePreferredDark, usePreferredLanguages, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSpeechRecognition, useSpeechSynthesis, useStorage, useStorageAsync, useStyleTag, useSwipe, useTemplateRefsList, useTextSelection, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nexport default isNil;\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"View\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  fill: \"currentColor\",\n  d: \"M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z\"\n}, null, -1);\nconst _hoisted_3 = [\n  _hoisted_2\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_3);\n}\nvar view = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { view as default };\n","import { defineComponent, openBlock, createElementBlock, createElementVNode } from 'vue';\nimport _export_sfc from './_virtual/plugin-vue_export-helper.mjs';\n\nconst _sfc_main = defineComponent({\n  name: \"Hide\"\n});\nconst _hoisted_1 = {\n  viewBox: \"0 0 1024 1024\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n};\nconst _hoisted_2 = /* @__PURE__ */ createElementVNode(\"path\", {\n  d: \"M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z\",\n  fill: \"currentColor\"\n}, null, -1);\nconst _hoisted_3 = /* @__PURE__ */ createElementVNode(\"path\", {\n  d: \"M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z\",\n  fill: \"currentColor\"\n}, null, -1);\nconst _hoisted_4 = [\n  _hoisted_2,\n  _hoisted_3\n];\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", _hoisted_1, _hoisted_4);\n}\nvar hide = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { hide as default };\n","import { isNumber } from '@element-plus/utils'\n\nlet hiddenTextarea: HTMLTextAreaElement | undefined = undefined\n\nconst HIDDEN_STYLE = `\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n`\n\nconst CONTEXT_STYLE = [\n  'letter-spacing',\n  'line-height',\n  'padding-top',\n  'padding-bottom',\n  'font-family',\n  'font-weight',\n  'font-size',\n  'text-rendering',\n  'text-transform',\n  'width',\n  'text-indent',\n  'padding-left',\n  'padding-right',\n  'border-width',\n  'box-sizing',\n]\n\ntype NodeStyle = {\n  contextStyle: string\n  boxSizing: string\n  paddingSize: number\n  borderSize: number\n}\n\ntype TextAreaHeight = {\n  height: string\n  minHeight?: string\n}\n\nfunction calculateNodeStyling(targetElement: Element): NodeStyle {\n  const style = window.getComputedStyle(targetElement)\n\n  const boxSizing = style.getPropertyValue('box-sizing')\n\n  const paddingSize =\n    Number.parseFloat(style.getPropertyValue('padding-bottom')) +\n    Number.parseFloat(style.getPropertyValue('padding-top'))\n\n  const borderSize =\n    Number.parseFloat(style.getPropertyValue('border-bottom-width')) +\n    Number.parseFloat(style.getPropertyValue('border-top-width'))\n\n  const contextStyle = CONTEXT_STYLE.map(\n    (name) => `${name}:${style.getPropertyValue(name)}`\n  ).join(';')\n\n  return { contextStyle, paddingSize, borderSize, boxSizing }\n}\n\nexport function calcTextareaHeight(\n  targetElement: HTMLTextAreaElement,\n  minRows = 1,\n  maxRows?: number\n): TextAreaHeight {\n  if (!hiddenTextarea) {\n    hiddenTextarea = document.createElement('textarea')\n    document.body.appendChild(hiddenTextarea)\n  }\n\n  const { paddingSize, borderSize, boxSizing, contextStyle } =\n    calculateNodeStyling(targetElement)\n\n  hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`)\n  hiddenTextarea.value = targetElement.value || targetElement.placeholder || ''\n\n  let height = hiddenTextarea.scrollHeight\n  const result = {} as TextAreaHeight\n\n  if (boxSizing === 'border-box') {\n    height = height + borderSize\n  } else if (boxSizing === 'content-box') {\n    height = height - paddingSize\n  }\n\n  hiddenTextarea.value = ''\n  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize\n\n  if (isNumber(minRows)) {\n    let minHeight = singleRowHeight * minRows\n    if (boxSizing === 'border-box') {\n      minHeight = minHeight + paddingSize + borderSize\n    }\n    height = Math.max(minHeight, height)\n    result.minHeight = `${minHeight}px`\n  }\n  if (isNumber(maxRows)) {\n    let maxHeight = singleRowHeight * maxRows\n    if (boxSizing === 'border-box') {\n      maxHeight = maxHeight + paddingSize + borderSize\n    }\n    height = Math.min(maxHeight, height)\n  }\n  result.height = `${height}px`\n  hiddenTextarea.parentNode?.removeChild(hiddenTextarea)\n  hiddenTextarea = undefined\n\n  return result\n}\n","export const mutable = <T extends readonly any[] | Record<string, unknown>>(\n  val: T\n) => val as Mutable<typeof val>\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport type HTMLElementCustomized<T> = HTMLElement & T\n\n/**\n * @deprecated stop to use null\n * @see {@link https://github.com/sindresorhus/meta/discussions/7}\n */\nexport type Nullable<T> = T | null\n\nexport type Arrayable<T> = T | T[]\nexport type Awaitable<T> = Promise<T> | T\n","export const UPDATE_MODEL_EVENT = 'update:modelValue'\nexport const CHANGE_EVENT = 'change'\nexport const INPUT_EVENT = 'input'\n","import { isString } from '@vue/shared'\nimport {\n  buildProps,\n  definePropType,\n  iconPropType,\n  mutable,\n} from '@element-plus/utils'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { useSizeProp } from '@element-plus/hooks'\nimport type Input from './input.vue'\nimport type { ExtractPropTypes, StyleValue } from 'vue'\n\nexport type InputAutoSize = { minRows?: number; maxRows?: number } | boolean\n\nexport const inputProps = buildProps({\n  id: {\n    type: String,\n    default: undefined,\n  },\n  size: useSizeProp,\n  disabled: Boolean,\n  modelValue: {\n    type: definePropType<string | number | null | undefined>([\n      String,\n      Number,\n      Object,\n    ]),\n    default: '',\n  },\n  type: {\n    type: String,\n    default: 'text',\n  },\n  resize: {\n    type: String,\n    values: ['none', 'both', 'horizontal', 'vertical'],\n  },\n  autosize: {\n    type: definePropType<InputAutoSize>([Boolean, Object]),\n    default: false,\n  },\n  autocomplete: {\n    type: String,\n    default: 'off',\n  },\n  formatter: {\n    type: Function,\n  },\n  parser: {\n    type: Function,\n  },\n  placeholder: {\n    type: String,\n  },\n  form: {\n    type: String,\n    default: '',\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  clearable: {\n    type: Boolean,\n    default: false,\n  },\n  showPassword: {\n    type: Boolean,\n    default: false,\n  },\n  showWordLimit: {\n    type: Boolean,\n    default: false,\n  },\n  suffixIcon: {\n    type: iconPropType,\n    default: '',\n  },\n  prefixIcon: {\n    type: iconPropType,\n    default: '',\n  },\n  containerRole: {\n    type: String,\n    default: undefined,\n  },\n  label: {\n    type: String,\n    default: undefined,\n  },\n  tabindex: {\n    type: [String, Number],\n    default: 0,\n  },\n  validateEvent: {\n    type: Boolean,\n    default: true,\n  },\n  inputStyle: {\n    type: definePropType<StyleValue>([Object, Array, String]),\n    default: () => mutable({} as const),\n  },\n} as const)\nexport type InputProps = ExtractPropTypes<typeof inputProps>\n\nexport const inputEmits = {\n  [UPDATE_MODEL_EVENT]: (value: string) => isString(value),\n  input: (value: string) => isString(value),\n  change: (value: string) => isString(value),\n  focus: (evt: FocusEvent) => evt instanceof FocusEvent,\n  blur: (evt: FocusEvent) => evt instanceof FocusEvent,\n  clear: () => true,\n  mouseleave: (evt: MouseEvent) => evt instanceof MouseEvent,\n  mouseenter: (evt: MouseEvent) => evt instanceof MouseEvent,\n  // NOTE: when autofill by browser, the keydown event is instanceof Event, not KeyboardEvent\n  // relative bug report https://github.com/element-plus/element-plus/issues/6665\n  keydown: (evt: KeyboardEvent | Event) => evt instanceof Event,\n  compositionstart: (evt: CompositionEvent) => evt instanceof CompositionEvent,\n  compositionupdate: (evt: CompositionEvent) => evt instanceof CompositionEvent,\n  compositionend: (evt: CompositionEvent) => evt instanceof CompositionEvent,\n}\nexport type InputEmits = typeof inputEmits\n\nexport type InputInstance = InstanceType<typeof Input>\n","import { computed, getCurrentInstance } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { ComputedRef } from 'vue'\n\ninterface Params {\n  excludeListeners?: boolean\n  excludeKeys?: ComputedRef<string[]>\n}\n\nconst DEFAULT_EXCLUDE_KEYS = ['class', 'style']\nconst LISTENER_PREFIX = /^on[A-Z]/\n\nexport const useAttrs = (\n  params: Params = {}\n): ComputedRef<Record<string, unknown>> => {\n  const { excludeListeners = false, excludeKeys } = params\n  const allExcludeKeys = computed<string[]>(() => {\n    return (excludeKeys?.value || []).concat(DEFAULT_EXCLUDE_KEYS)\n  })\n\n  const instance = getCurrentInstance()\n  if (!instance) {\n    debugWarn(\n      'use-attrs',\n      'getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function'\n    )\n    return computed(() => ({}))\n  }\n\n  return computed(() =>\n    fromPairs(\n      Object.entries(instance.proxy?.$attrs!).filter(\n        ([key]) =>\n          !allExcludeKeys.value.includes(key) &&\n          !(excludeListeners && LISTENER_PREFIX.test(key))\n      )\n    )\n  )\n}\n","import { ref } from 'vue'\n\nimport type { ShallowRef } from 'vue'\n\n// Keep input cursor in the correct position when we use formatter.\nexport function useCursor(\n  input: ShallowRef<HTMLInputElement | undefined>\n): [() => void, () => void] {\n  const selectionRef = ref<{\n    selectionStart?: number\n    selectionEnd?: number\n    value?: string\n    beforeTxt?: string\n    afterTxt?: string\n  }>()\n\n  function recordCursor() {\n    if (input.value == undefined) return\n\n    const { selectionStart, selectionEnd, value } = input.value\n\n    if (selectionStart == null || selectionEnd == null) return\n\n    const beforeTxt = value.slice(0, Math.max(0, selectionStart))\n    const afterTxt = value.slice(Math.max(0, selectionEnd))\n\n    selectionRef.value = {\n      selectionStart,\n      selectionEnd,\n      value,\n      beforeTxt,\n      afterTxt,\n    }\n  }\n  function setCursor() {\n    if (input.value == undefined || selectionRef.value == undefined) return\n\n    const { value } = input.value\n    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value\n\n    if (\n      beforeTxt == undefined ||\n      afterTxt == undefined ||\n      selectionStart == undefined\n    )\n      return\n\n    let startPos = value.length\n\n    if (value.endsWith(afterTxt)) {\n      startPos = value.length - afterTxt.length\n    } else if (value.startsWith(beforeTxt)) {\n      startPos = beforeTxt.length\n    } else {\n      const beforeLastChar = beforeTxt[selectionStart - 1]\n      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1)\n      if (newIndex !== -1) {\n        startPos = newIndex + 1\n      }\n    }\n\n    input.value.setSelectionRange(startPos, startPos)\n  }\n\n  return [recordCursor, setCursor]\n}\n","export const isKorean = (text: string) =>\n  /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi.test(text)\n","<template>\n  <div\n    v-show=\"type !== 'hidden'\"\n    v-bind=\"containerAttrs\"\n    :class=\"[\n      type === 'textarea' ? nsTextarea.b() : nsInput.b(),\n      nsInput.m(inputSize),\n      nsInput.is('disabled', inputDisabled),\n      nsInput.is('exceed', inputExceed),\n      {\n        [nsInput.b('group')]: $slots.prepend || $slots.append,\n        [nsInput.bm('group', 'append')]: $slots.append,\n        [nsInput.bm('group', 'prepend')]: $slots.prepend,\n        [nsInput.m('prefix')]: $slots.prefix || prefixIcon,\n        [nsInput.m('suffix')]:\n          $slots.suffix || suffixIcon || clearable || showPassword,\n        [nsInput.bm('suffix', 'password-clear')]: showClear && showPwdVisible,\n      },\n      $attrs.class,\n    ]\"\n    :style=\"containerStyle\"\n    :role=\"containerRole\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n  >\n    <!-- input -->\n    <template v-if=\"type !== 'textarea'\">\n      <!-- prepend slot -->\n      <div v-if=\"$slots.prepend\" :class=\"nsInput.be('group', 'prepend')\">\n        <slot name=\"prepend\" />\n      </div>\n\n      <div :class=\"[nsInput.e('wrapper'), nsInput.is('focus', focused)]\">\n        <!-- prefix slot -->\n        <span v-if=\"$slots.prefix || prefixIcon\" :class=\"nsInput.e('prefix')\">\n          <span :class=\"nsInput.e('prefix-inner')\">\n            <slot name=\"prefix\" />\n            <el-icon v-if=\"prefixIcon\" :class=\"nsInput.e('icon')\">\n              <component :is=\"prefixIcon\" />\n            </el-icon>\n          </span>\n        </span>\n\n        <input\n          :id=\"inputId\"\n          ref=\"input\"\n          :class=\"nsInput.e('inner')\"\n          v-bind=\"attrs\"\n          :type=\"showPassword ? (passwordVisible ? 'text' : 'password') : type\"\n          :disabled=\"inputDisabled\"\n          :formatter=\"formatter\"\n          :parser=\"parser\"\n          :readonly=\"readonly\"\n          :autocomplete=\"autocomplete\"\n          :tabindex=\"tabindex\"\n          :aria-label=\"label\"\n          :placeholder=\"placeholder\"\n          :style=\"inputStyle\"\n          @compositionstart=\"handleCompositionStart\"\n          @compositionupdate=\"handleCompositionUpdate\"\n          @compositionend=\"handleCompositionEnd\"\n          @input=\"handleInput\"\n          @focus=\"handleFocus\"\n          @blur=\"handleBlur\"\n          @change=\"handleChange\"\n          @keydown=\"handleKeydown\"\n        />\n\n        <!-- suffix slot -->\n        <span v-if=\"suffixVisible\" :class=\"nsInput.e('suffix')\">\n          <span :class=\"nsInput.e('suffix-inner')\">\n            <template\n              v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\"\n            >\n              <slot name=\"suffix\" />\n              <el-icon v-if=\"suffixIcon\" :class=\"nsInput.e('icon')\">\n                <component :is=\"suffixIcon\" />\n              </el-icon>\n            </template>\n            <el-icon\n              v-if=\"showClear\"\n              :class=\"[nsInput.e('icon'), nsInput.e('clear')]\"\n              @mousedown.prevent\n              @click=\"clear\"\n            >\n              <circle-close />\n            </el-icon>\n            <el-icon\n              v-if=\"showPwdVisible\"\n              :class=\"[nsInput.e('icon'), nsInput.e('password')]\"\n              @click=\"handlePasswordVisible\"\n            >\n              <component :is=\"passwordIcon\" />\n            </el-icon>\n            <span v-if=\"isWordLimitVisible\" :class=\"nsInput.e('count')\">\n              <span :class=\"nsInput.e('count-inner')\">\n                {{ textLength }} / {{ attrs.maxlength }}\n              </span>\n            </span>\n            <el-icon\n              v-if=\"validateState && validateIcon && needStatusIcon\"\n              :class=\"[\n                nsInput.e('icon'),\n                nsInput.e('validateIcon'),\n                nsInput.is('loading', validateState === 'validating'),\n              ]\"\n            >\n              <component :is=\"validateIcon\" />\n            </el-icon>\n          </span>\n        </span>\n      </div>\n\n      <!-- append slot -->\n      <div v-if=\"$slots.append\" :class=\"nsInput.be('group', 'append')\">\n        <slot name=\"append\" />\n      </div>\n    </template>\n\n    <!-- textarea -->\n    <template v-else>\n      <textarea\n        :id=\"inputId\"\n        ref=\"textarea\"\n        :class=\"nsTextarea.e('inner')\"\n        v-bind=\"attrs\"\n        :tabindex=\"tabindex\"\n        :disabled=\"inputDisabled\"\n        :readonly=\"readonly\"\n        :autocomplete=\"autocomplete\"\n        :style=\"textareaStyle\"\n        :aria-label=\"label\"\n        :placeholder=\"placeholder\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n        @input=\"handleInput\"\n        @focus=\"handleFocus\"\n        @blur=\"handleBlur\"\n        @change=\"handleChange\"\n        @keydown=\"handleKeydown\"\n      />\n      <span\n        v-if=\"isWordLimitVisible\"\n        :style=\"countStyle\"\n        :class=\"nsInput.e('count')\"\n      >\n        {{ textLength }} / {{ attrs.maxlength }}\n      </span>\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  getCurrentInstance,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  shallowRef,\n  toRef,\n  useAttrs as useRawAttrs,\n  useSlots,\n  watch,\n} from 'vue'\nimport { isClient, useResizeObserver } from '@vueuse/core'\nimport { isNil } from 'lodash-unified'\nimport { ElIcon } from '@element-plus/components/icon'\nimport {\n  CircleClose,\n  Hide as IconHide,\n  View as IconView,\n} from '@element-plus/icons-vue'\nimport {\n  ValidateComponentsMap,\n  debugWarn,\n  isKorean,\n  isObject,\n} from '@element-plus/utils'\nimport {\n  useAttrs,\n  useCursor,\n  useDisabled,\n  useFormItem,\n  useFormItemInputId,\n  useNamespace,\n  useSize,\n} from '@element-plus/hooks'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { calcTextareaHeight } from './utils'\nimport { inputEmits, inputProps } from './input'\nimport type { StyleValue } from 'vue'\n\ntype TargetElement = HTMLInputElement | HTMLTextAreaElement\nconst PENDANT_MAP = {\n  suffix: 'append',\n  prefix: 'prepend',\n} as const\n\ndefineOptions({\n  name: 'ElInput',\n  inheritAttrs: false,\n})\nconst props = defineProps(inputProps)\nconst emit = defineEmits(inputEmits)\n\nconst instance = getCurrentInstance()!\nconst rawAttrs = useRawAttrs()\nconst slots = useSlots()\n\nconst containerAttrs = computed<Record<string, unknown>>(() => {\n  const comboBoxAttrs = {}\n  if (props.containerRole === 'combobox') {\n    comboBoxAttrs['aria-haspopup'] = rawAttrs['aria-haspopup']\n    comboBoxAttrs['aria-owns'] = rawAttrs['aria-owns']\n    comboBoxAttrs['aria-expanded'] = rawAttrs['aria-expanded']\n  }\n  return comboBoxAttrs\n})\n\nconst attrs = useAttrs({\n  excludeKeys: computed<string[]>(() => {\n    return Object.keys(containerAttrs.value)\n  }),\n})\nconst { form, formItem } = useFormItem()\nconst { inputId } = useFormItemInputId(props, {\n  formItemContext: formItem,\n})\nconst inputSize = useSize()\nconst inputDisabled = useDisabled()\nconst nsInput = useNamespace('input')\nconst nsTextarea = useNamespace('textarea')\n\nconst input = shallowRef<HTMLInputElement>()\nconst textarea = shallowRef<HTMLTextAreaElement>()\n\nconst focused = ref(false)\nconst hovering = ref(false)\nconst isComposing = ref(false)\nconst passwordVisible = ref(false)\nconst countStyle = ref<StyleValue>()\nconst textareaCalcStyle = shallowRef(props.inputStyle)\n\nconst _ref = computed(() => input.value || textarea.value)\n\nconst needStatusIcon = computed(() => form?.statusIcon ?? false)\nconst validateState = computed(() => formItem?.validateState || '')\nconst validateIcon = computed(() => ValidateComponentsMap[validateState.value])\nconst passwordIcon = computed(() =>\n  passwordVisible.value ? IconView : IconHide\n)\nconst containerStyle = computed<StyleValue>(() => [\n  rawAttrs.style as StyleValue,\n  props.inputStyle,\n])\nconst textareaStyle = computed<StyleValue>(() => [\n  props.inputStyle,\n  textareaCalcStyle.value,\n  { resize: props.resize },\n])\nconst nativeInputValue = computed(() =>\n  isNil(props.modelValue) ? '' : String(props.modelValue)\n)\nconst showClear = computed(\n  () =>\n    props.clearable &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !!nativeInputValue.value &&\n    (focused.value || hovering.value)\n)\nconst showPwdVisible = computed(\n  () =>\n    props.showPassword &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    (!!nativeInputValue.value || focused.value)\n)\nconst isWordLimitVisible = computed(\n  () =>\n    props.showWordLimit &&\n    !!attrs.value.maxlength &&\n    (props.type === 'text' || props.type === 'textarea') &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !props.showPassword\n)\nconst textLength = computed(() => Array.from(nativeInputValue.value).length)\nconst inputExceed = computed(\n  () =>\n    // show exceed style if length of initial value greater then maxlength\n    !!isWordLimitVisible.value &&\n    textLength.value > Number(attrs.value.maxlength)\n)\nconst suffixVisible = computed(\n  () =>\n    !!slots.suffix ||\n    !!props.suffixIcon ||\n    showClear.value ||\n    props.showPassword ||\n    isWordLimitVisible.value ||\n    (!!validateState.value && needStatusIcon.value)\n)\n\nconst [recordCursor, setCursor] = useCursor(input)\n\nuseResizeObserver(textarea, (entries) => {\n  if (!isWordLimitVisible.value || props.resize !== 'both') return\n  const entry = entries[0]\n  const { width } = entry.contentRect\n  countStyle.value = {\n    /** right: 100% - width + padding(15) + right(6) */\n    right: `calc(100% - ${width + 15 + 6}px)`,\n  }\n})\n\nconst resizeTextarea = () => {\n  const { type, autosize } = props\n\n  if (!isClient || type !== 'textarea') return\n\n  if (autosize) {\n    const minRows = isObject(autosize) ? autosize.minRows : undefined\n    const maxRows = isObject(autosize) ? autosize.maxRows : undefined\n    textareaCalcStyle.value = {\n      ...calcTextareaHeight(textarea.value!, minRows, maxRows),\n    }\n  } else {\n    textareaCalcStyle.value = {\n      minHeight: calcTextareaHeight(textarea.value!).minHeight,\n    }\n  }\n}\n\nconst setNativeInputValue = () => {\n  const input = _ref.value\n  if (!input || input.value === nativeInputValue.value) return\n  input.value = nativeInputValue.value\n}\n\nconst calcIconOffset = (place: 'prefix' | 'suffix') => {\n  const { el } = instance.vnode\n  if (!el) return\n  const elList = Array.from(\n    (el as Element).querySelectorAll<HTMLSpanElement>(`.${nsInput.e(place)}`)\n  )\n  const target = elList.find((item) => item.parentNode === el)\n  if (!target) return\n\n  const pendant = PENDANT_MAP[place]\n\n  if (slots[pendant]) {\n    target.style.transform = `translateX(${place === 'suffix' ? '-' : ''}${\n      el.querySelector(`.${nsInput.be('group', pendant)}`).offsetWidth\n    }px)`\n  } else {\n    target.removeAttribute('style')\n  }\n}\n\nconst updateIconOffset = () => {\n  calcIconOffset('prefix')\n  calcIconOffset('suffix')\n}\n\nconst handleInput = async (event: Event) => {\n  recordCursor()\n\n  let { value } = event.target as TargetElement\n\n  if (props.formatter) {\n    value = props.parser ? props.parser(value) : value\n    value = props.formatter(value)\n  }\n\n  // should not emit input during composition\n  // see: https://github.com/ElemeFE/element/issues/10516\n  if (isComposing.value) return\n\n  // hack for https://github.com/ElemeFE/element/issues/8548\n  // should remove the following line when we don't support IE\n  if (value === nativeInputValue.value) return\n\n  emit(UPDATE_MODEL_EVENT, value)\n  emit('input', value)\n\n  // ensure native input value is controlled\n  // see: https://github.com/ElemeFE/element/issues/12850\n  await nextTick()\n  setNativeInputValue()\n  setCursor()\n}\n\nconst handleChange = (event: Event) => {\n  emit('change', (event.target as TargetElement).value)\n}\n\nconst handleCompositionStart = (event: CompositionEvent) => {\n  emit('compositionstart', event)\n  isComposing.value = true\n}\n\nconst handleCompositionUpdate = (event: CompositionEvent) => {\n  emit('compositionupdate', event)\n  const text = (event.target as HTMLInputElement)?.value\n  const lastCharacter = text[text.length - 1] || ''\n  isComposing.value = !isKorean(lastCharacter)\n}\n\nconst handleCompositionEnd = (event: CompositionEvent) => {\n  emit('compositionend', event)\n  if (isComposing.value) {\n    isComposing.value = false\n    handleInput(event)\n  }\n}\n\nconst handlePasswordVisible = () => {\n  passwordVisible.value = !passwordVisible.value\n  focus()\n}\n\nconst focus = async () => {\n  // see: https://github.com/ElemeFE/element/issues/18573\n  await nextTick()\n  _ref.value?.focus()\n}\n\nconst blur = () => _ref.value?.blur()\n\nconst handleFocus = (event: FocusEvent) => {\n  focused.value = true\n  emit('focus', event)\n}\n\nconst handleBlur = (event: FocusEvent) => {\n  focused.value = false\n  emit('blur', event)\n  if (props.validateEvent) {\n    formItem?.validate?.('blur').catch((err) => debugWarn(err))\n  }\n}\n\nconst handleMouseLeave = (evt: MouseEvent) => {\n  hovering.value = false\n  emit('mouseleave', evt)\n}\n\nconst handleMouseEnter = (evt: MouseEvent) => {\n  hovering.value = true\n  emit('mouseenter', evt)\n}\n\nconst handleKeydown = (evt: KeyboardEvent) => {\n  emit('keydown', evt)\n}\n\nconst select = () => {\n  _ref.value?.select()\n}\n\nconst clear = () => {\n  emit(UPDATE_MODEL_EVENT, '')\n  emit('change', '')\n  emit('clear')\n  emit('input', '')\n}\n\nwatch(\n  () => props.modelValue,\n  () => {\n    nextTick(() => resizeTextarea())\n    if (props.validateEvent) {\n      formItem?.validate?.('change').catch((err) => debugWarn(err))\n    }\n  }\n)\n\n// native input value is set explicitly\n// do not use v-model / :value in template\n// see: https://github.com/ElemeFE/element/issues/14521\nwatch(nativeInputValue, () => setNativeInputValue())\n\n// when change between <input> and <textarea>,\n// update DOM dependent value and styles\n// https://github.com/ElemeFE/element/issues/14857\nwatch(\n  () => props.type,\n  async () => {\n    await nextTick()\n    setNativeInputValue()\n    resizeTextarea()\n    updateIconOffset()\n  }\n)\n\nonMounted(async () => {\n  if (!props.formatter && props.parser) {\n    debugWarn(\n      'ElInput',\n      'If you set the parser, you also need to set the formatter.'\n    )\n  }\n  setNativeInputValue()\n  updateIconOffset()\n  await nextTick()\n  resizeTextarea()\n})\n\nonUpdated(async () => {\n  await nextTick()\n  updateIconOffset()\n})\n\ndefineExpose({\n  /** @description HTML input element */\n  input,\n  /** @description HTML textarea element */\n  textarea,\n  /** @description HTML element, input or textarea */\n  ref: _ref,\n  /** @description style of textarea. */\n  textareaStyle,\n\n  /** @description from props (used on unit test) */\n  autosize: toRef(props, 'autosize'),\n\n  /** @description HTML input element native method */\n  focus,\n  /** @description HTML input element native method */\n  blur,\n  /** @description HTML input element native method */\n  select,\n  /** @description clear input value */\n  clear,\n  /** @description resize textarea. */\n  resizeTextarea,\n})\n</script>\n","import { withInstall } from '@element-plus/utils'\n\nimport Input from './src/input.vue'\n\nexport const ElInput = withInstall(Input)\nexport default ElInput\n\nexport * from './src/input'\n","import { NOOP } from '@vue/shared'\n\nexport const useSameTarget = (handleClick?: (e: MouseEvent) => void) => {\n  if (!handleClick) {\n    return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP }\n  }\n\n  let mousedownTarget = false\n  let mouseupTarget = false\n  // refer to this https://javascript.info/mouse-events-basics\n  // events fired in the order: mousedown -> mouseup -> click\n  // we need to set the mousedown handle to false after click fired.\n  const onClick = (e: MouseEvent) => {\n    // if and only if\n    if (mousedownTarget && mouseupTarget) {\n      handleClick(e)\n    }\n    mousedownTarget = mouseupTarget = false\n  }\n\n  const onMousedown = (e: MouseEvent) => {\n    // marking current mousedown target.\n    mousedownTarget = e.target === e.currentTarget\n  }\n  const onMouseup = (e: MouseEvent) => {\n    // marking current mouseup target.\n    mouseupTarget = e.target === e.currentTarget\n  }\n\n  return { onClick, onMousedown, onMouseup }\n}\n","import {\n  Comment,\n  Fragment,\n  Text,\n  camelize,\n  createBlock,\n  createCommentVNode,\n  isVNode,\n  openBlock,\n} from 'vue'\nimport { isArray } from '@vue/shared'\nimport { hasOwn } from '../objects'\nimport { debugWarn } from '../error'\nimport type {\n  VNode,\n  VNodeArrayChildren,\n  VNodeChild,\n  VNodeNormalizedChildren,\n} from 'vue'\n\nconst SCOPE = 'utils/vue/vnode'\n\nexport enum PatchFlags {\n  TEXT = 1,\n  CLASS = 2,\n  STYLE = 4,\n  PROPS = 8,\n  FULL_PROPS = 16,\n  HYDRATE_EVENTS = 32,\n  STABLE_FRAGMENT = 64,\n  KEYED_FRAGMENT = 128,\n  UNKEYED_FRAGMENT = 256,\n  NEED_PATCH = 512,\n  DYNAMIC_SLOTS = 1024,\n  HOISTED = -1,\n  BAIL = -2,\n}\n\nexport function isFragment(node: VNode): boolean\nexport function isFragment(node: unknown): node is VNode\nexport function isFragment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Fragment\n}\n\nexport function isText(node: VNode): boolean\nexport function isText(node: unknown): node is VNode\nexport function isText(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Text\n}\n\nexport function isComment(node: VNode): boolean\nexport function isComment(node: unknown): node is VNode\nexport function isComment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Comment\n}\n\nconst TEMPLATE = 'template'\nexport function isTemplate(node: VNode): boolean\nexport function isTemplate(node: unknown): node is VNode\nexport function isTemplate(node: unknown): node is VNode {\n  return isVNode(node) && node.type === TEMPLATE\n}\n\n/**\n * determine if the element is a valid element type rather than fragments and comment e.g. <template> v-if\n * @param node {VNode} node to be tested\n */\nexport function isValidElementNode(node: VNode): boolean\nexport function isValidElementNode(node: unknown): node is VNode\nexport function isValidElementNode(node: unknown): node is VNode {\n  return isVNode(node) && !isFragment(node) && !isComment(node)\n}\n\n/**\n * get a valid child node (not fragment nor comment)\n * @param node {VNode} node to be searched\n * @param depth {number} depth to be searched\n */\nfunction getChildren(\n  node: VNodeNormalizedChildren | VNodeChild,\n  depth: number\n): VNodeNormalizedChildren | VNodeChild {\n  if (isComment(node)) return\n  if (isFragment(node) || isTemplate(node)) {\n    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : undefined\n  }\n  return node\n}\n\nexport const getFirstValidNode = (\n  nodes: VNodeNormalizedChildren,\n  maxDepth = 3\n) => {\n  if (Array.isArray(nodes)) {\n    return getChildren(nodes[0], maxDepth)\n  } else {\n    return getChildren(nodes, maxDepth)\n  }\n}\n\nexport function renderIf(\n  condition: boolean,\n  ...args: Parameters<typeof createBlock>\n) {\n  return condition ? renderBlock(...args) : createCommentVNode('v-if', true)\n}\n\nexport function renderBlock(...args: Parameters<typeof createBlock>) {\n  return openBlock(), createBlock(...args)\n}\n\nexport const getNormalizedProps = (node: VNode) => {\n  if (!isVNode(node)) {\n    debugWarn(SCOPE, '[getNormalizedProps] must be a VNode')\n    return {}\n  }\n\n  const raw = node.props || {}\n  const type = (isVNode(node.type) ? node.type.props : undefined) || {}\n  const props: Record<string, any> = {}\n\n  Object.keys(type).forEach((key) => {\n    if (hasOwn(type[key], 'default')) {\n      props[key] = type[key].default\n    }\n  })\n\n  Object.keys(raw).forEach((key) => {\n    props[camelize(key)] = raw[key]\n  })\n\n  return props\n}\n\nexport const ensureOnlyChild = (children: VNodeArrayChildren | undefined) => {\n  if (!isArray(children) || children.length > 1) {\n    throw new Error('expect to receive a single Vue element child')\n  }\n  return children[0]\n}\n","import { createVNode, defineComponent, h, renderSlot } from 'vue'\nimport { PatchFlags, buildProps, definePropType } from '@element-plus/utils'\nimport { useNamespace, useSameTarget } from '@element-plus/hooks'\n\nimport type { CSSProperties, ExtractPropTypes } from 'vue'\nimport type { ZIndexProperty } from 'csstype'\n\nexport const overlayProps = buildProps({\n  mask: {\n    type: Boolean,\n    default: true,\n  },\n  customMaskEvent: {\n    type: Boolean,\n    default: false,\n  },\n  overlayClass: {\n    type: definePropType<string | string[] | Record<string, boolean>>([\n      String,\n      Array,\n      Object,\n    ]),\n  },\n  zIndex: {\n    type: definePropType<ZIndexProperty>([String, Number]),\n  },\n} as const)\nexport type OverlayProps = ExtractPropTypes<typeof overlayProps>\n\nexport const overlayEmits = {\n  click: (evt: MouseEvent) => evt instanceof MouseEvent,\n}\nexport type OverlayEmits = typeof overlayEmits\n\nexport default defineComponent({\n  name: 'ElOverlay',\n\n  props: overlayProps,\n  emits: overlayEmits,\n\n  setup(props, { slots, emit }) {\n    const ns = useNamespace('overlay')\n\n    const onMaskClick = (e: MouseEvent) => {\n      emit('click', e)\n    }\n\n    const { onClick, onMousedown, onMouseup } = useSameTarget(\n      props.customMaskEvent ? undefined : onMaskClick\n    )\n\n    // init here\n    return () => {\n      // when the vnode meets the same structure but with different change trigger\n      // it will not automatically update, thus we simply use h function to manage updating\n      return props.mask\n        ? createVNode(\n            'div',\n            {\n              class: [ns.b(), props.overlayClass],\n              style: {\n                zIndex: props.zIndex,\n              },\n              onClick,\n              onMousedown,\n              onMouseup,\n            },\n            [renderSlot(slots, 'default')],\n            PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS,\n            ['onClick', 'onMouseup', 'onMousedown']\n          )\n        : h(\n            'div',\n            {\n              class: props.overlayClass,\n              style: {\n                zIndex: props.zIndex,\n                position: 'fixed',\n                top: '0px',\n                right: '0px',\n                bottom: '0px',\n                left: '0px',\n              } as CSSProperties,\n            },\n            [renderSlot(slots, 'default')]\n          )\n    }\n  },\n})\n","import Overlay from './src/overlay'\n\nexport const ElOverlay = Overlay\nexport default ElOverlay\n\nexport * from './src/overlay'\n","export const EVENT_CODE = {\n  tab: 'Tab',\n  enter: 'Enter',\n  space: 'Space',\n  left: 'ArrowLeft', // 37\n  up: 'ArrowUp', // 38\n  right: 'ArrowRight', // 39\n  down: 'ArrowDown', // 40\n  esc: 'Escape',\n  delete: 'Delete',\n  backspace: 'Backspace',\n  numpadEnter: 'NumpadEnter',\n  pageUp: 'PageUp',\n  pageDown: 'PageDown',\n  home: 'Home',\n  end: 'End',\n}\n","import type { Nullable } from '../typescript'\n\nconst FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  // HTMLButtonElement has disabled\n  if ((element as HTMLButtonElement).disabled) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @desc Set Attempt to set focus on the current node.\n * @param element\n *          The node to attempt to focus on.\n * @returns\n *  true if element is focused.\n */\nexport const attemptFocus = (element: HTMLElement): boolean => {\n  if (!isFocusable(element)) {\n    return false\n  }\n  // Remove the old try catch block since there will be no error to be thrown\n  element.focus?.()\n  return document.activeElement === element\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n): Nullable<Element> => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusNode = (el) => {\n  if (!el) return\n  el.focus()\n  !isLeaf(el) && el.click()\n}\n","/** @deprecated use `element.addEventListener` instead */\nexport const on = (\n  element: HTMLElement | Document | Window,\n  event: string,\n  handler: EventListenerOrEventListenerObject,\n  useCapture = false\n): void => {\n  if (element && event && handler) {\n    element?.addEventListener(event, handler, useCapture)\n  }\n}\n\n/** @deprecated use `element.addEventListener` instead */\nexport const off = (\n  element: HTMLElement | Document | Window,\n  event: string,\n  handler: EventListenerOrEventListenerObject,\n  useCapture = false\n): void => {\n  if (element && event && handler) {\n    element?.removeEventListener(event, handler, useCapture)\n  }\n}\n\n/** @deprecated use `element.addEventListener` instead */\nexport const once = (\n  el: HTMLElement,\n  event: string,\n  fn: EventListener\n): void => {\n  const listener = function (this: any, ...args: any) {\n    if (fn) {\n      fn.apply(this, args)\n    }\n    off(el, event, listener)\n  }\n  on(el, event, listener)\n}\n\nexport const composeEventHandlers = <E>(\n  theirsHandler?: (event: E) => boolean | void,\n  oursHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) => {\n  const handleEvent = (event: E) => {\n    const shouldPrevent = theirsHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !shouldPrevent) {\n      return oursHandler?.(event)\n    }\n  }\n  return handleEvent\n}\n\ntype WhenMouseHandler = (e: PointerEvent) => any\nexport const whenMouse = (handler: WhenMouseHandler): WhenMouseHandler => {\n  return (e: PointerEvent) =>\n    e.pointerType === 'mouse' ? handler(e) : undefined\n}\n","import { nextTick } from 'vue'\nimport { obtainAllFocusableElements, off, on } from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport type { ObjectDirective } from 'vue'\n\nexport const FOCUSABLE_CHILDREN = '_trap-focus-children'\nexport const TRAP_FOCUS_HANDLER = '_trap-focus-handler'\n\nexport interface ITrapFocusElement extends HTMLElement {\n  [FOCUSABLE_CHILDREN]: HTMLElement[]\n  [TRAP_FOCUS_HANDLER]: (e: KeyboardEvent) => void\n}\n\nconst FOCUS_STACK = []\n\nconst FOCUS_HANDLER = (e: KeyboardEvent) => {\n  // Getting the top layer.\n  if (FOCUS_STACK.length === 0) return\n  const focusableElement =\n    FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN]\n  if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {\n    if (focusableElement.length === 1) {\n      e.preventDefault()\n      if (document.activeElement !== focusableElement[0]) {\n        focusableElement[0].focus()\n      }\n      return\n    }\n    const goingBackward = e.shiftKey\n    const isFirst = e.target === focusableElement[0]\n    const isLast = e.target === focusableElement[focusableElement.length - 1]\n    if (isFirst && goingBackward) {\n      e.preventDefault()\n      focusableElement[focusableElement.length - 1].focus()\n    }\n    if (isLast && !goingBackward) {\n      e.preventDefault()\n      focusableElement[0].focus()\n    }\n\n    // the is critical since jsdom did not implement user actions, you can only mock it\n    // DELETE ME: when testing env switches to puppeteer\n    if (process.env.NODE_ENV === 'test') {\n      const index = focusableElement.indexOf(e.target)\n      if (index !== -1) {\n        focusableElement[goingBackward ? index - 1 : index + 1]?.focus()\n      }\n    }\n  }\n}\n\nconst TrapFocus: ObjectDirective = {\n  beforeMount(el: ITrapFocusElement) {\n    el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el)\n    FOCUS_STACK.push(el)\n    if (FOCUS_STACK.length <= 1) {\n      on(document, 'keydown', FOCUS_HANDLER)\n    }\n  },\n  updated(el: ITrapFocusElement) {\n    nextTick(() => {\n      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el)\n    })\n  },\n  unmounted() {\n    FOCUS_STACK.shift()\n    if (FOCUS_STACK.length === 0) {\n      off(document, 'keydown', FOCUS_HANDLER)\n    }\n  },\n}\n\nexport default TrapFocus\n","export type FocusLayer = {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nexport type FocusStack = FocusLayer[]\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (\n      node: Element & {\n        disabled: boolean\n        hidden: boolean\n        type: string\n        tabIndex: number\n      }\n    ) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      return node.tabIndex >= 0 || node === document.activeElement\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n\n  return nodes\n}\n\nexport const getVisibleElement = (\n  elements: HTMLElement[],\n  container: HTMLElement\n) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element\n  }\n}\n\nexport const isHidden = (element: HTMLElement, container: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return false\n  if (getComputedStyle(element).visibility === 'hidden') return true\n\n  while (element) {\n    if (container && element === container) return false\n    if (getComputedStyle(element).display === 'none') return true\n    element = element.parentElement as HTMLElement\n  }\n\n  return false\n}\n\nexport const getEdges = (container: HTMLElement) => {\n  const focusable = obtainAllFocusableElements(container)\n  const first = getVisibleElement(focusable, container)\n  const last = getVisibleElement(focusable.reverse(), container)\n  return [first, last]\n}\n\nconst isSelectable = (\n  element: any\n): element is HTMLInputElement & { select: () => void } => {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport const tryFocus = (\n  element?: HTMLElement | { focus: () => void } | null,\n  shouldSelect?: boolean\n) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement\n    element.focus({ preventScroll: true })\n    if (\n      element !== prevFocusedElement &&\n      isSelectable(element) &&\n      shouldSelect\n    ) {\n      element.select()\n    }\n  }\n}\n\nfunction removeFromStack<T>(list: T[], item: T) {\n  const copy = [...list]\n\n  const idx = list.indexOf(item)\n\n  if (idx !== -1) {\n    copy.splice(idx, 1)\n  }\n  return copy\n}\n\nconst createFocusableStack = () => {\n  let stack = [] as FocusStack\n\n  const push = (layer: FocusLayer) => {\n    const currentLayer = stack[0]\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause()\n    }\n\n    stack = removeFromStack(stack, layer)\n    stack.unshift(layer)\n  }\n\n  const remove = (layer: FocusLayer) => {\n    stack = removeFromStack(stack, layer)\n    stack[0]?.resume?.()\n  }\n\n  return {\n    push,\n    remove,\n  }\n}\n\nexport const focusFirstDescendant = (\n  elements: HTMLElement[],\n  shouldSelect = false\n) => {\n  const prevFocusedElement = document.activeElement\n  for (const element of elements) {\n    tryFocus(element, shouldSelect)\n    if (document.activeElement !== prevFocusedElement) return\n  }\n}\n\nexport const focusableStack = createFocusableStack()\n","import type { InjectionKey, Ref } from 'vue'\n\nexport const FOCUS_AFTER_TRAPPED = 'focus-trap.focus-after-trapped'\nexport const FOCUS_AFTER_RELEASED = 'focus-trap.focus-after-released'\nexport const FOCUS_AFTER_TRAPPED_OPTS: EventInit = {\n  cancelable: true,\n  bubbles: false,\n}\n\nexport const ON_TRAP_FOCUS_EVT = 'focusAfterTrapped'\nexport const ON_RELEASE_FOCUS_EVT = 'focusAfterReleased'\n\nexport type FocusTrapInjectionContext = {\n  focusTrapRef: Ref<HTMLElement | undefined>\n  onKeydown: (e: KeyboardEvent) => void\n}\n\nexport const FOCUS_TRAP_INJECTION_KEY: InjectionKey<FocusTrapInjectionContext> =\n  Symbol('elFocusTrap')\n","import { onBeforeUnmount, onMounted } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { EVENT_CODE } from '@element-plus/constants'\n\nlet registeredEscapeHandlers: ((e: KeyboardEvent) => void)[] = []\n\nexport const useEscapeKeydown = (handler: (e: KeyboardEvent) => void) => {\n  const cachedHandler = (e: Event) => {\n    const event = e as KeyboardEvent\n    if (event.key === EVENT_CODE.esc) {\n      registeredEscapeHandlers.forEach((registeredHandler) =>\n        registeredHandler(event)\n      )\n    }\n  }\n\n  onMounted(() => {\n    if (registeredEscapeHandlers.length === 0) {\n      document.addEventListener('keydown', cachedHandler)\n    }\n    if (isClient) registeredEscapeHandlers.push(handler)\n  })\n\n  onBeforeUnmount(() => {\n    registeredEscapeHandlers = registeredEscapeHandlers.filter(\n      (registeredHandler) => registeredHandler !== handler\n    )\n    if (registeredEscapeHandlers.length === 0) {\n      if (isClient) document.removeEventListener('keydown', cachedHandler)\n    }\n  })\n}\n","<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  obtainAllFocusableElements,\n  tryFocus,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            e.preventDefault()\n            emit('focusout-prevented')\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault()\n            if (loop) tryFocus(first, true)\n            emit('focusout-prevented')\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            e.preventDefault()\n            if (loop) tryFocus(last, true)\n            emit('focusout-prevented')\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        if (\n          !trapContainer.contains(\n            (e as FocusEvent).relatedTarget as HTMLElement | null\n          )\n        ) {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new Event(\n          FOCUS_AFTER_RELEASED,\n          FOCUS_AFTER_TRAPPED_OPTS\n        )\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n\n        if (!releasedEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body, true)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n","import { componentSizes, datePickTypes } from '@element-plus/constants'\nimport type { ComponentSize, DatePickType } from '@element-plus/constants'\n\nexport const isValidComponentSize = (val: string): val is ComponentSize | '' =>\n  ['', ...componentSizes].includes(val)\n\nexport const isValidDatePickType = (val: string): val is DatePickType =>\n  ([...datePickTypes] as string[]).includes(val)\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n","import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n","import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n","import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n","import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n","import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n","import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n","import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n","export default {\n  name: 'en',\n  el: {\n    colorpicker: {\n      confirm: 'OK',\n      clear: 'Clear',\n      defaultLabel: 'color picker',\n      description:\n        'current color is {color}. press enter to select a new color.',\n    },\n    datepicker: {\n      now: 'Now',\n      today: 'Today',\n      cancel: 'Cancel',\n      clear: 'Clear',\n      confirm: 'OK',\n      dateTablePrompt:\n        'Use the arrow keys and enter to select the day of the month',\n      monthTablePrompt: 'Use the arrow keys and enter to select the month',\n      yearTablePrompt: 'Use the arrow keys and enter to select the year',\n      selectedDate: 'Selected date',\n      selectDate: 'Select date',\n      selectTime: 'Select time',\n      startDate: 'Start Date',\n      startTime: 'Start Time',\n      endDate: 'End Date',\n      endTime: 'End Time',\n      prevYear: 'Previous Year',\n      nextYear: 'Next Year',\n      prevMonth: 'Previous Month',\n      nextMonth: 'Next Month',\n      year: '',\n      month1: 'January',\n      month2: 'February',\n      month3: 'March',\n      month4: 'April',\n      month5: 'May',\n      month6: 'June',\n      month7: 'July',\n      month8: 'August',\n      month9: 'September',\n      month10: 'October',\n      month11: 'November',\n      month12: 'December',\n      week: 'week',\n      weeks: {\n        sun: 'Sun',\n        mon: 'Mon',\n        tue: 'Tue',\n        wed: 'Wed',\n        thu: 'Thu',\n        fri: 'Fri',\n        sat: 'Sat',\n      },\n      weeksFull: {\n        sun: 'Sunday',\n        mon: 'Monday',\n        tue: 'Tuesday',\n        wed: 'Wednesday',\n        thu: 'Thursday',\n        fri: 'Friday',\n        sat: 'Saturday',\n      },\n      months: {\n        jan: 'Jan',\n        feb: 'Feb',\n        mar: 'Mar',\n        apr: 'Apr',\n        may: 'May',\n        jun: 'Jun',\n        jul: 'Jul',\n        aug: 'Aug',\n        sep: 'Sep',\n        oct: 'Oct',\n        nov: 'Nov',\n        dec: 'Dec',\n      },\n    },\n    inputNumber: {\n      decrease: 'decrease number',\n      increase: 'increase number',\n    },\n    select: {\n      loading: 'Loading',\n      noMatch: 'No matching data',\n      noData: 'No data',\n      placeholder: 'Select',\n    },\n    cascader: {\n      noMatch: 'No matching data',\n      loading: 'Loading',\n      placeholder: 'Select',\n      noData: 'No data',\n    },\n    pagination: {\n      goto: 'Go to',\n      pagesize: '/page',\n      total: 'Total {total}',\n      pageClassifier: '',\n      deprecationWarning:\n        'Deprecated usages detected, please refer to the el-pagination documentation for more details',\n    },\n    dialog: {\n      close: 'Close this dialog',\n    },\n    drawer: {\n      close: 'Close this dialog',\n    },\n    messagebox: {\n      title: 'Message',\n      confirm: 'OK',\n      cancel: 'Cancel',\n      error: 'Illegal input',\n      close: 'Close this dialog',\n    },\n    upload: {\n      deleteTip: 'press delete to remove',\n      delete: 'Delete',\n      preview: 'Preview',\n      continue: 'Continue',\n    },\n    slider: {\n      defaultLabel: 'slider between {min} and {max}',\n      defaultRangeStartLabel: 'pick start value',\n      defaultRangeEndLabel: 'pick end value',\n    },\n    table: {\n      emptyText: 'No Data',\n      confirmFilter: 'Confirm',\n      resetFilter: 'Reset',\n      clearFilter: 'All',\n      sumText: 'Sum',\n    },\n    tree: {\n      emptyText: 'No Data',\n    },\n    transfer: {\n      noMatch: 'No matching data',\n      noData: 'No data',\n      titles: ['List 1', 'List 2'], // to be translated\n      filterPlaceholder: 'Enter keyword', // to be translated\n      noCheckedFormat: '{total} items', // to be translated\n      hasCheckedFormat: '{checked}/{total} checked', // to be translated\n    },\n    image: {\n      error: 'FAILED',\n    },\n    pageHeader: {\n      title: 'Back', // to be translated\n    },\n    popconfirm: {\n      confirmButtonText: 'Yes',\n      cancelButtonText: 'No',\n    },\n  },\n}\n","import { computed, isRef, ref, unref } from 'vue'\nimport { get } from 'lodash-unified'\nimport English from '@element-plus/locale/lang/en'\nimport { useGlobalConfig } from '../use-global-config'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { Ref } from 'vue'\nimport type { Language } from '@element-plus/locale'\n\nexport type TranslatorOption = Record<string, string | number>\nexport type Translator = (path: string, option?: TranslatorOption) => string\nexport type LocaleContext = {\n  locale: Ref<Language>\n  lang: Ref<string>\n  t: Translator\n}\n\nexport const buildTranslator =\n  (locale: MaybeRef<Language>): Translator =>\n  (path, option) =>\n    translate(path, option, unref(locale))\n\nexport const translate = (\n  path: string,\n  option: undefined | TranslatorOption,\n  locale: Language\n): string =>\n  (get(locale, path, path) as string).replace(\n    /\\{(\\w+)\\}/g,\n    (_, key) => `${option?.[key] ?? `{${key}}`}`\n  )\n\nexport const buildLocaleContext = (\n  locale: MaybeRef<Language>\n): LocaleContext => {\n  const lang = computed(() => unref(locale).name)\n  const localeRef = isRef(locale) ? locale : ref(locale)\n  return {\n    lang,\n    locale: localeRef,\n    t: buildTranslator(locale),\n  }\n}\n\nexport const useLocale = () => {\n  const locale = useGlobalConfig('locale')\n  return buildLocaleContext(computed(() => locale.value || English))\n}\n","import { computed, ref } from 'vue'\nimport { useGlobalConfig } from '../use-global-config'\n\nconst zIndex = ref(0)\n\nexport const useZIndex = () => {\n  const initialZIndex = useGlobalConfig('zIndex', 2000) // TODO: move to @element-plus/constants\n  const currentZIndex = computed(() => initialZIndex.value + zIndex.value)\n\n  const nextZIndex = () => {\n    zIndex.value++\n    return currentZIndex.value\n  }\n\n  return {\n    initialZIndex,\n    currentZIndex,\n    nextZIndex,\n  }\n}\n","import { onBeforeUnmount, onMounted, watchEffect } from 'vue'\nimport { addUnit } from '@element-plus/utils'\nimport type { ComputedRef, Ref } from 'vue'\n\nexport const useDraggable = (\n  targetRef: Ref<HTMLElement | undefined>,\n  dragRef: Ref<HTMLElement | undefined>,\n  draggable: ComputedRef<boolean>\n) => {\n  let transform = {\n    offsetX: 0,\n    offsetY: 0,\n  }\n\n  const onMousedown = (e: MouseEvent) => {\n    const downX = e.clientX\n    const downY = e.clientY\n    const { offsetX, offsetY } = transform\n\n    const targetRect = targetRef.value!.getBoundingClientRect()\n    const targetLeft = targetRect.left\n    const targetTop = targetRect.top\n    const targetWidth = targetRect.width\n    const targetHeight = targetRect.height\n\n    const clientWidth = document.documentElement.clientWidth\n    const clientHeight = document.documentElement.clientHeight\n\n    const minLeft = -targetLeft + offsetX\n    const minTop = -targetTop + offsetY\n    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX\n    const maxTop = clientHeight - targetTop - targetHeight + offsetY\n\n    const onMousemove = (e: MouseEvent) => {\n      const moveX = Math.min(\n        Math.max(offsetX + e.clientX - downX, minLeft),\n        maxLeft\n      )\n      const moveY = Math.min(\n        Math.max(offsetY + e.clientY - downY, minTop),\n        maxTop\n      )\n\n      transform = {\n        offsetX: moveX,\n        offsetY: moveY,\n      }\n      targetRef.value!.style.transform = `translate(${addUnit(\n        moveX\n      )}, ${addUnit(moveY)})`\n    }\n\n    const onMouseup = () => {\n      document.removeEventListener('mousemove', onMousemove)\n      document.removeEventListener('mouseup', onMouseup)\n    }\n\n    document.addEventListener('mousemove', onMousemove)\n    document.addEventListener('mouseup', onMouseup)\n  }\n\n  const onDraggable = () => {\n    if (dragRef.value && targetRef.value) {\n      dragRef.value.addEventListener('mousedown', onMousedown)\n    }\n  }\n\n  const offDraggable = () => {\n    if (dragRef.value && targetRef.value) {\n      dragRef.value.removeEventListener('mousedown', onMousedown)\n    }\n  }\n\n  onMounted(() => {\n    watchEffect(() => {\n      if (draggable.value) {\n        onDraggable()\n      } else {\n        offDraggable()\n      }\n    })\n  })\n\n  onBeforeUnmount(() => {\n    offDraggable()\n  })\n}\n","import { isClient } from '@vueuse/core'\nimport { getStyle } from './style'\n\nexport const isScroll = (el: HTMLElement, isVertical?: boolean): boolean => {\n  if (!isClient) return false\n\n  const key = (\n    {\n      undefined: 'overflow',\n      true: 'overflow-y',\n      false: 'overflow-x',\n    } as const\n  )[String(isVertical)]!\n  const overflow = getStyle(el, key)\n  return ['scroll', 'auto', 'overlay'].some((s) => overflow.includes(s))\n}\n\nexport const getScrollContainer = (\n  el: HTMLElement,\n  isVertical?: boolean\n): Window | HTMLElement | undefined => {\n  if (!isClient) return\n\n  let parent: HTMLElement = el\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent))\n      return window\n\n    if (isScroll(parent, isVertical)) return parent\n\n    parent = parent.parentNode as HTMLElement\n  }\n\n  return parent\n}\n\nlet scrollBarWidth: number\nexport const getScrollBarWidth = (): number => {\n  if (!isClient) return 0\n  if (scrollBarWidth !== undefined) return scrollBarWidth\n\n  const outer = document.createElement('div')\n  // Cannot access 'propKey' before initialization\n  // need to be dynamic namespace\n  outer.className = 'el-scrollbar__wrap'\n  outer.style.visibility = 'hidden'\n  outer.style.width = '100px'\n  outer.style.position = 'absolute'\n  outer.style.top = '-9999px'\n  document.body.appendChild(outer)\n\n  const widthNoScroll = outer.offsetWidth\n  outer.style.overflow = 'scroll'\n\n  const inner = document.createElement('div')\n  inner.style.width = '100%'\n  outer.appendChild(inner)\n\n  const widthWithScroll = inner.offsetWidth\n  outer.parentNode?.removeChild(outer)\n  scrollBarWidth = widthNoScroll - widthWithScroll\n\n  return scrollBarWidth\n}\n\n/**\n * Scroll with in the container element, positioning the **selected** element at the top\n * of the container\n */\nexport function scrollIntoView(\n  container: HTMLElement,\n  selected: HTMLElement\n): void {\n  if (!isClient) return\n\n  if (!selected) {\n    container.scrollTop = 0\n    return\n  }\n\n  const offsetParents: HTMLElement[] = []\n  let pointer = selected.offsetParent\n  while (\n    pointer !== null &&\n    container !== pointer &&\n    container.contains(pointer)\n  ) {\n    offsetParents.push(pointer as HTMLElement)\n    pointer = (pointer as HTMLElement).offsetParent\n  }\n  const top =\n    selected.offsetTop +\n    offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0)\n  const bottom = top + selected.offsetHeight\n  const viewRectTop = container.scrollTop\n  const viewRectBottom = viewRectTop + container.clientHeight\n\n  if (top < viewRectTop) {\n    container.scrollTop = top\n  } else if (bottom > viewRectBottom) {\n    container.scrollTop = bottom - container.clientHeight\n  }\n}\n","import { isRef, onScopeDispose, watch } from 'vue'\n\nimport { isClient } from '@vueuse/core'\nimport {\n  addClass,\n  getScrollBarWidth,\n  getStyle,\n  hasClass,\n  removeClass,\n  throwError,\n} from '@element-plus/utils'\n\nimport type { Ref } from 'vue'\n\n/**\n * Hook that monitoring the ref value to lock or unlock the screen.\n * When the trigger became true, it assumes modal is now opened and vice versa.\n * @param trigger {Ref<boolean>}\n */\nexport const useLockscreen = (trigger: Ref<boolean>) => {\n  if (!isRef(trigger)) {\n    throwError(\n      '[useLockscreen]',\n      'You need to pass a ref param to this function'\n    )\n  }\n  if (!isClient || hasClass(document.body, 'el-popup-parent--hidden')) {\n    return\n  }\n\n  let scrollBarWidth = 0\n  let withoutHiddenClass = false\n  let bodyPaddingRight = '0'\n  let computedBodyPaddingRight = 0\n\n  const cleanup = () => {\n    removeClass(document.body, 'el-popup-parent--hidden')\n    if (withoutHiddenClass) {\n      document.body.style.paddingRight = bodyPaddingRight\n    }\n  }\n  watch(trigger, (val) => {\n    if (!val) {\n      cleanup()\n      return\n    }\n\n    withoutHiddenClass = !hasClass(document.body, 'el-popup-parent--hidden')\n    if (withoutHiddenClass) {\n      bodyPaddingRight = document.body.style.paddingRight\n      computedBodyPaddingRight = Number.parseInt(\n        getStyle(document.body, 'paddingRight'),\n        10\n      )\n    }\n    scrollBarWidth = getScrollBarWidth()\n    const bodyHasOverflow =\n      document.documentElement.clientHeight < document.body.scrollHeight\n    const bodyOverflowY = getStyle(document.body, 'overflowY')\n    if (\n      scrollBarWidth > 0 &&\n      (bodyHasOverflow || bodyOverflowY === 'scroll') &&\n      withoutHiddenClass\n    ) {\n      document.body.style.paddingRight = `${\n        computedBodyPaddingRight + scrollBarWidth\n      }px`\n    }\n    addClass(document.body, 'el-popup-parent--hidden')\n  })\n  onScopeDispose(() => cleanup())\n}\n","import { isRef, watch } from 'vue'\nimport type { Ref } from 'vue'\n\n/**\n * This method provides dialogable components the ability to restore previously activated element before\n * the dialog gets opened\n */\nexport const useRestoreActive = (\n  toggle: Ref<boolean>,\n  initialFocus?: Ref<HTMLElement>\n) => {\n  let previousActive: HTMLElement\n  watch(\n    () => toggle.value,\n    (val) => {\n      if (val) {\n        previousActive = document.activeElement as HTMLElement\n        if (isRef(initialFocus)) {\n          initialFocus.value.focus?.()\n        }\n      } else {\n        if (process.env.NODE_ENV === 'test') {\n          previousActive.focus.call(previousActive)\n        } else {\n          previousActive.focus()\n        }\n      }\n    }\n  )\n}\n","<template>\n  <transition name=\"fade-in-linear\" @after-leave=\"$emit('vanish')\">\n    <el-overlay\n      v-show=\"visible\"\n      :z-index=\"zIndex\"\n      :overlay-class=\"[ns.is('message-box'), modalClass]\"\n      :mask=\"modal\"\n    >\n      <div\n        role=\"dialog\"\n        :aria-label=\"title\"\n        aria-modal=\"true\"\n        :aria-describedby=\"!showInput ? contentId : undefined\"\n        :class=\"`${ns.namespace.value}-overlay-message-box`\"\n        @click=\"overlayEvent.onClick\"\n        @mousedown=\"overlayEvent.onMousedown\"\n        @mouseup=\"overlayEvent.onMouseup\"\n      >\n        <el-focus-trap\n          loop\n          :trapped=\"visible\"\n          :focus-trap-el=\"rootRef\"\n          :focus-start-el=\"focusStartRef\"\n          @release-requested=\"onCloseRequested\"\n        >\n          <div\n            ref=\"rootRef\"\n            :class=\"[\n              ns.b(),\n              customClass,\n              ns.is('draggable', draggable),\n              { [ns.m('center')]: center },\n            ]\"\n            :style=\"customStyle\"\n            tabindex=\"-1\"\n            @click.stop=\"\"\n          >\n            <div\n              v-if=\"title !== null && title !== undefined\"\n              ref=\"headerRef\"\n              :class=\"ns.e('header')\"\n            >\n              <div :class=\"ns.e('title')\">\n                <el-icon\n                  v-if=\"iconComponent && center\"\n                  :class=\"[ns.e('status'), typeClass]\"\n                >\n                  <component :is=\"iconComponent\" />\n                </el-icon>\n                <span>{{ title }}</span>\n              </div>\n              <button\n                v-if=\"showClose\"\n                type=\"button\"\n                :class=\"ns.e('headerbtn')\"\n                :aria-label=\"t('el.messagebox.close')\"\n                @click=\"\n                  handleAction(distinguishCancelAndClose ? 'close' : 'cancel')\n                \"\n                @keydown.prevent.enter=\"\n                  handleAction(distinguishCancelAndClose ? 'close' : 'cancel')\n                \"\n              >\n                <el-icon :class=\"ns.e('close')\">\n                  <close />\n                </el-icon>\n              </button>\n            </div>\n            <div :id=\"contentId\" :class=\"ns.e('content')\">\n              <div :class=\"ns.e('container')\">\n                <el-icon\n                  v-if=\"iconComponent && !center && hasMessage\"\n                  :class=\"[ns.e('status'), typeClass]\"\n                >\n                  <component :is=\"iconComponent\" />\n                </el-icon>\n                <div v-if=\"hasMessage\" :class=\"ns.e('message')\">\n                  <slot>\n                    <component\n                      :is=\"showInput ? 'label' : 'p'\"\n                      v-if=\"!dangerouslyUseHTMLString\"\n                      :for=\"showInput ? inputId : undefined\"\n                    >\n                      {{ !dangerouslyUseHTMLString ? message : '' }}\n                    </component>\n                    <component\n                      :is=\"showInput ? 'label' : 'p'\"\n                      v-else\n                      :for=\"showInput ? inputId : undefined\"\n                      v-html=\"message\"\n                    />\n                  </slot>\n                </div>\n              </div>\n              <div v-show=\"showInput\" :class=\"ns.e('input')\">\n                <el-input\n                  :id=\"inputId\"\n                  ref=\"inputRef\"\n                  v-model=\"inputValue\"\n                  :type=\"inputType\"\n                  :placeholder=\"inputPlaceholder\"\n                  :aria-invalid=\"validateError\"\n                  :class=\"{ invalid: validateError }\"\n                  @keydown.enter=\"handleInputEnter\"\n                />\n                <div\n                  :class=\"ns.e('errormsg')\"\n                  :style=\"{\n                    visibility: !!editorErrorMessage ? 'visible' : 'hidden',\n                  }\"\n                >\n                  {{ editorErrorMessage }}\n                </div>\n              </div>\n            </div>\n            <div :class=\"ns.e('btns')\">\n              <el-button\n                v-if=\"showCancelButton\"\n                :loading=\"cancelButtonLoading\"\n                :class=\"[cancelButtonClass]\"\n                :round=\"roundButton\"\n                :size=\"btnSize\"\n                @click=\"handleAction('cancel')\"\n                @keydown.prevent.enter=\"handleAction('cancel')\"\n              >\n                {{ cancelButtonText || t('el.messagebox.cancel') }}\n              </el-button>\n              <el-button\n                v-show=\"showConfirmButton\"\n                ref=\"confirmRef\"\n                type=\"primary\"\n                :loading=\"confirmButtonLoading\"\n                :class=\"[confirmButtonClasses]\"\n                :round=\"roundButton\"\n                :disabled=\"confirmButtonDisabled\"\n                :size=\"btnSize\"\n                @click=\"handleAction('confirm')\"\n                @keydown.prevent.enter=\"handleAction('confirm')\"\n              >\n                {{ confirmButtonText || t('el.messagebox.confirm') }}\n              </el-button>\n            </div>\n          </div>\n        </el-focus-trap>\n      </div>\n    </el-overlay>\n  </transition>\n</template>\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n} from 'vue'\nimport ElButton from '@element-plus/components/button'\nimport { TrapFocus } from '@element-plus/directives'\nimport {\n  useDraggable,\n  useId,\n  useLocale,\n  useLockscreen,\n  useNamespace,\n  useRestoreActive,\n  useSameTarget,\n  useSize,\n  useZIndex,\n} from '@element-plus/hooks'\nimport ElInput from '@element-plus/components/input'\nimport { ElOverlay } from '@element-plus/components/overlay'\nimport {\n  TypeComponents,\n  TypeComponentsMap,\n  isValidComponentSize,\n  off,\n  on,\n} from '@element-plus/utils'\nimport { ElIcon } from '@element-plus/components/icon'\nimport ElFocusTrap from '@element-plus/components/focus-trap'\n\nimport type { ComponentPublicInstance, PropType } from 'vue'\nimport type { ComponentSize } from '@element-plus/constants'\nimport type {\n  Action,\n  MessageBoxState,\n  MessageBoxType,\n} from './message-box.type'\n\nexport default defineComponent({\n  name: 'ElMessageBox',\n  directives: {\n    TrapFocus,\n  },\n  components: {\n    ElButton,\n    ElFocusTrap,\n    ElInput,\n    ElOverlay,\n    ElIcon,\n    ...TypeComponents,\n  },\n  inheritAttrs: false,\n  props: {\n    buttonSize: {\n      type: String as PropType<ComponentSize>,\n      validator: isValidComponentSize,\n    },\n    modal: {\n      type: Boolean,\n      default: true,\n    },\n    lockScroll: {\n      type: Boolean,\n      default: true,\n    },\n    showClose: {\n      type: Boolean,\n      default: true,\n    },\n    closeOnClickModal: {\n      type: Boolean,\n      default: true,\n    },\n    closeOnPressEscape: {\n      type: Boolean,\n      default: true,\n    },\n    closeOnHashChange: {\n      type: Boolean,\n      default: true,\n    },\n    center: Boolean,\n    draggable: Boolean,\n    roundButton: {\n      default: false,\n      type: Boolean,\n    },\n    container: {\n      type: String, // default append to body\n      default: 'body',\n    },\n    boxType: {\n      type: String as PropType<MessageBoxType>,\n      default: '',\n    },\n  },\n  emits: ['vanish', 'action'],\n  setup(props, { emit }) {\n    // const popup = usePopup(props, doClose)\n    const { t } = useLocale()\n    const ns = useNamespace('message-box')\n    const visible = ref(false)\n    const { nextZIndex } = useZIndex()\n    // s represents state\n    const state = reactive<MessageBoxState>({\n      beforeClose: null,\n      callback: null,\n      cancelButtonText: '',\n      cancelButtonClass: '',\n      confirmButtonText: '',\n      confirmButtonClass: '',\n      customClass: '',\n      customStyle: {},\n      dangerouslyUseHTMLString: false,\n      distinguishCancelAndClose: false,\n      icon: '',\n      inputPattern: null,\n      inputPlaceholder: '',\n      inputType: 'text',\n      inputValue: null,\n      inputValidator: null,\n      inputErrorMessage: '',\n      message: null,\n      modalFade: true,\n      modalClass: '',\n      showCancelButton: false,\n      showConfirmButton: true,\n      type: '',\n      title: undefined,\n      showInput: false,\n      action: '' as Action,\n      confirmButtonLoading: false,\n      cancelButtonLoading: false,\n      confirmButtonDisabled: false,\n      editorErrorMessage: '',\n      // refer to: https://github.com/ElemeFE/element/commit/2999279ae34ef10c373ca795c87b020ed6753eed\n      // seemed ok for now without this state.\n      // isOnComposition: false, // temporary remove\n      validateError: false,\n      zIndex: nextZIndex(),\n    })\n\n    const typeClass = computed(() => {\n      const type = state.type\n      return { [ns.bm('icon', type)]: type && TypeComponentsMap[type] }\n    })\n\n    const contentId = useId()\n    const inputId = useId()\n\n    const btnSize = useSize(\n      computed(() => props.buttonSize),\n      { prop: true, form: true, formItem: true }\n    )\n\n    const iconComponent = computed(\n      () => state.icon || TypeComponentsMap[state.type] || ''\n    )\n    const hasMessage = computed(() => !!state.message)\n    const rootRef = ref<HTMLElement>()\n    const headerRef = ref<HTMLElement>()\n    const focusStartRef = ref<HTMLElement>()\n    const inputRef = ref<ComponentPublicInstance>()\n    const confirmRef = ref<ComponentPublicInstance>()\n\n    const confirmButtonClasses = computed(() => state.confirmButtonClass)\n\n    watch(\n      () => state.inputValue,\n      async (val) => {\n        await nextTick()\n        if (props.boxType === 'prompt' && val !== null) {\n          validate()\n        }\n      },\n      { immediate: true }\n    )\n\n    watch(\n      () => visible.value,\n      (val) => {\n        if (val) {\n          if (props.boxType === 'alert' || props.boxType === 'confirm') {\n            focusStartRef.value = confirmRef.value?.$el ?? rootRef.value\n          }\n          state.zIndex = nextZIndex()\n        }\n        if (props.boxType !== 'prompt') return\n        if (val) {\n          nextTick().then(() => {\n            if (inputRef.value && inputRef.value.$el) {\n              focusStartRef.value = getInputElement() ?? rootRef.value\n            }\n          })\n        } else {\n          state.editorErrorMessage = ''\n          state.validateError = false\n        }\n      }\n    )\n\n    const draggable = computed(() => props.draggable)\n    useDraggable(rootRef, headerRef, draggable)\n\n    onMounted(async () => {\n      await nextTick()\n      if (props.closeOnHashChange) {\n        on(window, 'hashchange', doClose)\n      }\n    })\n\n    onBeforeUnmount(() => {\n      if (props.closeOnHashChange) {\n        off(window, 'hashchange', doClose)\n      }\n    })\n\n    function doClose() {\n      if (!visible.value) return\n      visible.value = false\n      nextTick(() => {\n        if (state.action) emit('action', state.action)\n      })\n    }\n\n    const handleWrapperClick = () => {\n      if (props.closeOnClickModal) {\n        handleAction(state.distinguishCancelAndClose ? 'close' : 'cancel')\n      }\n    }\n\n    const overlayEvent = useSameTarget(handleWrapperClick)\n\n    const handleInputEnter = (e: KeyboardEvent) => {\n      if (state.inputType !== 'textarea') {\n        e.preventDefault()\n        return handleAction('confirm')\n      }\n    }\n\n    const handleAction = (action: Action) => {\n      if (props.boxType === 'prompt' && action === 'confirm' && !validate()) {\n        return\n      }\n\n      state.action = action\n\n      if (state.beforeClose) {\n        state.beforeClose?.(action, state, doClose)\n      } else {\n        doClose()\n      }\n    }\n\n    const validate = () => {\n      if (props.boxType === 'prompt') {\n        const inputPattern = state.inputPattern\n        if (inputPattern && !inputPattern.test(state.inputValue || '')) {\n          state.editorErrorMessage =\n            state.inputErrorMessage || t('el.messagebox.error')\n          state.validateError = true\n          return false\n        }\n        const inputValidator = state.inputValidator\n        if (typeof inputValidator === 'function') {\n          const validateResult = inputValidator(state.inputValue)\n          if (validateResult === false) {\n            state.editorErrorMessage =\n              state.inputErrorMessage || t('el.messagebox.error')\n            state.validateError = true\n            return false\n          }\n          if (typeof validateResult === 'string') {\n            state.editorErrorMessage = validateResult\n            state.validateError = true\n            return false\n          }\n        }\n      }\n      state.editorErrorMessage = ''\n      state.validateError = false\n      return true\n    }\n\n    const getInputElement = () => {\n      const inputRefs = inputRef.value.$refs\n      return (inputRefs.input || inputRefs.textarea) as HTMLElement\n    }\n\n    const handleClose = () => {\n      handleAction('close')\n    }\n\n    // when close on press escape is disabled, pressing esc should not callout\n    // any other message box and close any other dialog-ish elements\n    // e.g. Dialog has a close on press esc feature, and when it closes, it calls\n    // props.beforeClose method to make a intermediate state by callout a message box\n    // for some verification or alerting. then if we allow global event liek this\n    // to dispatch, it could callout another message box.\n    const onCloseRequested = () => {\n      if (props.closeOnPressEscape) {\n        handleClose()\n      }\n    }\n\n    // locks the screen to prevent scroll\n    if (props.lockScroll) {\n      useLockscreen(visible)\n    }\n\n    // restore to prev active element.\n    useRestoreActive(visible)\n\n    return {\n      ...toRefs(state),\n      ns,\n      overlayEvent,\n      visible,\n      hasMessage,\n      typeClass,\n      contentId,\n      inputId,\n      btnSize,\n      iconComponent,\n      confirmButtonClasses,\n      rootRef,\n      focusStartRef,\n      headerRef,\n      inputRef,\n      confirmRef,\n      doClose, // for outside usage\n      handleClose, // for out side usage\n      onCloseRequested,\n      handleWrapperClick,\n      handleInputEnter,\n      handleAction,\n      t,\n    }\n  },\n})\n</script>\n","import { h, render, watch } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport {\n  hasOwn,\n  isObject,\n  isString,\n  isUndefined,\n  isVNode,\n} from '@element-plus/utils'\nimport MessageBoxConstructor from './index.vue'\n\nimport type { AppContext, ComponentPublicInstance, VNode } from 'vue'\nimport type {\n  Action,\n  Callback,\n  ElMessageBoxOptions,\n  IElMessageBox,\n  MessageBoxData,\n  MessageBoxState,\n} from './message-box.type'\n\n// component default merge props & data\n\nconst messageInstance = new Map<\n  ComponentPublicInstance<{ doClose: () => void }>, // marking doClose as function\n  {\n    options: any\n    callback: Callback\n    resolve: (res: any) => void\n    reject: (reason?: any) => void\n  }\n>()\n\nconst initInstance = (\n  props: any,\n  container: HTMLElement,\n  appContext: AppContext | null = null\n) => {\n  const vnode = h(MessageBoxConstructor, props)\n  vnode.appContext = appContext\n  render(vnode, container)\n  document.body.appendChild(container.firstElementChild!)\n  return vnode.component\n}\n\nconst genContainer = () => {\n  return document.createElement('div')\n}\n\nconst showMessage = (options: any, appContext?: AppContext | null) => {\n  const container = genContainer()\n  // Adding destruct method.\n  // when transition leaves emitting `vanish` evt. so that we can do the clean job.\n  options.onVanish = () => {\n    // not sure if this causes mem leak, need proof to verify that.\n    // maybe calling out like 1000 msg-box then close them all.\n    render(null, container)\n    messageInstance.delete(vm) // Remove vm to avoid mem leak.\n    // here we were suppose to call document.body.removeChild(container.firstElementChild)\n    // but render(null, container) did that job for us. so that we do not call that directly\n  }\n\n  options.onAction = (action: Action) => {\n    const currentMsg = messageInstance.get(vm)!\n    let resolve: Action | { value: string; action: Action }\n    if (options.showInput) {\n      resolve = { value: vm.inputValue, action }\n    } else {\n      resolve = action\n    }\n    if (options.callback) {\n      options.callback(resolve, instance.proxy)\n    } else {\n      if (action === 'cancel' || action === 'close') {\n        if (options.distinguishCancelAndClose && action !== 'cancel') {\n          currentMsg.reject('close')\n        } else {\n          currentMsg.reject('cancel')\n        }\n      } else {\n        currentMsg.resolve(resolve)\n      }\n    }\n  }\n\n  const instance = initInstance(options, container, appContext)!\n\n  // This is how we use message box programmably.\n  // Maybe consider releasing a template version?\n  // get component instance like v2.\n  const vm = instance.proxy as ComponentPublicInstance<\n    {\n      visible: boolean\n      doClose: () => void\n    } & MessageBoxState\n  >\n\n  for (const prop in options) {\n    if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {\n      vm[prop as string] = options[prop]\n    }\n  }\n\n  watch(\n    () => vm.message,\n    (newVal, oldVal) => {\n      if (isVNode(newVal)) {\n        // Override slots since message is vnode type.\n        instance.slots.default = () => [newVal]\n      } else if (isVNode(oldVal) && !isVNode(newVal)) {\n        delete instance.slots.default\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  // change visibility after everything is settled\n  vm.visible = true\n  return vm\n}\n\nasync function MessageBox(\n  options: ElMessageBoxOptions,\n  appContext?: AppContext | null\n): Promise<MessageBoxData>\nfunction MessageBox(\n  options: ElMessageBoxOptions | string | VNode,\n  appContext: AppContext | null = null\n): Promise<{ value: string; action: Action } | Action> {\n  if (!isClient) return Promise.reject()\n  let callback\n  if (isString(options) || isVNode(options)) {\n    options = {\n      message: options,\n    }\n  } else {\n    callback = options.callback\n  }\n\n  return new Promise((resolve, reject) => {\n    const vm = showMessage(options, appContext ?? MessageBox._context)\n    // collect this vm in order to handle upcoming events.\n    messageInstance.set(vm, {\n      options,\n      callback,\n      resolve,\n      reject,\n    })\n  })\n}\n\nconst MESSAGE_BOX_VARIANTS = ['alert', 'confirm', 'prompt'] as const\nconst MESSAGE_BOX_DEFAULT_OPTS: Record<\n  typeof MESSAGE_BOX_VARIANTS[number],\n  Partial<ElMessageBoxOptions>\n> = {\n  alert: { closeOnPressEscape: false, closeOnClickModal: false },\n  confirm: { showCancelButton: true },\n  prompt: { showCancelButton: true, showInput: true },\n}\n\nMESSAGE_BOX_VARIANTS.forEach((boxType) => {\n  MessageBox[boxType] = messageBoxFactory(boxType)\n})\n\nfunction messageBoxFactory(boxType: typeof MESSAGE_BOX_VARIANTS[number]) {\n  return (\n    message: string,\n    titleOrOpts: string | ElMessageBoxOptions,\n    options?: ElMessageBoxOptions,\n    appContext?: AppContext | null\n  ) => {\n    let title: string\n    if (isObject(titleOrOpts)) {\n      options = titleOrOpts\n      title = ''\n    } else if (isUndefined(titleOrOpts)) {\n      title = ''\n    } else {\n      title = titleOrOpts\n    }\n\n    return MessageBox(\n      Object.assign(\n        {\n          title,\n          message,\n          type: '',\n          ...MESSAGE_BOX_DEFAULT_OPTS[boxType],\n        },\n        options,\n        {\n          boxType,\n        }\n      ),\n      appContext\n    )\n  }\n}\n\nMessageBox.close = () => {\n  // instance.setupInstall.doClose()\n  // instance.setupInstall.state.visible = false\n\n  messageInstance.forEach((_, vm) => {\n    vm.doClose()\n  })\n\n  messageInstance.clear()\n}\n\nMessageBox._context = null\n\nexport default MessageBox as IElMessageBox\n","import MessageBox from './src/messageBox'\n\nimport type { App } from 'vue'\nimport type { SFCWithInstall } from '@element-plus/utils'\n\nconst _MessageBox = MessageBox as SFCWithInstall<typeof MessageBox>\n\n_MessageBox.install = (app: App) => {\n  _MessageBox._context = app._context\n  app.config.globalProperties.$msgbox = _MessageBox\n  app.config.globalProperties.$messageBox = _MessageBox\n  app.config.globalProperties.$alert = _MessageBox.alert\n  app.config.globalProperties.$confirm = _MessageBox.confirm\n  app.config.globalProperties.$prompt = _MessageBox.prompt\n}\n\nexport default _MessageBox\nexport const ElMessageBox = _MessageBox\n\nexport * from './src/message-box.type'\n","import { defineComponent, renderSlot, watch } from 'vue'\nimport { buildProps, definePropType } from '@element-plus/utils'\nimport { provideGlobalConfig } from '@element-plus/hooks'\n\nimport { componentSizes } from '@element-plus/constants'\nimport type { ExtractPropTypes } from 'vue'\nimport type { ExperimentalFeatures } from '@element-plus/tokens'\nimport type { Language } from '@element-plus/locale'\nimport type { ButtonConfigContext } from '@element-plus/components/button'\nimport type { MessageConfigContext } from '@element-plus/components/message'\n\nexport const messageConfig: MessageConfigContext = {}\n\nexport const configProviderProps = buildProps({\n  // Controlling if the users want a11y features.\n  a11y: {\n    type: Boolean,\n    default: true,\n  },\n\n  locale: {\n    type: definePropType<Language>(Object),\n  },\n\n  size: {\n    type: String,\n    values: componentSizes,\n    default: '',\n  },\n\n  button: {\n    type: definePropType<ButtonConfigContext>(Object),\n  },\n\n  experimentalFeatures: {\n    type: definePropType<ExperimentalFeatures>(Object),\n  },\n\n  // Controls if we should handle keyboard navigation\n  keyboardNavigation: {\n    type: Boolean,\n    default: true,\n  },\n\n  message: {\n    type: definePropType<MessageConfigContext>(Object),\n  },\n\n  zIndex: {\n    type: Number,\n  },\n\n  namespace: {\n    type: String,\n    default: 'el',\n  },\n} as const)\n\nexport default defineComponent({\n  name: 'ElConfigProvider',\n  props: configProviderProps,\n\n  setup(props, { slots }) {\n    watch(\n      () => props.message,\n      (val) => {\n        Object.assign(messageConfig, val ?? {})\n      },\n      { immediate: true, deep: true }\n    )\n    const config = provideGlobalConfig(props)\n    return () => renderSlot(slots, 'default', { config: config?.value })\n  },\n})\n\nexport type ConfigProviderProps = ExtractPropTypes<typeof configProviderProps>\n","import { buildProps } from '@element-plus/utils'\nimport type { ExtractPropTypes } from 'vue'\nimport type Badge from './badge.vue'\n\nexport const badgeProps = buildProps({\n  value: {\n    type: [String, Number],\n    default: '',\n  },\n  max: {\n    type: Number,\n    default: 99,\n  },\n  isDot: Boolean,\n  hidden: Boolean,\n  type: {\n    type: String,\n    values: ['primary', 'success', 'warning', 'info', 'danger'],\n    default: 'danger',\n  },\n} as const)\nexport type BadgeProps = ExtractPropTypes<typeof badgeProps>\n\nexport type BadgeInstance = InstanceType<typeof Badge>\n","<template>\n  <div :class=\"ns.b()\">\n    <slot />\n    <transition :name=\"`${ns.namespace.value}-zoom-in-center`\">\n      <sup\n        v-show=\"!hidden && (content || content === '0' || isDot)\"\n        :class=\"[\n          ns.e('content'),\n          ns.em('content', type),\n          ns.is('fixed', !!$slots.default),\n          ns.is('dot', isDot),\n        ]\"\n        v-text=\"content\"\n      />\n    </transition>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed } from 'vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport { isNumber } from '@element-plus/utils'\nimport { badgeProps } from './badge'\n\ndefineOptions({\n  name: 'ElBadge',\n})\n\nconst props = defineProps(badgeProps)\n\nconst ns = useNamespace('badge')\n\nconst content = computed<string>(() => {\n  if (props.isDot) return ''\n\n  if (isNumber(props.value) && isNumber(props.max)) {\n    return props.max < props.value ? `${props.max}+` : `${props.value}`\n  }\n  return `${props.value}`\n})\n\ndefineExpose({\n  /** @description badge content */\n  content,\n})\n</script>\n","import { withInstall } from '@element-plus/utils'\n\nimport Badge from './src/badge.vue'\n\nexport const ElBadge = withInstall(Badge)\nexport default ElBadge\n\nexport * from './src/badge'\n","import { buildProps, definePropType, iconPropType } from '@element-plus/utils'\nimport type { AppContext, ExtractPropTypes, VNode } from 'vue'\n\nexport const messageTypes = ['success', 'info', 'warning', 'error'] as const\n\nexport interface MessageConfigContext {\n  max?: number\n}\n\nexport const messageProps = buildProps({\n  customClass: {\n    type: String,\n    default: '',\n  },\n  center: {\n    type: Boolean,\n    default: false,\n  },\n  dangerouslyUseHTMLString: {\n    type: Boolean,\n    default: false,\n  },\n  duration: {\n    type: Number,\n    default: 3000,\n  },\n  icon: {\n    type: iconPropType,\n    default: '',\n  },\n  id: {\n    type: String,\n    default: '',\n  },\n  message: {\n    type: definePropType<string | VNode | (() => VNode)>([\n      String,\n      Object,\n      Function,\n    ]),\n    default: '',\n  },\n  onClose: {\n    type: definePropType<() => void>(Function),\n    required: false,\n  },\n  showClose: {\n    type: Boolean,\n    default: false,\n  },\n  type: {\n    type: String,\n    values: messageTypes,\n    default: 'info',\n  },\n  offset: {\n    type: Number,\n    default: 20,\n  },\n  zIndex: {\n    type: Number,\n    default: 0,\n  },\n  grouping: {\n    type: Boolean,\n    default: false,\n  },\n  repeatNum: {\n    type: Number,\n    default: 1,\n  },\n} as const)\nexport type MessageProps = ExtractPropTypes<typeof messageProps>\n\nexport const messageEmits = {\n  destroy: () => true,\n}\nexport type MessageEmits = typeof messageEmits\n\nexport type MessageOptions = Omit<MessageProps, 'id'> & {\n  appendTo?: HTMLElement | string\n}\nexport type MessageOptionsTyped = Omit<MessageOptions, 'type'>\n\nexport interface MessageHandle {\n  close: () => void\n}\n\nexport type MessageParams = Partial<MessageOptions> | string | VNode\nexport type MessageParamsTyped = Partial<MessageOptionsTyped> | string | VNode\n\nexport type MessageFn = ((\n  options?: MessageParams,\n  appContext?: null | AppContext\n) => MessageHandle) & {\n  closeAll(): void\n}\nexport type MessageTypedFn = (\n  options?: MessageParamsTyped,\n  appContext?: null | AppContext\n) => MessageHandle\n\nexport interface Message extends MessageFn {\n  success: MessageTypedFn\n  warning: MessageTypedFn\n  info: MessageTypedFn\n  error: MessageTypedFn\n}\n\ntype MessageQueueItem = {\n  vm: VNode\n}\n\nexport type MessageQueue = MessageQueueItem[]\n","<template>\n  <transition\n    :name=\"ns.b('fade')\"\n    @before-leave=\"onClose\"\n    @after-leave=\"$emit('destroy')\"\n  >\n    <div\n      v-show=\"visible\"\n      :id=\"id\"\n      :class=\"[\n        ns.b(),\n        { [ns.m(type)]: type && !icon },\n        ns.is('center', center),\n        ns.is('closable', showClose),\n        customClass,\n      ]\"\n      :style=\"customStyle\"\n      role=\"alert\"\n      @mouseenter=\"clearTimer\"\n      @mouseleave=\"startTimer\"\n    >\n      <el-badge\n        v-if=\"repeatNum > 1\"\n        :value=\"repeatNum\"\n        :type=\"badgeType\"\n        :class=\"ns.e('badge')\"\n      />\n      <el-icon v-if=\"iconComponent\" :class=\"[ns.e('icon'), typeClass]\">\n        <component :is=\"iconComponent\" />\n      </el-icon>\n      <slot>\n        <p v-if=\"!dangerouslyUseHTMLString\" :class=\"ns.e('content')\">\n          {{ message }}\n        </p>\n        <!-- Caution here, message could've been compromised, never use user's input as message -->\n        <p v-else :class=\"ns.e('content')\" v-html=\"message\" />\n      </slot>\n      <el-icon v-if=\"showClose\" :class=\"ns.e('closeBtn')\" @click.stop=\"close\">\n        <close />\n      </el-icon>\n    </div>\n  </transition>\n</template>\n<script lang=\"ts\">\nimport { computed, defineComponent, onMounted, ref, watch } from 'vue'\nimport { useEventListener, useTimeoutFn } from '@vueuse/core'\nimport { TypeComponents, TypeComponentsMap } from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport ElBadge from '@element-plus/components/badge'\nimport { ElIcon } from '@element-plus/components/icon'\n\nimport { useNamespace } from '@element-plus/hooks'\nimport { messageEmits, messageProps } from './message'\nimport type { BadgeProps } from '@element-plus/components/badge'\n\nimport type { CSSProperties } from 'vue'\n\nexport default defineComponent({\n  name: 'ElMessage',\n\n  components: {\n    ElBadge,\n    ElIcon,\n    ...TypeComponents,\n  },\n\n  props: messageProps,\n  emits: messageEmits,\n\n  setup(props) {\n    const ns = useNamespace('message')\n    const visible = ref(false)\n    const badgeType = ref<BadgeProps['type']>(\n      props.type ? (props.type === 'error' ? 'danger' : props.type) : 'info'\n    )\n    let stopTimer: (() => void) | undefined = undefined\n\n    const typeClass = computed(() => {\n      const type = props.type\n      return { [ns.bm('icon', type)]: type && TypeComponentsMap[type] }\n    })\n\n    const iconComponent = computed(() => {\n      return props.icon || TypeComponentsMap[props.type] || ''\n    })\n\n    const customStyle = computed<CSSProperties>(() => ({\n      top: `${props.offset}px`,\n      zIndex: props.zIndex,\n    }))\n\n    function startTimer() {\n      if (props.duration > 0) {\n        ;({ stop: stopTimer } = useTimeoutFn(() => {\n          if (visible.value) close()\n        }, props.duration))\n      }\n    }\n\n    function clearTimer() {\n      stopTimer?.()\n    }\n\n    function close() {\n      visible.value = false\n    }\n\n    function keydown({ code }: KeyboardEvent) {\n      if (code === EVENT_CODE.esc) {\n        // press esc to close the message\n        if (visible.value) {\n          close()\n        }\n      } else {\n        startTimer() // resume timer\n      }\n    }\n\n    onMounted(() => {\n      startTimer()\n      visible.value = true\n    })\n\n    watch(\n      () => props.repeatNum,\n      () => {\n        clearTimer()\n        startTimer()\n      }\n    )\n\n    useEventListener(document, 'keydown', keydown)\n\n    return {\n      ns,\n      typeClass,\n      iconComponent,\n      customStyle,\n      visible,\n      badgeType,\n\n      close,\n      clearTimer,\n      startTimer,\n    }\n  },\n})\n</script>\n","import { createVNode, render } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport {\n  debugWarn,\n  isElement,\n  isFunction,\n  isNumber,\n  isObject,\n  isString,\n  isVNode,\n} from '@element-plus/utils'\nimport { useZIndex } from '@element-plus/hooks'\nimport { messageConfig } from '@element-plus/components/config-provider/src/config-provider'\nimport MessageConstructor from './message.vue'\nimport { messageTypes } from './message'\n\nimport type { AppContext, ComponentPublicInstance, VNode } from 'vue'\nimport type { Message, MessageFn, MessageProps, MessageQueue } from './message'\n\nconst instances: MessageQueue = []\nlet seed = 1\n\n// TODO: Since Notify.ts is basically the same like this file. So we could do some encapsulation against them to reduce code duplication.\n\nconst message: MessageFn & Partial<Message> & { _context: AppContext | null } =\n  function (options = {}, context?: AppContext | null) {\n    if (!isClient) return { close: () => undefined }\n    if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {\n      return { close: () => undefined }\n    }\n\n    if (\n      !isVNode(options) &&\n      isObject(options) &&\n      options.grouping &&\n      !isVNode(options.message) &&\n      instances.length\n    ) {\n      const tempVm: any = instances.find(\n        (item) =>\n          `${item.vm.props?.message ?? ''}` ===\n          `${(options as any).message ?? ''}`\n      )\n      if (tempVm) {\n        tempVm.vm.component!.props.repeatNum += 1\n        tempVm.vm.component!.props.type = options?.type || 'info'\n        return {\n          close: () =>\n            ((\n              vm.component!.proxy as ComponentPublicInstance<{\n                visible: boolean\n              }>\n            ).visible = false),\n        }\n      }\n    }\n\n    if (isString(options) || isVNode(options)) {\n      options = { message: options }\n    }\n\n    let verticalOffset = options.offset || 20\n    instances.forEach(({ vm }) => {\n      verticalOffset += (vm.el?.offsetHeight || 0) + 16\n    })\n    verticalOffset += 16\n\n    const { nextZIndex } = useZIndex()\n\n    const id = `message_${seed++}`\n    const userOnClose = options.onClose\n    const props: Partial<MessageProps> = {\n      zIndex: nextZIndex(),\n      ...options,\n      offset: verticalOffset,\n      id,\n      onClose: () => {\n        close(id, userOnClose)\n      },\n    }\n\n    let appendTo: HTMLElement | null = document.body\n    if (isElement(options.appendTo)) {\n      appendTo = options.appendTo\n    } else if (isString(options.appendTo)) {\n      appendTo = document.querySelector(options.appendTo)\n    }\n    // should fallback to default value with a warning\n    if (!isElement(appendTo)) {\n      debugWarn(\n        'ElMessage',\n        'the appendTo option is not an HTMLElement. Falling back to document.body.'\n      )\n      appendTo = document.body\n    }\n\n    const container = document.createElement('div')\n\n    container.className = `container_${id}`\n\n    const messageContent = props.message\n    const vm = createVNode(\n      MessageConstructor,\n      props,\n      isFunction(messageContent)\n        ? { default: messageContent }\n        : isVNode(messageContent)\n        ? { default: () => messageContent }\n        : null\n    )\n\n    vm.appContext = context || message._context\n\n    // clean message element preventing mem leak\n    vm.props!.onDestroy = () => {\n      render(null, container)\n      // since the element is destroy, then the VNode should be collected by GC as well\n      // we do not want cause any mem leak because we have returned vm as a reference to users\n      // so that we manually set it to false.\n    }\n\n    render(vm, container)\n    // instances will remove this item when close function gets called. So we do not need to worry about it.\n    instances.push({ vm })\n    appendTo.appendChild(container.firstElementChild!)\n\n    return {\n      // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle\n      // for out component, so that all closing steps will not be skipped.\n      close: () =>\n        ((\n          vm.component!.proxy as ComponentPublicInstance<{ visible: boolean }>\n        ).visible = false),\n    }\n  }\n\nmessageTypes.forEach((type) => {\n  message[type] = (options = {}, appContext?: AppContext | null) => {\n    if (isString(options) || isVNode(options)) {\n      options = {\n        message: options,\n      }\n    }\n    return message(\n      {\n        ...options,\n        type,\n      },\n      appContext\n    )\n  }\n})\n\nexport function close(id: string, userOnClose?: (vm: VNode) => void): void {\n  const idx = instances.findIndex(({ vm }) => id === vm.component!.props.id)\n  if (idx === -1) return\n\n  const { vm } = instances[idx]\n  if (!vm) return\n  userOnClose?.(vm)\n\n  const removedHeight = vm.el!.offsetHeight\n  instances.splice(idx, 1)\n\n  // adjust other instances vertical offset\n  const len = instances.length\n  if (len < 1) return\n  for (let i = idx; i < len; i++) {\n    const pos =\n      Number.parseInt(instances[i].vm.el!.style['top'], 10) - removedHeight - 16\n\n    instances[i].vm.component!.props.offset = pos\n  }\n}\n\nexport function closeAll(): void {\n  for (let i = instances.length - 1; i >= 0; i--) {\n    const instance = instances[i].vm.component\n    ;(instance?.proxy as any)?.close()\n  }\n}\n\nmessage.closeAll = closeAll\nmessage._context = null\n\nexport default message as Message\n","import { withInstallFunction } from '@element-plus/utils'\n\nimport Message from './src/message-method'\n\nexport const ElMessage = withInstallFunction(Message, '$message')\nexport default ElMessage\n\nexport * from './src/message'\n","import { resolveComponent as _resolveComponent, createVNode as _createVNode, createElementVNode as _createElementVNode, unref as _unref, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, createStaticVNode as _createStaticVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nimport _imports_0 from './images/pay2.jpg';\nimport _imports_1 from './images/pay3.jpg';\nimport _imports_2 from './images/pay10.jpg';\nimport _imports_3 from './images/pay11.jpg';\nimport _imports_4 from './images/pay12.jpg';\nimport _imports_5 from './images/pay13.jpg';\nimport _imports_6 from './images/pay14.jpg';\nimport _imports_7 from './images/pay15.jpg';\nimport _imports_8 from './images/pay16.jpg';\nimport _imports_9 from './images/pay17.jpg';\nimport _imports_10 from './images/pay18.jpg';\nimport _imports_11 from './images/pay19.jpg';\nimport _imports_12 from './images/pay20.jpg';\nimport _imports_13 from './images/pay21.jpg';\nimport _imports_14 from './images/pay22.jpg';\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-05f80324\"), n = n(), _popScopeId(), n);\n\nconst _hoisted_1 = {\n  class: \"pay-main\"\n};\nconst _hoisted_2 = {\n  class: \"pay-container\"\n};\nconst _hoisted_3 = {\n  class: \"checkout-tit\"\n};\n\nconst _hoisted_4 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"h4\", {\n  class: \"tit-txt\"\n}, [/*#__PURE__*/_createElementVNode(\"span\", {\n  class: \"success-icon\"\n}), /*#__PURE__*/_createElementVNode(\"span\", {\n  class: \"success-info\"\n}, \"~~\")], -1));\n\nconst _hoisted_5 = {\n  class: \"paymark\"\n};\nconst _hoisted_6 = {\n  class: \"fl\"\n};\n\nconst _hoisted_7 = /*#__PURE__*/_createTextVNode(\"\");\n\nconst _hoisted_8 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"em\", {\n  class: \"orange time\"\n}, \"4\", -1));\n\nconst _hoisted_9 = /*#__PURE__*/_createTextVNode(\"\");\n\nconst _hoisted_10 = {\n  class: \"fr\"\n};\n\nconst _hoisted_11 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"em\", {\n  class: \"lead\"\n}, \"\", -1));\n\nconst _hoisted_12 = {\n  class: \"orange money\"\n};\n\nconst _hoisted_13 = /*#__PURE__*/_createStaticVNode(\"<div class=\\\"checkout-info\\\" data-v-05f80324><h4 data-v-05f80324></h4><ol data-v-05f80324><li data-v-05f80324><span class=\\\"zfb\\\" data-v-05f80324></span></li><li data-v-05f80324></li><li data-v-05f80324></li></ol><h4 data-v-05f80324><span class=\\\"save\\\" data-v-05f80324></span></h4><ul data-v-05f80324><li data-v-05f80324>11111111</li><li data-v-05f80324>111111</li><li data-v-05f80324>111111</li></ul></div>\", 1);\n\nconst _hoisted_14 = /*#__PURE__*/_createStaticVNode(\"<div class=\\\"step-tit\\\" data-v-05f80324><h5 data-v-05f80324></h5></div><div class=\\\"step-cont\\\" data-v-05f80324><ul class=\\\"payType\\\" data-v-05f80324><li data-v-05f80324><img src=\\\"\" + _imports_0 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_1 + \"\\\" data-v-05f80324></li></ul></div><div class=\\\"hr\\\" data-v-05f80324></div><div class=\\\"payshipInfo\\\" data-v-05f80324><div class=\\\"step-tit\\\" data-v-05f80324><h5 data-v-05f80324></h5></div><div class=\\\"step-cont\\\" data-v-05f80324><ul class=\\\"payType\\\" data-v-05f80324><li data-v-05f80324><img src=\\\"\" + _imports_2 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_3 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_4 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_5 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_6 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_7 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_8 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_9 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_10 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_11 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_12 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_13 + \"\\\" data-v-05f80324></li><li data-v-05f80324><img src=\\\"\" + _imports_14 + \"\\\" data-v-05f80324></li></ul></div></div><div class=\\\"hr\\\" data-v-05f80324></div>\", 5);\n\nconst __default__ = {\n  name: 'Pay'\n};\nimport useTradeStore from '@/store/Trade';\nimport { storeToRefs } from 'pinia';\nimport { computed, onMounted, ref } from 'vue';\nimport { useRoute, useRouter } from 'vue-router';\nimport { ElMessageBox, ElMessage } from 'element-plus';\nexport default /*#__PURE__*/Object.assign(__default__, {\n  setup(__props) {\n    const route = useRoute();\n    const store = useTradeStore();\n    const router = useRouter();\n    let timer = '';\n    let {\n      payInfo,\n      vxUrl,\n      payStatus\n    } = storeToRefs(store);\n    let orderId = computed(() => {\n      return route.query.orderId;\n    });\n\n    function handlePay() {\n      ElMessageBox.alert(`<img src=\"${vxUrl.value}\" /> `, {\n        dangerouslyUseHTMLString: true,\n        title: '',\n        center: true,\n        showCancelButton: true,\n        showClose: false,\n        cancelButtonText: '',\n        confirmButtonText: '',\n        beforeClose: function (action, instance, done) {\n          if (action === 'cancel') {\n            ElMessage({\n              message: '',\n              type: 'warning'\n            });\n            clearInterval(timer);\n            timer = null;\n            done();\n          } else if (action === 'confirm') {\n            if (payStatus.value == 200) {\n              ElMessage({\n                message: ' ',\n                type: 'success'\n              });\n              clearInterval(timer);\n              timer = null;\n              done();\n              router.push('/paySuccess');\n            } else {\n              ElMessage({\n                message: '',\n                type: 'warning'\n              });\n            }\n          }\n        }\n      });\n\n      if (!timer) {\n        timer = setInterval(async () => {\n          try {\n            await store.getPayStatus(orderId.value);\n\n            if (payStatus.value == 200) {\n              clearInterval(timer);\n              timer = null;\n              ElMessageBox.close(false);\n              router.push('/paySuccess');\n            } else {}\n          } catch (error) {}\n        }, 1000);\n      }\n    }\n\n    onMounted(() => {\n      store.getPayInfo(orderId.value);\n    });\n    return (_ctx, _cache) => {\n      const _component_TypeNav = _resolveComponent(\"TypeNav\");\n\n      return _openBlock(), _createElementBlock(_Fragment, null, [_createVNode(_component_TypeNav), _createElementVNode(\"div\", _hoisted_1, [_createElementVNode(\"div\", _hoisted_2, [_createElementVNode(\"div\", _hoisted_3, [_hoisted_4, _createElementVNode(\"div\", _hoisted_5, [_createElementVNode(\"span\", _hoisted_6, [_hoisted_7, _hoisted_8, _hoisted_9, _createElementVNode(\"em\", null, _toDisplayString(_unref(orderId)), 1)]), _createElementVNode(\"span\", _hoisted_10, [_hoisted_11, _createElementVNode(\"em\", _hoisted_12, \"\" + _toDisplayString(_unref(payInfo).totalFee), 1)])])]), _hoisted_13, _createElementVNode(\"div\", {\n        class: \"checkout-steps\"\n      }, [_hoisted_14, _createElementVNode(\"div\", {\n        class: \"submit\"\n      }, [_createElementVNode(\"a\", {\n        class: \"btn\",\n        onClick: handlePay\n      }, \"\")])])])])], 64);\n    };\n  }\n\n});","/* unplugin-vue-components disabled */import script from \"./index.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./index.vue?vue&type=script&setup=true&lang=js\"\n\nimport \"./index.vue?vue&type=style&index=0&id=05f80324&lang=less&scoped=true\"\n\nimport exportComponent from \"D:\\\\web\\\\Vue\\\\shop\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-05f80324\"]])\n\nexport default __exports__"],"names":["Object","defineProperty","defineProperties","getOwnPropertyDescriptors","getOwnPropertySymbols","prototype","hasOwnProperty","propertyIsEnumerable","tryOnScopeDispose","fn","getCurrentScope","onScopeDispose","isVue3","_a","isClient","window","isNumber","toString","val","isString","noop","navigator","userAgent","test","useTimeoutFn","cb","interval","options","immediate","isPending","ref","timer","clear","clearTimeout","stop","value","start","args","setTimeout","unref","fromPairs","pairs","index","length","result","pair","wrapperKey","Symbol","propKey","buildProp","option","key","isObject","values","required","default","defaultValue","type","validator","_validator","valid","allowedValues","Array","from","hasOwn","push","includes","allowValuesText","Set","map","JSON","stringify","join","warn","prop","buildProps","props","entries","definePropType","iconProps","size","Number","String","color","sfc","target","__vccOpts","configProviderContextKey","ElementPlusError","Error","constructor","m","name","throwError","scope","debugWarn","message","process","keysOf","arr","keys","globalConfig","useGlobalConfig","config","getCurrentInstance","inject","computed","_b","provideGlobalConfig","app","global","inSetup","oldConfig","provideFn","provide","context","cfg","mergeConfig","a","b","obj","defaultNamespace","statePrefix","_bem","namespace","block","blockSuffix","element","modifier","cls","useNamespace","e","be","em","bm","bem","is","state","cssVar","object","styles","cssVarBlock","cssVarName","cssVarBlockName","isUndefined","isElement","Element","SCOPE","classNameToArray","split","filter","item","trim","hasClass","el","classList","contains","addClass","add","removeClass","remove","getStyle","styleName","camelize","style","document","defaultView","getComputedStyle","addUnit","defaultUnit","ns","fontSize","withInstall","main","extra","install","comp","component","withInstallFunction","_context","globalProperties","withNoopInstall","NOOP","ElIcon","Icon","_export_sfc","_sfc_main","defineComponent","_hoisted_1","viewBox","xmlns","_hoisted_2","createElementVNode","fill","d","_hoisted_3","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","openBlock","createElementBlock","loading","useProp","vm","proxy","componentSizes","formContextKey","formItemContextKey","useSizeProp","useSize","fallback","ignore","emptyRef","form","formItem","useDisabled","disabled","close","successFilled","infoFilled","warningFilled","circleCloseFilled","_hoisted_4","circleCheck","circleClose","iconPropType","Function","TypeComponents","Close","SuccessFilled","InfoFilled","WarningFilled","CircleCloseFilled","TypeComponentsMap","success","warning","error","info","ValidateComponentsMap","validating","Loading","CircleCheck","CircleClose","buttonTypes","buttonNativeTypes","buttonProps","Boolean","icon","nativeType","loadingIcon","plain","text","link","bg","autofocus","round","circle","dark","autoInsertSpace","buttonEmits","click","evt","MouseEvent","bound01","n","max","isOnePointZero","isPercent","isPercentage","Math","min","parseFloat","parseInt","abs","clamp01","indexOf","boundAlpha","isNaN","convertToPercentage","concat","pad2","c","rgbToRgb","r","g","rgbToHsl","h","s","l","hue2rgb","p","q","t","hslToRgb","rgbToHsv","v","hsvToRgb","i","floor","f","mod","rgbToHex","allow3Char","hex","startsWith","charAt","rgbaToHex","allow4Char","convertDecimalToHex","convertHexToDecimal","parseIntFromHex","numberInputToObject","names","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","goldenrod","gold","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavenderblush","lavender","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","inputToRGB","rgb","ok","format","stringInputToObject","isValidCSSUnit","substr","call","CSS_INTEGER","CSS_NUMBER","CSS_UNIT","PERMISSIVE_MATCH3","PERMISSIVE_MATCH4","matchers","RegExp","rgba","hsl","hsla","hsv","hsva","hex3","hex6","hex4","hex8","toLowerCase","named","match","exec","TinyColor","opts","this","originalInput","roundA","gradientType","isValid","isDark","getBrightness","isLight","toRgb","getLuminance","R","G","B","RsRGB","GsRGB","BsRGB","pow","getAlpha","setAlpha","alpha","toHsv","toHsvString","toHsl","toHslString","toHex","toHexString","toHex8","toHex8String","toRgbString","toPercentageRgb","fmt","x","toPercentageRgbString","rnd","toName","_i","formatSet","formattedString","hasAlpha","needsAlphaFormat","toNumber","clone","lighten","amount","brighten","darken","tint","mix","shade","desaturate","saturate","greyscale","spin","hue","rgb1","rgb2","analogous","results","slices","part","ret","complement","monochromatic","res","modification","splitcomplement","onBackground","background","fg","triad","polyad","tetrad","increment","equals","useButtonCustomStyle","_disabled","buttonColor","activeBgColor","hoverBgColor","textColor","disabledButtonColor","useDeprecated","replacement","version","condition","watch","buttonGroupContextKey","defaultIdInjection","prefix","random","current","ID_INJECTION_KEY","useId","deterministicId","idInjection","idRef","useFormItem","useFormItemInputId","formItemContext","disableIdGeneration","disableIdManagement","inputId","idUnwatch","isLabeledByFormItem","label","inputIds","onMounted","toRef","id","disableIdGeneration2","newId","removeInputId","addInputId","onUnmounted","slots","buttonGroupContext","_size","_ref","_type","emit","expose","buttonGroupProps","reactive","ElButton","Button","ButtonGroup","unrefElement","elRef","$el","defaultWindow","location","useEventListener","event","listener","cleanup","stopWatch","addEventListener","removeEventListener","flush","_global","globalThis","self","globalKey","__getOwnPropSymbols$c","__hasOwnProp$c","__propIsEnum$c","__objRest$2","source","exclude","useResizeObserver","callback","observerOptions","observer","isSupported","disconnect","ResizeObserver","observe","isNil","view","hide","hiddenTextarea","HIDDEN_STYLE","CONTEXT_STYLE","calculateNodeStyling","targetElement","boxSizing","getPropertyValue","paddingSize","borderSize","contextStyle","calcTextareaHeight","minRows","maxRows","createElement","body","appendChild","setAttribute","placeholder","height","scrollHeight","singleRowHeight","minHeight","maxHeight","parentNode","removeChild","mutable","UPDATE_MODEL_EVENT","inputProps","modelValue","resize","autosize","autocomplete","formatter","parser","readonly","clearable","showPassword","showWordLimit","suffixIcon","prefixIcon","containerRole","tabindex","validateEvent","inputStyle","inputEmits","input","change","focus","FocusEvent","blur","mouseleave","mouseenter","keydown","Event","compositionstart","CompositionEvent","compositionupdate","compositionend","DEFAULT_EXCLUDE_KEYS","LISTENER_PREFIX","useAttrs","params","excludeListeners","excludeKeys","allExcludeKeys","instance","$attrs","useCursor","selectionRef","recordCursor","selectionStart","selectionEnd","beforeTxt","slice","afterTxt","setCursor","startPos","endsWith","beforeLastChar","newIndex","setSelectionRange","isKorean","PENDANT_MAP","suffix","rawAttrs","containerAttrs","comboBoxAttrs","attrs","inputSize","inputDisabled","nsInput","nsTextarea","textarea","focused","hovering","isComposing","passwordVisible","countStyle","textareaCalcStyle","needStatusIcon","validateIcon","passwordIcon","width","right","input2","calcIconOffset","setNativeInputValue","handleInput","nextTick","resizeTextarea","updateIconOffset","onUpdated","ElInput","Input","useSameTarget","handleClick","onClick","onMousedown","onMouseup","mousedownTarget","mouseupTarget","currentTarget","PatchFlags","PatchFlags2","overlayProps","mask","customMaskEvent","overlayClass","zIndex","overlayEmits","emits","setup","onMaskClick","createVNode","class","renderSlot","position","top","bottom","left","ElOverlay","Overlay","EVENT_CODE","tab","enter","space","up","down","esc","delete","backspace","numpadEnter","pageUp","pageDown","home","end","FOCUSABLE_ELEMENT_SELECTORS","isVisible","offsetParent","obtainAllFocusableElements","querySelectorAll","isFocusable","tabIndex","getAttribute","nodeName","href","rel","on","handler","useCapture","off","FOCUSABLE_CHILDREN","FOCUS_STACK","FOCUS_HANDLER","focusableElement","code","preventDefault","activeElement","goingBackward","shiftKey","isFirst","isLast","TrapFocus","beforeMount","updated","unmounted","shift","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","getVisibleElement","elements","container","isHidden","visibility","display","parentElement","getEdges","focusable","first","last","reverse","isSelectable","HTMLInputElement","tryFocus","shouldSelect","prevFocusedElement","preventScroll","select","removeFromStack","list","copy","idx","splice","createFocusableStack","stack","layer","currentLayer","pause","unshift","resume","focusFirstDescendant","focusableStack","FOCUS_AFTER_TRAPPED","FOCUS_AFTER_RELEASED","FOCUS_AFTER_TRAPPED_OPTS","cancelable","bubbles","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","FOCUS_TRAP_INJECTION_KEY","registeredEscapeHandlers","useEscapeKeydown","cachedHandler","forEach","registeredHandler","onBeforeUnmount","inheritAttrs","loop","trapped","focusTrapEl","focusStartEl","forwardRef","lastFocusBeforeTrapped","lastFocusAfterTrapped","focusLayer","paused","onKeydown","altKey","ctrlKey","metaKey","isTabbing","currentFocusingEl","isTabbable","focusTrapRef","forwardRef2","oldForwardRef","onFocusIn","onFocusOut","trapOnFocus","releaseOnFocus","trapContainer","isFocusedInTrap","relatedTarget","isPrevFocusContained","focusEvent","dispatchEvent","defaultPrevented","releasedEvent","startTrap","stopTrap","_renderSlot","handleKeydown","isValidComponentSize","isArray","freeGlobal","freeSelf","root","objectProto","nativeObjectToString","symToStringTag","undefined","getRawTag","isOwn","tag","unmasked","objectToString","nullTag","undefinedTag","baseGetTag","isObjectLike","symbolTag","isSymbol","reIsDeepProp","reIsPlainProp","isKey","asyncTag","funcTag","genTag","proxyTag","isFunction","coreJsData","maskSrcKey","uid","isMasked","func","funcProto","funcToString","toSource","reRegExpChar","reIsHostCtor","reIsNative","replace","baseIsNative","pattern","getValue","getNative","nativeCreate","hashClear","__data__","hashDelete","has","HASH_UNDEFINED","hashGet","data","hashHas","hashSet","Hash","entry","set","get","listCacheClear","eq","other","assocIndexOf","array","arrayProto","listCacheDelete","lastIndex","pop","listCacheGet","listCacheHas","listCacheSet","ListCache","Map","mapCacheClear","isKeyable","getMapData","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","FUNC_ERROR_TEXT","memoize","resolver","TypeError","memoized","arguments","apply","cache","Cache","MAX_MEMOIZE_SIZE","memoizeCapped","rePropName","reEscapeChar","stringToPath","string","charCodeAt","number","quote","subString","arrayMap","iteratee","INFINITY","symbolProto","symbolToString","baseToString","castPath","toKey","baseGet","path","colorpicker","confirm","defaultLabel","description","datepicker","now","today","cancel","dateTablePrompt","monthTablePrompt","yearTablePrompt","selectedDate","selectDate","selectTime","startDate","startTime","endDate","endTime","prevYear","nextYear","prevMonth","nextMonth","year","month1","month2","month3","month4","month5","month6","month7","month8","month9","month10","month11","month12","week","weeks","sun","mon","tue","wed","thu","fri","sat","weeksFull","months","jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec","inputNumber","decrease","increase","noMatch","noData","cascader","pagination","goto","pagesize","total","pageClassifier","deprecationWarning","dialog","drawer","messagebox","title","upload","deleteTip","preview","continue","slider","defaultRangeStartLabel","defaultRangeEndLabel","table","emptyText","confirmFilter","resetFilter","clearFilter","sumText","tree","transfer","titles","filterPlaceholder","noCheckedFormat","hasCheckedFormat","image","pageHeader","popconfirm","confirmButtonText","cancelButtonText","buildTranslator","locale","translate","_","buildLocaleContext","lang","localeRef","isRef","useLocale","English","useZIndex","initialZIndex","currentZIndex","nextZIndex","useDraggable","targetRef","dragRef","draggable","transform","offsetX","offsetY","downX","clientX","downY","clientY","targetRect","getBoundingClientRect","targetLeft","targetTop","targetWidth","targetHeight","clientWidth","documentElement","clientHeight","minLeft","minTop","maxLeft","maxTop","onMousemove","e2","moveX","moveY","onDraggable","offDraggable","watchEffect","scrollBarWidth","getScrollBarWidth","outer","className","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","useLockscreen","trigger","withoutHiddenClass","bodyPaddingRight","computedBodyPaddingRight","paddingRight","bodyHasOverflow","bodyOverflowY","useRestoreActive","toggle","initialFocus","previousActive","directives","components","ElFocusTrap","buttonSize","modal","lockScroll","showClose","closeOnClickModal","closeOnPressEscape","closeOnHashChange","center","roundButton","boxType","visible","beforeClose","cancelButtonClass","confirmButtonClass","customClass","customStyle","dangerouslyUseHTMLString","distinguishCancelAndClose","inputPattern","inputPlaceholder","inputType","inputValue","inputValidator","inputErrorMessage","modalFade","modalClass","showCancelButton","showConfirmButton","showInput","action","confirmButtonLoading","cancelButtonLoading","confirmButtonDisabled","editorErrorMessage","validateError","typeClass","contentId","btnSize","iconComponent","hasMessage","rootRef","headerRef","focusStartRef","inputRef","confirmRef","confirmButtonClasses","async","validate","handleAction","handleInputEnter","doClose","$refs","inputRefs","handleClose","overlayEvent","onCloseRequested","handleWrapperClick","_component_el_focus_trap","onAfterLeave","_withDirectives","role","_createVNode","onReleaseRequested","_withModifiers","_openBlock","_createElementVNode","_createCommentVNode","_withKeys","for","_createTextVNode","invalid","_toDisplayString","$event","messageInstance","initInstance","appContext","vnode","MessageBoxConstructor","render","firstElementChild","genContainer","showMessage","onVanish","onAction","currentMsg","resolve","reject","newVal","oldVal","isVNode","MessageBox","Promise","MESSAGE_BOX_VARIANTS","MESSAGE_BOX_DEFAULT_OPTS","alert","prompt","messageBoxFactory","titleOrOpts","assign","_MessageBox","$msgbox","$messageBox","$alert","$confirm","$prompt","ElMessageBox","messageConfig","configProviderProps","a11y","button","experimentalFeatures","keyboardNavigation","deep","badgeProps","isDot","content","ElBadge","Badge","messageTypes","messageProps","duration","onClose","offset","grouping","repeatNum","messageEmits","destroy","badgeType","stopTimer","startTimer","clearTimer","_createBlock","onBeforeLeave","_normalizeStyle","onMouseenter","onMouseleave","_normalizeClass","_resolveDynamicComponent","_createElementBlock","innerHTML","instances","seed","tempVm","find","_c","verticalOffset","vm2","offsetHeight","userOnClose","appendTo","querySelector","messageContent","MessageConstructor","onDestroy","findIndex","removedHeight","len","pos","closeAll","ElMessage","Message","_withScopeId","_hoisted_5","_hoisted_6","_hoisted_7","_hoisted_8","_hoisted_9","_hoisted_10","_hoisted_11","_hoisted_12","_hoisted_13","_hoisted_14","__props","route","store","router","payInfo","vxUrl","payStatus","orderId","query","handlePay","done","clearInterval","setInterval","getPayStatus","getPayInfo","_component_TypeNav","totalFee","__exports__"],"sourceRoot":""}